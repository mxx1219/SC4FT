package edu.stanford.nlp.trees;
import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.locks.Lock;
import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.StringLabel;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.parser.lexparser.TreebankLangParserParams;
import edu.stanford.nlp.process.PTBTokenizer;
import edu.stanford.nlp.process.WhitespaceTokenizer;
import edu.stanford.nlp.trees.GrammaticalRelation.GrammaticalRelationAnnotation;
import edu.stanford.nlp.util.ErasureUtils;
import edu.stanford.nlp.util.Filter;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.Function;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.ReflectionLoading;
import edu.stanford.nlp.util.StringUtils;
import edu.stanford.nlp.trees.GrammaticalRelation.DEPENDENT;
import edu.stanford.nlp.trees.GrammaticalRelation.GOVERNOR;
import edu.stanford.nlp.trees.GrammaticalRelation.ROOT;
public abstract class GrammaticalStructure extends TreeGraph {
  private static final boolean PRINT_DEBUGGING=false;
  protected final Set<Dependency<Label,Label,Object>> dependencies;
  protected final List<TypedDependency> typedDependencies;
  protected final List<TypedDependency> allTypedDependencies;
  protected final Filter<String> puncFilter;
  public GrammaticalStructure(  Tree t,  Collection<GrammaticalRelation> relations,  Lock relationsLock,  HeadFinder hf,  Filter<String> puncFilter){
    super(t);
    root.percolateHeads(hf);
    if (root.value() == null) {
      root.setValue("ROOT");
    }
    this.puncFilter=puncFilter;
    NoPunctFilter puncDepFilter=new NoPunctFilter(puncFilter);
    NoPunctTypedDependencyFilter puncTypedDepFilter=new NoPunctTypedDependencyFilter(puncFilter);
    dependencies=root.dependencies(puncDepFilter,null);
    for (    Dependency<Label,Label,Object> p : dependencies) {
      TreeGraphNode gov=(TreeGraphNode)p.governor();
      TreeGraphNode dep=(TreeGraphNode)p.dependent();
      dep.addArc(GrammaticalRelation.getAnnotationClass(GOVERNOR),gov);
    }
    if (relationsLock != null) {
      relationsLock.lock();
    }
    try {
      analyzeNode(root,root,relations);
    }
  finally {
      if (relationsLock != null) {
        relationsLock.unlock();
      }
    }
    typedDependencies=getDeps(false,puncTypedDepFilter);
    allTypedDependencies=getDeps(true,puncTypedDepFilter);
  }
  private static void throwDepFormatException(  String dep){
    throw new RuntimeException(String.format("Dependencies should be for the format 'type(arg-idx, arg-idx)'. Could not parse '%s'",dep));
  }
  public static GrammaticalStructure fromStringReps(  List<String> tokens,  List<String> posTags,  List<String> deps){
    if (tokens.size() != posTags.size()) {
      throw new RuntimeException(String.format("tokens.size(): %d != pos.size(): %d\n",tokens.size(),posTags.size()));
    }
    List<TreeGraphNode> tgWordNodes=new ArrayList<TreeGraphNode>(tokens.size());
    List<TreeGraphNode> tgPOSNodes=new ArrayList<TreeGraphNode>(tokens.size());
    SemanticHeadFinder headFinder=new SemanticHeadFinder();
    Iterator<String> posIter=posTags.iterator();
    for (    String wordString : tokens) {
      String posString=posIter.next();
      TreeGraphNode word=new TreeGraphNode(new Word(wordString));
      TreeGraphNode pos=new TreeGraphNode(new Word(posString));
      tgWordNodes.add(word);
      tgPOSNodes.add(pos);
      TreeGraphNode[] childArr={word};
      pos.setChildren(childArr);
      word.setParent(pos);
      pos.percolateHeads(headFinder);
    }
    TreeGraphNode root=new TreeGraphNode(new StringLabel("ROOT"));
    root.setChildren(tgPOSNodes.toArray(new TreeGraphNode[tgPOSNodes.size()]));
    root.setIndex(0);
    List<TypedDependency> tdeps=new ArrayList<TypedDependency>(deps.size());
    for (    String depString : deps) {
      int firstBracket=depString.indexOf('(');
      if (firstBracket == -1)       throwDepFormatException(depString);
      String type=depString.substring(0,firstBracket);
      if (depString.charAt(depString.length() - 1) != ')')       throwDepFormatException(depString);
      String args=depString.substring(firstBracket + 1,depString.length() - 1);
      int argSep=args.indexOf(", ");
      if (argSep == -1)       throwDepFormatException(depString);
      String parentArg=args.substring(0,argSep);
      String childArg=args.substring(argSep + 2);
      int parentDash=parentArg.lastIndexOf('-');
      if (parentDash == -1)       throwDepFormatException(depString);
      int childDash=childArg.lastIndexOf('-');
      if (childDash == -1)       throwDepFormatException(depString);
      int parentIdx=Integer.parseInt(parentArg.substring(parentDash + 1).replace("'",""));
      int childIdx=Integer.parseInt(childArg.substring(childDash + 1).replace("'",""));
      GrammaticalRelation grel=new GrammaticalRelation(GrammaticalRelation.Language.Any,type,null,null,DEPENDENT);
      TypedDependency tdep=new TypedDependency(grel,(parentIdx == 0 ? root : tgWordNodes.get(parentIdx - 1)),tgWordNodes.get(childIdx - 1));
      tdeps.add(tdep);
    }
    return new GrammaticalStructure(tdeps,root){
      private static final long serialVersionUID=1L;
    }
;
  }
  public GrammaticalStructure(  List<TypedDependency> projectiveDependencies,  TreeGraphNode root){
    super(root);
    this.puncFilter=Filters.acceptFilter();
    allTypedDependencies=typedDependencies=new ArrayList<TypedDependency>(projectiveDependencies);
    dependencies=Generics.newHashSet();
    for (    TypedDependency tdep : projectiveDependencies) {
      dependencies.add(new NamedDependency(tdep.gov().toString(),tdep.dep().toString(),tdep.reln()));
    }
  }
  public GrammaticalStructure(  Tree t,  Collection<GrammaticalRelation> relations,  HeadFinder hf,  Filter<String> puncFilter){
    this(t,relations,null,hf,puncFilter);
  }
  private static void analyzeNode(  TreeGraphNode t,  TreeGraphNode root,  Collection<GrammaticalRelation> relations){
    if (t.isPhrasal()) {
      TreeGraphNode tHigh=t.highestNodeWithSameHead();
      for (      GrammaticalRelation egr : relations) {
        if (egr.isApplicable(t)) {
          for (          Tree u : egr.getRelatedNodes(t,root)) {
            tHigh.addArc(GrammaticalRelation.getAnnotationClass(egr),(TreeGraphNode)u);
          }
        }
      }
      for (      TreeGraphNode kid : t.children()) {
        analyzeNode(kid,root,relations);
      }
    }
  }
  private List<TypedDependency> getDeps(  boolean getExtra,  Filter<TypedDependency> puncTypedDepFilter){
    List<TypedDependency> basicDep=Generics.newArrayList();
    for (    Dependency<Label,Label,Object> d : dependencies()) {
      TreeGraphNode gov=(TreeGraphNode)d.governor();
      TreeGraphNode dep=(TreeGraphNode)d.dependent();
      GrammaticalRelation reln=getGrammaticalRelation(gov,dep);
      basicDep.add(new TypedDependency(reln,gov,dep));
    }
    TreeGraphNode dependencyRoot=new TreeGraphNode(new Word("ROOT"));
    dependencyRoot.setIndex(0);
    TreeGraphNode rootDep=null;
    Collection<TypedDependency> roots=getRoots(basicDep);
    if (roots.size() == 0) {
      List<Tree> leaves=Trees.leaves(root());
      if (leaves.size() > 0) {
        Tree leaf=leaves.get(0);
        if (!(leaf instanceof TreeGraphNode)) {
          throw new AssertionError("Leaves should be TreeGraphNodes");
        }
        rootDep=(TreeGraphNode)leaf;
        if (rootDep.headWordNode() != null) {
          rootDep=rootDep.headWordNode();
        }
      }
    }
 else {
      Iterator<TypedDependency> iterator=roots.iterator();
      rootDep=iterator.next().gov();
    }
    if (rootDep != null) {
      TypedDependency rootTypedDep=new TypedDependency(ROOT,dependencyRoot,rootDep);
      if (puncTypedDepFilter.accept(rootTypedDep)) {
        basicDep.add(rootTypedDep);
      }
    }
    postProcessDependencies(basicDep);
    if (getExtra) {
      getExtras(basicDep);
      getTreeDeps(root(),basicDep,puncTypedDepFilter,extraTreeDepFilter());
    }
    Collections.sort(basicDep);
    return basicDep;
  }
  protected Filter<TypedDependency> extraTreeDepFilter(){
    return Filters.acceptFilter();
  }
  protected void postProcessDependencies(  List<TypedDependency> basicDep){
  }
  protected void getExtras(  List<TypedDependency> basicDep){
  }
  private static void getTreeDeps(  TreeGraphNode t,  List<TypedDependency> basicDep,  Filter<TypedDependency> puncTypedDepFilter,  Filter<TypedDependency> extraTreeDepFilter){
    if (t.isPhrasal()) {
      Map<Class<? extends GrammaticalRelationAnnotation>,Set<TreeGraphNode>> depMap=getAllDependents(t);
      for (      Class<? extends GrammaticalRelationAnnotation> depName : depMap.keySet()) {
        for (        TreeGraphNode depNode : depMap.get(depName)) {
          TreeGraphNode gov=t.headWordNode();
          TreeGraphNode dep=depNode.headWordNode();
          if (gov != dep) {
            List<GrammaticalRelation> rels=getListGrammaticalRelation(t,depNode);
            if (!rels.isEmpty()) {
              for (              GrammaticalRelation rel : rels) {
                TypedDependency newDep=new TypedDependency(rel,gov,dep);
                if (!basicDep.contains(newDep) && puncTypedDepFilter.accept(newDep) && extraTreeDepFilter.accept(newDep)) {
                  newDep.setExtra();
                  basicDep.add(newDep);
                }
              }
            }
          }
        }
      }
      for (      Tree kid : t.children()) {
        getTreeDeps((TreeGraphNode)kid,basicDep,puncTypedDepFilter,extraTreeDepFilter);
      }
    }
  }
private static class NoPunctFilter implements Filter<Dependency<Label,Label,Object>> {
    private Filter<String> npf;
    NoPunctFilter(    Filter<String> f){
      this.npf=f;
    }
    @Override public boolean accept(    Dependency<Label,Label,Object> d){
      if (d == null) {
        return false;
      }
      Label lab=d.dependent();
      if (lab == null) {
        return false;
      }
      return npf.accept(lab.value());
    }
    private static final long serialVersionUID=-2319891944796663180L;
  }
private static class NoPunctTypedDependencyFilter implements Filter<TypedDependency> {
    private Filter<String> npf;
    NoPunctTypedDependencyFilter(    Filter<String> f){
      this.npf=f;
    }
    @Override public boolean accept(    TypedDependency d){
      if (d == null)       return false;
      TreeGraphNode s=d.dep();
      if (s == null)       return false;
      Label l=s.label();
      if (l == null)       return false;
      return npf.accept(l.value());
    }
    private static final long serialVersionUID=-2872766864289207468L;
  }
  public Set<Dependency<Label,Label,Object>> dependencies(){
    return dependencies;
  }
  public static Set<TreeGraphNode> getDependents(  TreeGraphNode t){
    Set<TreeGraphNode> deps=Generics.newTreeSet();
    for (    Tree subtree : t) {
      TreeGraphNode node=(TreeGraphNode)subtree;
      TreeGraphNode gov=getGovernor(node);
      if (gov != null && gov == t) {
        deps.add(node);
      }
    }
    return deps;
  }
  public static TreeGraphNode getGovernor(  TreeGraphNode t){
    return getNodeInRelation(t,GOVERNOR);
  }
  public static TreeGraphNode getNodeInRelation(  TreeGraphNode t,  GrammaticalRelation r){
    return t.followArcToNode(GrammaticalRelation.getAnnotationClass(r));
  }
  public GrammaticalRelation getGrammaticalRelation(  int govIndex,  int depIndex){
    TreeGraphNode gov=getNodeByIndex(govIndex);
    TreeGraphNode dep=getNodeByIndex(depIndex);
    return getGrammaticalRelation(gov,dep);
  }
  public static GrammaticalRelation getGrammaticalRelation(  TreeGraphNode gov,  TreeGraphNode dep){
    GrammaticalRelation reln=GrammaticalRelation.DEPENDENT;
    TreeGraphNode govH=gov.highestNodeWithSameHead();
    TreeGraphNode depH=dep.highestNodeWithSameHead();
    Set<Class<? extends GrammaticalRelationAnnotation>> arcLabels=new TreeSet<Class<? extends GrammaticalRelationAnnotation>>(new NameComparator<Class<? extends GrammaticalRelationAnnotation>>());
    arcLabels.addAll(govH.arcLabelsToNode(depH));
    for (    Class<? extends GrammaticalRelationAnnotation> arcLabel : arcLabels) {
      if (arcLabel != null) {
        GrammaticalRelation reln2;
        try {
          reln2=GrammaticalRelation.getRelation(arcLabel);
        }
 catch (        Exception e) {
          continue;
        }
        if (reln.isAncestor(reln2)) {
          reln=reln2;
        }
 else         if (PRINT_DEBUGGING && !reln2.isAncestor(reln)) {
          System.err.println("@@@\t" + reln + "\t"+ reln2+ "\t"+ govH.label().get(CoreAnnotations.ValueAnnotation.class)+ "\t"+ depH.label().get(CoreAnnotations.ValueAnnotation.class));
        }
      }
    }
    if (PRINT_DEBUGGING && reln.equals(GrammaticalRelation.DEPENDENT)) {
      String topCat=govH.label().get(CoreAnnotations.ValueAnnotation.class);
      String topTag=govH.label().get(TreeCoreAnnotations.HeadTagAnnotation.class).value();
      String topWord=govH.label().get(TreeCoreAnnotations.HeadWordAnnotation.class).value();
      String botCat=depH.label().get(CoreAnnotations.ValueAnnotation.class);
      String botTag=depH.label().get(TreeCoreAnnotations.HeadTagAnnotation.class).value();
      String botWord=depH.label().get(TreeCoreAnnotations.HeadWordAnnotation.class).value();
      System.err.println("### dep\t" + topCat + "\t"+ topTag+ "\t"+ topWord+ "\t"+ botCat+ "\t"+ botTag+ "\t"+ botWord+ "\t");
    }
    return reln;
  }
  public static List<GrammaticalRelation> getListGrammaticalRelation(  TreeGraphNode gov,  TreeGraphNode dep){
    List<GrammaticalRelation> list=new ArrayList<GrammaticalRelation>();
    TreeGraphNode govH=gov.highestNodeWithSameHead();
    TreeGraphNode depH=dep.highestNodeWithSameHead();
    Set<Class<? extends GrammaticalRelationAnnotation>> arcLabels=govH.arcLabelsToNode(depH);
    if (dep != depH) {
      Set<Class<? extends GrammaticalRelationAnnotation>> arcLabels2=govH.arcLabelsToNode(dep);
      arcLabels.addAll(arcLabels2);
    }
    for (    Class<? extends GrammaticalRelationAnnotation> arcLabel : arcLabels) {
      if (arcLabel != null) {
        GrammaticalRelation reln=GrammaticalRelation.getRelation(arcLabel);
        boolean descendantFound=false;
        for (int index=0; index < list.size(); ++index) {
          GrammaticalRelation gr=list.get(index);
          if (gr.isAncestor(reln)) {
            list.remove(index);
            --index;
          }
 else           if (reln.isAncestor(gr)) {
            descendantFound=true;
          }
        }
        if (!descendantFound) {
          list.add(reln);
        }
      }
    }
    return list;
  }
  public Collection<TypedDependency> typedDependencies(){
    return typedDependencies(false);
  }
  public Collection<TypedDependency> allTypedDependencies(){
    return typedDependencies(true);
  }
  public List<TypedDependency> typedDependencies(  boolean includeExtras){
    List<TypedDependency> deps=new ArrayList<TypedDependency>(includeExtras ? allTypedDependencies : typedDependencies);
    correctDependencies(deps);
    return deps;
  }
  public Collection<TypedDependency> typedDependenciesCollapsed(){
    return typedDependenciesCollapsed(false);
  }
  public Collection<TypedDependency> typedDependenciesCollapsedTree(){
    List<TypedDependency> tdl=typedDependencies(false);
    collapseDependenciesTree(tdl);
    return tdl;
  }
  public List<TypedDependency> typedDependenciesCollapsed(  boolean includeExtras){
    List<TypedDependency> tdl=typedDependencies(false);
    if (includeExtras) {
      getTreeDeps(root(),tdl,new NoPunctTypedDependencyFilter(puncFilter),extraTreeDepFilter());
    }
    collapseDependencies(tdl,false,includeExtras);
    return tdl;
  }
  public List<TypedDependency> typedDependenciesCCprocessed(  boolean includeExtras){
    List<TypedDependency> tdl=typedDependencies(false);
    if (includeExtras) {
      getTreeDeps(root(),tdl,new NoPunctTypedDependencyFilter(puncFilter),extraTreeDepFilter());
    }
    collapseDependencies(tdl,true,includeExtras);
    return tdl;
  }
  public List<TypedDependency> typedDependenciesCCprocessed(){
    return typedDependenciesCCprocessed(true);
  }
  protected void collapseDependencies(  List<TypedDependency> list,  boolean CCprocess,  boolean includeExtras){
  }
  protected void collapseDependenciesTree(  List<TypedDependency> list){
  }
  protected void correctDependencies(  Collection<TypedDependency> list){
  }
  public List<String> getDependencyPath(  int nodeIndex,  int rootIndex){
    TreeGraphNode node=getNodeByIndex(nodeIndex);
    TreeGraphNode rootTree=getNodeByIndex(rootIndex);
    return getDependencyPath(node,rootTree);
  }
  private static List<String> getDependencyPath(  TreeGraphNode node,  TreeGraphNode root){
    List<String> path=new ArrayList<String>();
    while (!node.equals(root)) {
      TreeGraphNode gov=getGovernor(node);
      List<GrammaticalRelation> relations=getListGrammaticalRelation(gov,node);
      StringBuilder sb=new StringBuilder();
      for (      GrammaticalRelation relation : relations) {
        sb.append((sb.length() == 0 ? "" : "+")).append(relation.toString());
      }
      path.add(sb.toString());
      node=gov;
    }
    return path;
  }
  private static <GR extends GrammaticalRelationAnnotation>Map<Class<? extends GrammaticalRelationAnnotation>,Set<TreeGraphNode>> getAllDependents(  TreeGraphNode node){
    Map<Class<? extends GrammaticalRelationAnnotation>,Set<TreeGraphNode>> newMap=Generics.newHashMap();
    for (    Class<?> o : node.label.keySet()) {
      if (GrammaticalRelationAnnotation.class.isAssignableFrom(o)) {
        Class<GR> typedKey=ErasureUtils.uncheckedCast(o);
        newMap.put(typedKey,node.label.get(typedKey));
      }
    }
    return newMap;
  }
  public static boolean isConnected(  Collection<TypedDependency> list){
    return getRoots(list).size() <= 1;
  }
  public static Collection<TypedDependency> getRoots(  Collection<TypedDependency> list){
    Collection<TypedDependency> roots=new ArrayList<TypedDependency>();
    Collection<TreeGraphNode> deps=Generics.newHashSet();
    for (    TypedDependency typedDep : list) {
      deps.add(typedDep.dep());
    }
    Collection<TreeGraphNode> govs=Generics.newHashSet();
    for (    TypedDependency typedDep : list) {
      TreeGraphNode gov=typedDep.gov();
      if (!deps.contains(gov) && !govs.contains(gov)) {
        roots.add(typedDep);
      }
      govs.add(gov);
    }
    return roots;
  }
  private static final long serialVersionUID=2286294455343892678L;
private static class NameComparator<X> implements Comparator<X> {
    @Override public int compare(    X o1,    X o2){
      String n1=o1.toString();
      String n2=o2.toString();
      return n1.compareTo(n2);
    }
  }
  public static final String DEFAULT_PARSER_FILE="/u/nlp/data/lexparser/englishPCFG.ser.gz";
  public static void printDependencies(  GrammaticalStructure gs,  Collection<TypedDependency> deps,  Tree tree,  boolean conllx,  boolean extraSep){
    System.out.println(dependenciesToString(gs,deps,tree,conllx,extraSep));
  }
  public static String dependenciesToString(  GrammaticalStructure gs,  Collection<TypedDependency> deps,  Tree tree,  boolean conllx,  boolean extraSep){
    StringBuilder bf=new StringBuilder();
    Map<Integer,Integer> indexToPos=Generics.newHashMap();
    indexToPos.put(0,0);
    List<Tree> gsLeaves=gs.root.getLeaves();
    for (int i=0; i < gsLeaves.size(); i++) {
      TreeGraphNode leaf=(TreeGraphNode)gsLeaves.get(i);
      indexToPos.put(leaf.label.index(),i + 1);
    }
    if (conllx) {
      List<Tree> leaves=tree.getLeaves();
      List<String> words=new ArrayList<String>(leaves.size());
      List<String> pos=new ArrayList<String>(leaves.size());
      String[] relns=new String[leaves.size()];
      int[] govs=new int[leaves.size()];
      for (      Tree leaf : leaves) {
        words.add(leaf.value());
        pos.add(leaf.parent(tree).value());
      }
      for (      TypedDependency dep : deps) {
        int depPos=indexToPos.get(dep.dep().index()) - 1;
        govs[depPos]=indexToPos.get(dep.gov().index());
        relns[depPos]=dep.reln().toString();
      }
      for (int i=0; i < relns.length; i++) {
        String out=String.format("%d\t%s\t_\t%s\t%s\t_\t%d\t%s\t_\t_\n",i + 1,words.get(i),pos.get(i),pos.get(i),govs[i],(relns[i] != null ? relns[i] : "erased"));
        bf.append(out);
      }
    }
 else {
      if (extraSep) {
        List<TypedDependency> extraDeps=new ArrayList<TypedDependency>();
        for (        TypedDependency dep : deps) {
          if (dep.extra()) {
            extraDeps.add(dep);
          }
 else {
            bf.append(toStringIndex(dep,indexToPos));
            bf.append("\n");
          }
        }
        if (!extraDeps.isEmpty()) {
          bf.append("======\n");
          for (          TypedDependency dep : extraDeps) {
            bf.append(toStringIndex(dep,indexToPos));
            bf.append("\n");
          }
        }
      }
 else {
        for (        TypedDependency dep : deps) {
          bf.append(toStringIndex(dep,indexToPos));
          bf.append("\n");
        }
      }
    }
    return bf.toString();
  }
  private static String toStringIndex(  TypedDependency td,  Map<Integer,Integer> indexToPos){
    TreeGraphNode gov=td.gov();
    TreeGraphNode dep=td.dep();
    return td.reln() + "(" + gov.value()+ "-"+ indexToPos.get(gov.index())+ gov.toPrimes()+ ", "+ dep.value()+ "-"+ indexToPos.get(dep.index())+ dep.toPrimes()+ ")";
  }
  public static final int CoNLLX_WordField=1;
  public static final int CoNLLX_POSField=3;
  public static final int CoNLLX_GovField=6;
  public static final int CoNLLX_RelnField=7;
  public static final int CoNLLX_FieldCount=10;
  public static List<GrammaticalStructure> readCoNLLXGrammaticalStructureCollection(  String fileName,  Map<String,GrammaticalRelation> shortNameToGRel,  GrammaticalStructureFromDependenciesFactory factory) throws IOException {
    LineNumberReader reader=new LineNumberReader(new FileReader(fileName));
    List<GrammaticalStructure> gsList=new LinkedList<GrammaticalStructure>();
    List<List<String>> tokenFields=new ArrayList<List<String>>();
    for (String inline=reader.readLine(); inline != null; inline=reader.readLine()) {
      if (!"".equals(inline)) {
        List<String> fields=Arrays.asList(inline.split("\t"));
        if (fields.size() != CoNLLX_FieldCount) {
          throw new RuntimeException(String.format("Error (line %d): 10 fields expected but %d are present",reader.getLineNumber(),fields.size()));
        }
        tokenFields.add(fields);
      }
 else {
        if (tokenFields.isEmpty())         continue;
        gsList.add(buildCoNLLXGrammaticalStructure(tokenFields,shortNameToGRel,factory));
        tokenFields=new ArrayList<List<String>>();
      }
    }
    return gsList;
  }
  public static GrammaticalStructure buildCoNLLXGrammaticalStructure(  List<List<String>> tokenFields,  Map<String,GrammaticalRelation> shortNameToGRel,  GrammaticalStructureFromDependenciesFactory factory){
    List<TreeGraphNode> tgWordNodes=new ArrayList<TreeGraphNode>(tokenFields.size());
    List<TreeGraphNode> tgPOSNodes=new ArrayList<TreeGraphNode>(tokenFields.size());
    SemanticHeadFinder headFinder=new SemanticHeadFinder();
    for (    List<String> fields : tokenFields) {
      TreeGraphNode word=new TreeGraphNode(new Word(fields.get(CoNLLX_WordField)));
      TreeGraphNode pos=new TreeGraphNode(new Word(fields.get(CoNLLX_POSField)));
      tgWordNodes.add(word);
      tgPOSNodes.add(pos);
      TreeGraphNode[] childArr={word};
      pos.setChildren(childArr);
      word.setParent(pos);
      pos.percolateHeads(headFinder);
    }
    TreeGraphNode root=new TreeGraphNode(new Word("ROOT-" + (tgWordNodes.size() + 1)));
    root.setChildren(tgPOSNodes.toArray(new TreeGraphNode[tgPOSNodes.size()]));
    List<TypedDependency> tdeps=new ArrayList<TypedDependency>(tgWordNodes.size());
    TreeGraphNode dependencyRoot=new TreeGraphNode(new Word("ROOT"));
    dependencyRoot.setIndex(0);
    for (int i=0; i < tgWordNodes.size(); i++) {
      String parentIdStr=tokenFields.get(i).get(CoNLLX_GovField);
      if (parentIdStr == null || parentIdStr.equals(""))       continue;
      int parentId=Integer.parseInt(parentIdStr) - 1;
      String grelString=tokenFields.get(i).get(CoNLLX_RelnField);
      if (grelString.equals("null") || grelString.equals("erased"))       continue;
      GrammaticalRelation grel=shortNameToGRel.get(grelString.toLowerCase());
      TypedDependency tdep;
      if (grel == null) {
        if (grelString.toLowerCase().equals("root")) {
          tdep=new TypedDependency(ROOT,dependencyRoot,tgWordNodes.get(i));
        }
 else {
          throw new RuntimeException("Unknown grammatical relation '" + grelString + "' fields: "+ tokenFields.get(i)+ "\nNode: "+ tgWordNodes.get(i)+ "\n"+ "Known Grammatical relations: ["+ shortNameToGRel.keySet()+ "]");
        }
      }
 else {
        if (parentId >= tgWordNodes.size()) {
          System.err.printf("Warning: Invalid Parent Id %d Sentence Length: %d%n",parentId + 1,tgWordNodes.size());
          System.err.printf("         Assigning to root (0)%n");
          parentId=-1;
        }
        tdep=new TypedDependency(grel,(parentId == -1 ? root : tgWordNodes.get(parentId)),tgWordNodes.get(i));
      }
      tdeps.add(tdep);
    }
    return factory.build(tdeps,root);
  }
  private static String[] parseClassConstructArgs(  String namePlusArgs){
    String[] args=StringUtils.EMPTY_STRING_ARRAY;
    String name=namePlusArgs;
    if (namePlusArgs.matches(".*\\([^)]*\\)$")) {
      String argStr=namePlusArgs.replaceFirst("^.*\\(([^)]*)\\)$","$1");
      args=argStr.split(",");
      name=namePlusArgs.replaceFirst("\\([^)]*\\)$","");
    }
    String[] tokens=new String[1 + args.length];
    tokens[0]=name;
    System.arraycopy(args,0,tokens,1,args.length);
    return tokens;
  }
  private static DependencyReader loadAlternateDependencyReader(  String altDepReaderName){
    Class<? extends DependencyReader> altDepReaderClass=null;
    String[] toks=parseClassConstructArgs(altDepReaderName);
    altDepReaderName=toks[0];
    String[] depReaderArgs=new String[toks.length - 1];
    System.arraycopy(toks,1,depReaderArgs,0,toks.length - 1);
    try {
      Class<?> cl=Class.forName(altDepReaderName);
      altDepReaderClass=cl.asSubclass(DependencyReader.class);
    }
 catch (    ClassNotFoundException e) {
    }
    if (altDepReaderClass == null) {
      try {
        Class<?> cl=Class.forName("edu.stanford.nlp.trees." + altDepReaderName);
        altDepReaderClass=cl.asSubclass(DependencyReader.class);
      }
 catch (      ClassNotFoundException e) {
      }
    }
    if (altDepReaderClass == null) {
      System.err.println("Can't load dependency reader " + altDepReaderName + " or edu.stanford.nlp.trees."+ altDepReaderName);
      return null;
    }
    DependencyReader altDepReader;
    if (depReaderArgs.length == 0) {
      try {
        altDepReader=altDepReaderClass.newInstance();
      }
 catch (      InstantiationException e) {
        throw new RuntimeException(e);
      }
catch (      IllegalAccessException e) {
        System.err.println("No argument constructor to " + altDepReaderName + " is not public");
        return null;
      }
    }
 else {
      try {
        altDepReader=altDepReaderClass.getConstructor(String[].class).newInstance((Object)depReaderArgs);
      }
 catch (      IllegalArgumentException e) {
        throw new RuntimeException(e);
      }
catch (      SecurityException e) {
        throw new RuntimeException(e);
      }
catch (      InstantiationException e) {
        e.printStackTrace();
        return null;
      }
catch (      IllegalAccessException e) {
        System.err.println(depReaderArgs.length + " argument constructor to " + altDepReaderName+ " is not public.");
        return null;
      }
catch (      InvocationTargetException e) {
        throw new RuntimeException(e);
      }
catch (      NoSuchMethodException e) {
        System.err.println("String arguments constructor to " + altDepReaderName + " does not exist.");
        return null;
      }
    }
    return altDepReader;
  }
  private static DependencyPrinter loadAlternateDependencyPrinter(  String altDepPrinterName){
    Class<? extends DependencyPrinter> altDepPrinterClass=null;
    String[] toks=parseClassConstructArgs(altDepPrinterName);
    altDepPrinterName=toks[0];
    String[] depPrintArgs=new String[toks.length - 1];
    System.arraycopy(toks,1,depPrintArgs,0,toks.length - 1);
    try {
      Class<?> cl=Class.forName(altDepPrinterName);
      altDepPrinterClass=cl.asSubclass(DependencyPrinter.class);
    }
 catch (    ClassNotFoundException e) {
    }
    if (altDepPrinterClass == null) {
      try {
        Class<?> cl=Class.forName("edu.stanford.nlp.trees." + altDepPrinterName);
        altDepPrinterClass=cl.asSubclass(DependencyPrinter.class);
      }
 catch (      ClassNotFoundException e) {
      }
    }
    if (altDepPrinterClass == null) {
      System.err.printf("Unable to load alternative printer %s or %s. Is your classpath set correctly?\n",altDepPrinterName,"edu.stanford.nlp.trees." + altDepPrinterName);
      return null;
    }
    try {
      DependencyPrinter depPrinter;
      if (depPrintArgs.length == 0) {
        depPrinter=altDepPrinterClass.newInstance();
      }
 else {
        depPrinter=altDepPrinterClass.getConstructor(String[].class).newInstance((Object)depPrintArgs);
      }
      return depPrinter;
    }
 catch (    IllegalArgumentException e) {
      e.printStackTrace();
      return null;
    }
catch (    SecurityException e) {
      e.printStackTrace();
      return null;
    }
catch (    InstantiationException e) {
      e.printStackTrace();
      return null;
    }
catch (    IllegalAccessException e) {
      e.printStackTrace();
      return null;
    }
catch (    InvocationTargetException e) {
      e.printStackTrace();
      return null;
    }
catch (    NoSuchMethodException e) {
      if (depPrintArgs == null) {
        System.err.printf("Can't find no-argument constructor %s().\n",altDepPrinterName);
      }
 else {
        System.err.printf("Can't find constructor %s(%s).\n",altDepPrinterName,Arrays.toString(depPrintArgs));
      }
      return null;
    }
  }
  private static Function<List<? extends HasWord>,Tree> loadParser(  String parserFile,  String parserOptions,  boolean makeCopulaHead){
    if (parserFile == null || "".equals(parserFile)) {
      parserFile=DEFAULT_PARSER_FILE;
      if (parserOptions == null) {
        parserOptions="-retainTmpSubcategories";
      }
    }
    if (parserOptions == null) {
      parserOptions="";
    }
    if (makeCopulaHead) {
      parserOptions="-makeCopulaHead " + parserOptions;
    }
    parserOptions=parserOptions.trim();
    Function<List<? extends HasWord>,Tree> lp;
    try {
      Class<?>[] classes=new Class<?>[]{String.class,String[].class};
      Method method=Class.forName("edu.stanford.nlp.parser.lexparser.LexicalizedParser").getMethod("loadModel",classes);
      String[] opts={};
      if (parserOptions.length() > 0) {
        opts=parserOptions.split(" +");
      }
      lp=(Function<List<? extends HasWord>,Tree>)method.invoke(null,parserFile,opts);
    }
 catch (    Exception cnfe) {
      throw new RuntimeException(cnfe);
    }
    return lp;
  }
private static class TreeBankGrammaticalStructureWrapper implements Iterable<GrammaticalStructure> {
    private final Iterable<Tree> trees;
    private final boolean keepPunct;
    private final TreebankLangParserParams params;
    private final Map<GrammaticalStructure,Tree> origTrees=new WeakHashMap<GrammaticalStructure,Tree>();
    public TreeBankGrammaticalStructureWrapper(    Iterable<Tree> wrappedTrees,    boolean keepPunct,    TreebankLangParserParams params){
      trees=wrappedTrees;
      this.keepPunct=keepPunct;
      this.params=params;
    }
    @Override public Iterator<GrammaticalStructure> iterator(){
      return new GsIterator();
    }
    public Tree getOriginalTree(    GrammaticalStructure gs){
      return origTrees.get(gs);
    }
private class GsIterator implements Iterator<GrammaticalStructure> {
      private final Iterator<Tree> tbIterator=trees.iterator();
      private final Filter<String> puncFilter;
      private final HeadFinder hf;
      private GrammaticalStructure next;
      public GsIterator(){
        if (keepPunct) {
          puncFilter=Filters.acceptFilter();
        }
 else {
          puncFilter=new PennTreebankLanguagePack().punctuationWordRejectFilter();
        }
        hf=params.typedDependencyHeadFinder();
        primeGs();
      }
      private void primeGs(){
        GrammaticalStructure gs=null;
        while (gs == null && tbIterator.hasNext()) {
          Tree t=tbIterator.next();
          if (t == null) {
            continue;
          }
          try {
            gs=params.getGrammaticalStructure(t,puncFilter,hf);
            origTrees.put(gs,t);
            next=gs;
            return;
          }
 catch (          NullPointerException npe) {
            System.err.println("Bung (empty?) tree caused below dump. Continuing....");
            npe.printStackTrace();
          }
        }
        next=null;
      }
      @Override public boolean hasNext(){
        return next != null;
      }
      @Override public GrammaticalStructure next(){
        GrammaticalStructure ret=next;
        if (ret == null) {
          throw new NoSuchElementException();
        }
        primeGs();
        return ret;
      }
      @Override public void remove(){
        throw new UnsupportedOperationException();
      }
    }
  }
  @SuppressWarnings("unchecked") public static void main(  String[] args){
    MemoryTreebank tb=new MemoryTreebank(new TreeNormalizer());
    Iterable<Tree> trees=tb;
    Iterable<GrammaticalStructure> gsBank=null;
    Properties props=StringUtils.argsToProperties(args);
    String encoding=props.getProperty("encoding","utf-8");
    try {
      System.setOut(new PrintStream(System.out,true,encoding));
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    String treeFileName=props.getProperty("treeFile");
    String sentFileName=props.getProperty("sentFile");
    String conllXFileName=props.getProperty("conllxFile");
    String altDepPrinterName=props.getProperty("altprinter");
    String altDepReaderName=props.getProperty("altreader");
    String altDepReaderFilename=props.getProperty("altreaderfile");
    String filter=props.getProperty("filter");
    boolean makeCopulaHead=props.getProperty("makeCopulaHead") != null;
    String tLPP=props.getProperty("tLPP","edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams");
    TreebankLangParserParams params=ReflectionLoading.loadByReflection(tLPP);
    if (makeCopulaHead) {
      String[] options={"-makeCopulaHead"};
      params.setOptionFlag(options,0);
    }
    if (sentFileName == null && (altDepReaderName == null || altDepReaderFilename == null) && treeFileName == null && conllXFileName == null && filter == null) {
      try {
        System.err.println("Usage: java GrammaticalStructure [options]* [-sentFile|-treeFile|-conllxFile file] [-testGraph]");
        System.err.println("  options: -basic, -collapsed, -CCprocessed [the default], -collapsedTree, -parseTree, -test, -parserFile file, -conllx, -keepPunct, -altprinter -altreader -altreaderfile");
        TreeReader tr=new PennTreeReader(new StringReader("((S (NP (NNP Sam)) (VP (VBD died) (NP-TMP (NN today)))))"));
        tb.add(tr.readTree());
      }
 catch (      Exception e) {
        System.err.println("Horrible error: " + e);
        e.printStackTrace();
      }
    }
 else     if (altDepReaderName != null && altDepReaderFilename != null) {
      DependencyReader altDepReader=loadAlternateDependencyReader(altDepReaderName);
      try {
        gsBank=altDepReader.readDependencies(altDepReaderFilename);
      }
 catch (      IOException e) {
        System.err.println("Error reading " + altDepReaderFilename);
        return;
      }
    }
 else     if (treeFileName != null) {
      tb.loadPath(treeFileName);
    }
 else     if (filter != null) {
      tb.load(new BufferedReader(new InputStreamReader(System.in)));
    }
 else     if (conllXFileName != null) {
      try {
        gsBank=params.readGrammaticalStructureFromFile(conllXFileName);
      }
 catch (      RuntimeIOException e) {
        System.err.println("Error reading " + conllXFileName);
        return;
      }
    }
 else {
      String parserFile=props.getProperty("parserFile");
      String parserOpts=props.getProperty("parserOpts");
      boolean tokenized=props.getProperty("tokenized") != null;
      Function<List<? extends HasWord>,Tree> lp=loadParser(parserFile,parserOpts,makeCopulaHead);
      trees=new LazyLoadTreesByParsing(sentFileName,encoding,tokenized,lp);
      try {
        Method method=lp.getClass().getMethod("getTLPParams");
        params=(TreebankLangParserParams)method.invoke(lp);
      }
 catch (      Exception cnfe) {
        throw new RuntimeException(cnfe);
      }
    }
    boolean basic=props.getProperty("basic") != null;
    boolean collapsed=props.getProperty("collapsed") != null;
    boolean CCprocessed=props.getProperty("CCprocessed") != null;
    boolean collapsedTree=props.getProperty("collapsedTree") != null;
    boolean nonCollapsed=props.getProperty("nonCollapsed") != null;
    boolean extraSep=props.getProperty("extraSep") != null;
    boolean parseTree=props.getProperty("parseTree") != null;
    boolean test=props.getProperty("test") != null;
    boolean keepPunct=props.getProperty("keepPunct") != null;
    boolean conllx=props.getProperty("conllx") != null;
    boolean checkConnected=props.getProperty("checkConnected") != null;
    boolean portray=props.getProperty("portray") != null;
    if (conllx) {
      keepPunct=true;
    }
    DependencyPrinter altDepPrinter=null;
    if (altDepPrinterName != null) {
      altDepPrinter=loadAlternateDependencyPrinter(altDepPrinterName);
    }
    Method m=null;
    if (test) {
      try {
        Class sgf=Class.forName("edu.stanford.nlp.semgraph.SemanticGraphFactory");
        m=sgf.getDeclaredMethod("makeFromTree",GrammaticalStructure.class,boolean.class,boolean.class,boolean.class,boolean.class,boolean.class,boolean.class,Filter.class,String.class,int.class);
      }
 catch (      Exception e) {
        System.err.println("Test cannot check for cycles in tree format (classes not available)");
      }
    }
    if (gsBank == null) {
      gsBank=new TreeBankGrammaticalStructureWrapper(trees,keepPunct,params);
    }
    for (    GrammaticalStructure gs : gsBank) {
      Tree tree;
      if (gsBank instanceof TreeBankGrammaticalStructureWrapper) {
        tree=((TreeBankGrammaticalStructureWrapper)gsBank).getOriginalTree(gs);
      }
 else {
        tree=gs.root();
      }
      if (test) {
        System.out.println("============= parse tree =======================");
        tree.pennPrint();
        System.out.println();
        System.out.println("------------- GrammaticalStructure -------------");
        System.out.println(gs);
        System.out.println("------------- basic dependencies ---------------");
        System.out.println(StringUtils.join(gs.typedDependencies(false),"\n"));
        System.out.println("------------- non-collapsed dependencies (basic + extra) ---------------");
        System.out.println(StringUtils.join(gs.typedDependencies(true),"\n"));
        System.out.println("------------- collapsed dependencies -----------");
        System.out.println(StringUtils.join(gs.typedDependenciesCollapsed(true),"\n"));
        System.out.println("------------- collapsed dependencies tree -----------");
        System.out.println(StringUtils.join(gs.typedDependenciesCollapsedTree(),"\n"));
        System.out.println("------------- CCprocessed dependencies --------");
        System.out.println(StringUtils.join(gs.typedDependenciesCCprocessed(true),"\n"));
        System.out.println("-----------------------------------------------");
        boolean connected=GrammaticalStructure.isConnected(gs.typedDependenciesCollapsed(true));
        System.out.println("collapsed dependencies form a connected graph: " + connected);
        if (!connected) {
          System.out.println("possible offending nodes: " + GrammaticalStructure.getRoots(gs.typedDependenciesCollapsed(true)));
        }
        if (m != null) {
          try {
            Object semGraph=m.invoke(null,gs,false,true,false,false,false,false,null,null,0);
            Class sg=Class.forName("edu.stanford.nlp.semgraph.SemanticGraph");
            Method mDag=sg.getDeclaredMethod("isDag");
            boolean isDag=(Boolean)mDag.invoke(semGraph);
            System.out.println("tree dependencies form a DAG: " + isDag);
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
 else {
        if (parseTree) {
          System.out.println("============= parse tree =======================");
          tree.pennPrint();
          System.out.println();
        }
        if (basic) {
          if (collapsed || CCprocessed || collapsedTree|| nonCollapsed) {
            System.out.println("------------- basic dependencies ---------------");
          }
          if (altDepPrinter == null) {
            printDependencies(gs,gs.typedDependencies(false),tree,conllx,false);
          }
 else {
            System.out.println(altDepPrinter.dependenciesToString(gs,gs.typedDependencies(false),tree));
          }
        }
        if (nonCollapsed) {
          if (basic || CCprocessed || collapsed|| collapsedTree) {
            System.out.println("----------- non-collapsed dependencies (basic + extra) -----------");
          }
          printDependencies(gs,gs.allTypedDependencies(),tree,conllx,extraSep);
        }
        if (collapsed) {
          if (basic || CCprocessed || collapsedTree|| nonCollapsed) {
            System.out.println("----------- collapsed dependencies -----------");
          }
          printDependencies(gs,gs.typedDependenciesCollapsed(true),tree,conllx,false);
        }
        if (CCprocessed) {
          if (basic || collapsed || collapsedTree|| nonCollapsed) {
            System.out.println("---------- CCprocessed dependencies ----------");
          }
          List<TypedDependency> deps=gs.typedDependenciesCCprocessed(true);
          if (checkConnected) {
            if (!GrammaticalStructure.isConnected(deps)) {
              System.err.println("Graph is not connected for:");
              System.err.println(tree);
              System.err.println("possible offending nodes: " + GrammaticalStructure.getRoots(deps));
            }
          }
          printDependencies(gs,deps,tree,conllx,false);
        }
        if (collapsedTree) {
          if (basic || CCprocessed || collapsed|| nonCollapsed) {
            System.out.println("----------- collapsed dependencies tree -----------");
          }
          printDependencies(gs,gs.typedDependenciesCollapsedTree(),tree,conllx,false);
        }
        if (!basic && !collapsed && !CCprocessed&& !collapsedTree&& !nonCollapsed) {
          printDependencies(gs,gs.typedDependenciesCCprocessed(true),tree,conllx,false);
        }
      }
      if (portray) {
        try {
          Class sgu=Class.forName("edu.stanford.nlp.semgraph.SemanticGraphUtils");
          Method mRender=sgu.getDeclaredMethod("render",GrammaticalStructure.class,String.class);
          mRender.invoke(null,gs,"Collapsed, CC processed deps");
        }
 catch (        Exception e) {
          throw new RuntimeException("Couldn't use swing to portray semantic graph",e);
        }
      }
    }
  }
static class LazyLoadTreesByParsing implements Iterable<Tree> {
    final Reader reader;
    final String filename;
    final boolean tokenized;
    final String encoding;
    final Function<List<? extends HasWord>,Tree> lp;
    public LazyLoadTreesByParsing(    String filename,    String encoding,    boolean tokenized,    Function<List<? extends HasWord>,Tree> lp){
      this.filename=filename;
      this.encoding=encoding;
      this.reader=null;
      this.tokenized=tokenized;
      this.lp=lp;
    }
    public LazyLoadTreesByParsing(    Reader reader,    boolean tokenized,    Function<List<? extends HasWord>,Tree> lp){
      this.filename=null;
      this.encoding=null;
      this.reader=reader;
      this.tokenized=tokenized;
      this.lp=lp;
    }
    @Override public Iterator<Tree> iterator(){
      final BufferedReader iReader;
      if (reader != null) {
        iReader=new BufferedReader(reader);
      }
 else {
        try {
          iReader=new BufferedReader(new InputStreamReader(new FileInputStream(filename),encoding));
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return new Iterator<Tree>(){
        String line=null;
        @Override public boolean hasNext(){
          if (line != null) {
            return true;
          }
 else {
            try {
              line=iReader.readLine();
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
            if (line == null) {
              try {
                if (reader == null)                 iReader.close();
              }
 catch (              Exception e) {
                throw new RuntimeException(e);
              }
              return false;
            }
            return true;
          }
        }
        @Override public Tree next(){
          if (line == null) {
            throw new NoSuchElementException();
          }
          Reader lineReader=new StringReader(line);
          line=null;
          List<Word> words;
          if (tokenized) {
            words=WhitespaceTokenizer.newWordWhitespaceTokenizer(lineReader).tokenize();
          }
 else {
            words=PTBTokenizer.newPTBTokenizer(lineReader).tokenize();
          }
          if (!words.isEmpty()) {
            Tree parseTree=lp.apply(words);
            return parseTree;
          }
 else {
            return new SimpleTree();
          }
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
}
