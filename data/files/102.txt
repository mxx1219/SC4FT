package com.android.launcher3;
import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.TimeInterpolator;
import android.animation.ValueAnimator;
import android.animation.ValueAnimator.AnimatorUpdateListener;
import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.Rect;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.NinePatchDrawable;
import android.os.Parcelable;
import android.util.AttributeSet;
import android.util.Log;
import android.util.SparseArray;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewDebug;
import android.view.ViewGroup;
import android.view.animation.Animation;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.LayoutAnimationController;
import com.android.launcher3.R;
import com.android.launcher3.FolderIcon.FolderRingAnimator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Stack;
public class CellLayout extends ViewGroup {
  static final String TAG="CellLayout";
  private Launcher mLauncher;
  private int mCellWidth;
  private int mCellHeight;
  private int mFixedCellWidth;
  private int mFixedCellHeight;
  private int mCountX;
  private int mCountY;
  private int mOriginalWidthGap;
  private int mOriginalHeightGap;
  private int mWidthGap;
  private int mHeightGap;
  private int mMaxGap;
  private boolean mScrollingTransformsDirty=false;
  private boolean mDropPending=false;
  private final Rect mRect=new Rect();
  private final CellInfo mCellInfo=new CellInfo();
  private final int[] mTmpXY=new int[2];
  private final int[] mTmpPoint=new int[2];
  int[] mTempLocation=new int[2];
  boolean[][] mOccupied;
  boolean[][] mTmpOccupied;
  private boolean mLastDownOnOccupiedCell=false;
  private OnTouchListener mInterceptTouchListener;
  private ArrayList<FolderRingAnimator> mFolderOuterRings=new ArrayList<FolderRingAnimator>();
  private int[] mFolderLeaveBehindCell={-1,-1};
  private float FOREGROUND_ALPHA_DAMPER=0.65f;
  private int mForegroundAlpha=0;
  private float mBackgroundAlpha;
  private float mBackgroundAlphaMultiplier=1.0f;
  private Drawable mNormalBackground;
  private Drawable mActiveGlowBackground;
  private Drawable mOverScrollForegroundDrawable;
  private Drawable mOverScrollLeft;
  private Drawable mOverScrollRight;
  private Rect mBackgroundRect;
  private Rect mForegroundRect;
  private int mForegroundPadding;
  private int mFixedWidth=-1;
  private int mFixedHeight=-1;
  private boolean mIsDragOverlapping=false;
  boolean mUseActiveGlowBackground=false;
  private Rect[] mDragOutlines=new Rect[4];
  private float[] mDragOutlineAlphas=new float[mDragOutlines.length];
  private InterruptibleInOutAnimator[] mDragOutlineAnims=new InterruptibleInOutAnimator[mDragOutlines.length];
  private int mDragOutlineCurrent=0;
  private final Paint mDragOutlinePaint=new Paint();
  private BubbleTextView mPressedOrFocusedIcon;
  private HashMap<CellLayout.LayoutParams,Animator> mReorderAnimators=new HashMap<CellLayout.LayoutParams,Animator>();
  private HashMap<View,ReorderPreviewAnimation> mShakeAnimators=new HashMap<View,ReorderPreviewAnimation>();
  private boolean mItemPlacementDirty=false;
  private final int[] mDragCell=new int[2];
  private boolean mDragging=false;
  private TimeInterpolator mEaseOutInterpolator;
  private ShortcutAndWidgetContainer mShortcutsAndWidgets;
  private boolean mIsHotseat=false;
  private float mHotseatScale=1f;
  public static final int MODE_SHOW_REORDER_HINT=0;
  public static final int MODE_DRAG_OVER=1;
  public static final int MODE_ON_DROP=2;
  public static final int MODE_ON_DROP_EXTERNAL=3;
  public static final int MODE_ACCEPT_DROP=4;
  private static final boolean DESTRUCTIVE_REORDER=false;
  private static final boolean DEBUG_VISUALIZE_OCCUPIED=false;
  static final int LANDSCAPE=0;
  static final int PORTRAIT=1;
  private static final float REORDER_PREVIEW_MAGNITUDE=0.12f;
  private static final int REORDER_ANIMATION_DURATION=150;
  private float mReorderPreviewAnimationMagnitude;
  private ArrayList<View> mIntersectingViews=new ArrayList<View>();
  private Rect mOccupiedRect=new Rect();
  private int[] mDirectionVector=new int[2];
  int[] mPreviousReorderDirection=new int[2];
  private static final int INVALID_DIRECTION=-100;
  private DropTarget.DragEnforcer mDragEnforcer;
  private Rect mTempRect=new Rect();
  private final static PorterDuffXfermode sAddBlendMode=new PorterDuffXfermode(PorterDuff.Mode.ADD);
  private final static Paint sPaint=new Paint();
  public CellLayout(  Context context){
    this(context,null);
  }
  public CellLayout(  Context context,  AttributeSet attrs){
    this(context,attrs,0);
  }
  public CellLayout(  Context context,  AttributeSet attrs,  int defStyle){
    super(context,attrs,defStyle);
    mDragEnforcer=new DropTarget.DragEnforcer(context);
    setWillNotDraw(false);
    setClipToPadding(false);
    mLauncher=(Launcher)context;
    LauncherAppState app=LauncherAppState.getInstance();
    DeviceProfile grid=app.getDynamicGrid().getDeviceProfile();
    TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.CellLayout,defStyle,0);
    mCellWidth=mCellHeight=-1;
    mFixedCellHeight=mFixedCellHeight=-1;
    mWidthGap=mOriginalWidthGap=0;
    mHeightGap=mOriginalHeightGap=0;
    mMaxGap=Integer.MAX_VALUE;
    mCountX=(int)grid.numColumns;
    mCountY=(int)grid.numRows;
    mOccupied=new boolean[mCountX][mCountY];
    mTmpOccupied=new boolean[mCountX][mCountY];
    mPreviousReorderDirection[0]=INVALID_DIRECTION;
    mPreviousReorderDirection[1]=INVALID_DIRECTION;
    a.recycle();
    setAlwaysDrawnWithCacheEnabled(false);
    final Resources res=getResources();
    mHotseatScale=(float)grid.hotseatIconSizePx / grid.iconSizePx;
    mNormalBackground=res.getDrawable(R.drawable.screenpanel);
    mActiveGlowBackground=res.getDrawable(R.drawable.screenpanel_hover);
    mOverScrollLeft=res.getDrawable(R.drawable.overscroll_glow_left);
    mOverScrollRight=res.getDrawable(R.drawable.overscroll_glow_right);
    mForegroundPadding=res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
    mReorderPreviewAnimationMagnitude=(REORDER_PREVIEW_MAGNITUDE * grid.iconSizePx);
    mNormalBackground.setFilterBitmap(true);
    mActiveGlowBackground.setFilterBitmap(true);
    mEaseOutInterpolator=new DecelerateInterpolator(2.5f);
    mDragCell[0]=mDragCell[1]=-1;
    for (int i=0; i < mDragOutlines.length; i++) {
      mDragOutlines[i]=new Rect(-1,-1,-1,-1);
    }
    final int duration=res.getInteger(R.integer.config_dragOutlineFadeTime);
    final float fromAlphaValue=0;
    final float toAlphaValue=(float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
    Arrays.fill(mDragOutlineAlphas,fromAlphaValue);
    for (int i=0; i < mDragOutlineAnims.length; i++) {
      final InterruptibleInOutAnimator anim=new InterruptibleInOutAnimator(this,duration,fromAlphaValue,toAlphaValue);
      anim.getAnimator().setInterpolator(mEaseOutInterpolator);
      final int thisIndex=i;
      anim.getAnimator().addUpdateListener(new AnimatorUpdateListener(){
        public void onAnimationUpdate(        ValueAnimator animation){
          final Bitmap outline=(Bitmap)anim.getTag();
          if (outline == null) {
            @SuppressWarnings("all") final boolean debug=false;
            if (debug) {
              Object val=animation.getAnimatedValue();
              Log.d(TAG,"anim " + thisIndex + " update: "+ val+ ", isStopped "+ anim.isStopped());
            }
            animation.cancel();
          }
 else {
            mDragOutlineAlphas[thisIndex]=(Float)animation.getAnimatedValue();
            CellLayout.this.invalidate(mDragOutlines[thisIndex]);
          }
        }
      }
);
      anim.getAnimator().addListener(new AnimatorListenerAdapter(){
        @Override public void onAnimationEnd(        Animator animation){
          if ((Float)((ValueAnimator)animation).getAnimatedValue() == 0f) {
            anim.setTag(null);
          }
        }
      }
);
      mDragOutlineAnims[i]=anim;
    }
    mBackgroundRect=new Rect();
    mForegroundRect=new Rect();
    mShortcutsAndWidgets=new ShortcutAndWidgetContainer(context);
    mShortcutsAndWidgets.setCellDimensions(mCellWidth,mCellHeight,mWidthGap,mHeightGap,mCountX,mCountY);
    addView(mShortcutsAndWidgets);
  }
  public void enableHardwareLayer(  boolean hasLayer){
    mShortcutsAndWidgets.setLayerType(hasLayer ? LAYER_TYPE_HARDWARE : LAYER_TYPE_NONE,sPaint);
  }
  public void buildHardwareLayer(){
    mShortcutsAndWidgets.buildLayer();
  }
  public float getChildrenScale(){
    return mIsHotseat ? mHotseatScale : 1.0f;
  }
  public void setCellDimensions(  int width,  int height){
    mFixedCellWidth=mCellWidth=width;
    mFixedCellHeight=mCellHeight=height;
    mShortcutsAndWidgets.setCellDimensions(mCellWidth,mCellHeight,mWidthGap,mHeightGap,mCountX,mCountY);
  }
  public void setGridSize(  int x,  int y){
    mCountX=x;
    mCountY=y;
    mOccupied=new boolean[mCountX][mCountY];
    mTmpOccupied=new boolean[mCountX][mCountY];
    mTempRectStack.clear();
    mShortcutsAndWidgets.setCellDimensions(mCellWidth,mCellHeight,mWidthGap,mHeightGap,mCountX,mCountY);
    requestLayout();
  }
  public void setInvertIfRtl(  boolean invert){
    mShortcutsAndWidgets.setInvertIfRtl(invert);
  }
  public void setDropPending(  boolean pending){
    mDropPending=pending;
  }
  public boolean isDropPending(){
    return mDropPending;
  }
  private void invalidateBubbleTextView(  BubbleTextView icon){
    final int padding=icon.getPressedOrFocusedBackgroundPadding();
    invalidate(icon.getLeft() + getPaddingLeft() - padding,icon.getTop() + getPaddingTop() - padding,icon.getRight() + getPaddingLeft() + padding,icon.getBottom() + getPaddingTop() + padding);
  }
  void setOverScrollAmount(  float r,  boolean left){
    if (left && mOverScrollForegroundDrawable != mOverScrollLeft) {
      mOverScrollForegroundDrawable=mOverScrollLeft;
    }
 else     if (!left && mOverScrollForegroundDrawable != mOverScrollRight) {
      mOverScrollForegroundDrawable=mOverScrollRight;
    }
    r*=FOREGROUND_ALPHA_DAMPER;
    mForegroundAlpha=(int)Math.round((r * 255));
    mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
    invalidate();
  }
  void setPressedOrFocusedIcon(  BubbleTextView icon){
    BubbleTextView oldIcon=mPressedOrFocusedIcon;
    mPressedOrFocusedIcon=icon;
    if (oldIcon != null) {
      invalidateBubbleTextView(oldIcon);
    }
    if (mPressedOrFocusedIcon != null) {
      invalidateBubbleTextView(mPressedOrFocusedIcon);
    }
  }
  void setIsDragOverlapping(  boolean isDragOverlapping){
    if (mIsDragOverlapping != isDragOverlapping) {
      mIsDragOverlapping=isDragOverlapping;
      setUseActiveGlowBackground(mIsDragOverlapping);
      invalidate();
    }
  }
  void setUseActiveGlowBackground(  boolean use){
    mUseActiveGlowBackground=use;
  }
  boolean getIsDragOverlapping(){
    return mIsDragOverlapping;
  }
  protected void setOverscrollTransformsDirty(  boolean dirty){
    mScrollingTransformsDirty=dirty;
  }
  protected void resetOverscrollTransforms(){
    if (mScrollingTransformsDirty) {
      setOverscrollTransformsDirty(false);
      setTranslationX(0);
      setRotationY(0);
      setOverScrollAmount(0,false);
      setPivotX(getMeasuredWidth() / 2);
      setPivotY(getMeasuredHeight() / 2);
    }
  }
  @Override protected void onDraw(  Canvas canvas){
    if (mBackgroundAlpha > 0.0f) {
      Drawable bg;
      if (mUseActiveGlowBackground) {
        bg=mActiveGlowBackground;
      }
 else {
        bg=mNormalBackground;
      }
      bg.setAlpha((int)(mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
      bg.setBounds(mBackgroundRect);
      bg.draw(canvas);
    }
    final Paint paint=mDragOutlinePaint;
    for (int i=0; i < mDragOutlines.length; i++) {
      final float alpha=mDragOutlineAlphas[i];
      if (alpha > 0) {
        final Rect r=mDragOutlines[i];
        mTempRect.set(r);
        Utilities.scaleRectAboutCenter(mTempRect,getChildrenScale());
        final Bitmap b=(Bitmap)mDragOutlineAnims[i].getTag();
        paint.setAlpha((int)(alpha + .5f));
        canvas.drawBitmap(b,null,mTempRect,paint);
      }
    }
    if (mPressedOrFocusedIcon != null) {
      final int padding=mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
      final Bitmap b=mPressedOrFocusedIcon.getPressedOrFocusedBackground();
      if (b != null) {
        int offset=getMeasuredWidth() - getPaddingLeft() - getPaddingRight()- (mCountX * mCellWidth);
        int left=getPaddingLeft() + (int)Math.ceil(offset / 2f);
        int top=getPaddingTop();
        canvas.drawBitmap(b,mPressedOrFocusedIcon.getLeft() + left - padding,mPressedOrFocusedIcon.getTop() + top - padding,null);
      }
    }
    if (DEBUG_VISUALIZE_OCCUPIED) {
      int[] pt=new int[2];
      ColorDrawable cd=new ColorDrawable(Color.RED);
      cd.setBounds(0,0,mCellWidth,mCellHeight);
      for (int i=0; i < mCountX; i++) {
        for (int j=0; j < mCountY; j++) {
          if (mOccupied[i][j]) {
            cellToPoint(i,j,pt);
            canvas.save();
            canvas.translate(pt[0],pt[1]);
            cd.draw(canvas);
            canvas.restore();
          }
        }
      }
    }
    int previewOffset=FolderRingAnimator.sPreviewSize;
    LauncherAppState app=LauncherAppState.getInstance();
    DeviceProfile grid=app.getDynamicGrid().getDeviceProfile();
    for (int i=0; i < mFolderOuterRings.size(); i++) {
      FolderRingAnimator fra=mFolderOuterRings.get(i);
      Drawable d;
      int width, height;
      cellToPoint(fra.mCellX,fra.mCellY,mTempLocation);
      View child=getChildAt(fra.mCellX,fra.mCellY);
      if (child != null) {
        int centerX=mTempLocation[0] + mCellWidth / 2;
        int centerY=mTempLocation[1] + previewOffset / 2 + child.getPaddingTop() + grid.folderBackgroundOffset;
        if (FolderIcon.HAS_OUTER_RING) {
          d=FolderRingAnimator.sSharedOuterRingDrawable;
          width=(int)(fra.getOuterRingSize() * getChildrenScale());
          height=width;
          canvas.save();
          canvas.translate(centerX - width / 2,centerY - height / 2);
          d.setBounds(0,0,width,height);
          d.draw(canvas);
          canvas.restore();
        }
        d=FolderRingAnimator.sSharedInnerRingDrawable;
        width=(int)(fra.getInnerRingSize() * getChildrenScale());
        height=width;
        canvas.save();
        canvas.translate(centerX - width / 2,centerY - width / 2);
        d.setBounds(0,0,width,height);
        d.draw(canvas);
        canvas.restore();
      }
    }
    if (mFolderLeaveBehindCell[0] >= 0 && mFolderLeaveBehindCell[1] >= 0) {
      Drawable d=FolderIcon.sSharedFolderLeaveBehind;
      int width=d.getIntrinsicWidth();
      int height=d.getIntrinsicHeight();
      cellToPoint(mFolderLeaveBehindCell[0],mFolderLeaveBehindCell[1],mTempLocation);
      View child=getChildAt(mFolderLeaveBehindCell[0],mFolderLeaveBehindCell[1]);
      if (child != null) {
        int centerX=mTempLocation[0] + mCellWidth / 2;
        int centerY=mTempLocation[1] + previewOffset / 2 + child.getPaddingTop() + grid.folderBackgroundOffset;
        canvas.save();
        canvas.translate(centerX - width / 2,centerY - width / 2);
        d.setBounds(0,0,width,height);
        d.draw(canvas);
        canvas.restore();
      }
    }
  }
  @Override protected void dispatchDraw(  Canvas canvas){
    super.dispatchDraw(canvas);
    if (mForegroundAlpha > 0) {
      mOverScrollForegroundDrawable.setBounds(mForegroundRect);
      mOverScrollForegroundDrawable.draw(canvas);
    }
  }
  public void showFolderAccept(  FolderRingAnimator fra){
    mFolderOuterRings.add(fra);
  }
  public void hideFolderAccept(  FolderRingAnimator fra){
    if (mFolderOuterRings.contains(fra)) {
      mFolderOuterRings.remove(fra);
    }
    invalidate();
  }
  public void setFolderLeaveBehindCell(  int x,  int y){
    mFolderLeaveBehindCell[0]=x;
    mFolderLeaveBehindCell[1]=y;
    invalidate();
  }
  public void clearFolderLeaveBehind(){
    mFolderLeaveBehindCell[0]=-1;
    mFolderLeaveBehindCell[1]=-1;
    invalidate();
  }
  @Override public boolean shouldDelayChildPressedState(){
    return false;
  }
  public void restoreInstanceState(  SparseArray<Parcelable> states){
    dispatchRestoreInstanceState(states);
  }
  @Override public void cancelLongPress(){
    super.cancelLongPress();
    final int count=getChildCount();
    for (int i=0; i < count; i++) {
      final View child=getChildAt(i);
      child.cancelLongPress();
    }
  }
  public void setOnInterceptTouchListener(  View.OnTouchListener listener){
    mInterceptTouchListener=listener;
  }
  int getCountX(){
    return mCountX;
  }
  int getCountY(){
    return mCountY;
  }
  public void setIsHotseat(  boolean isHotseat){
    mIsHotseat=isHotseat;
    mShortcutsAndWidgets.setIsHotseat(isHotseat);
  }
  public boolean addViewToCellLayout(  View child,  int index,  int childId,  LayoutParams params,  boolean markCells){
    final LayoutParams lp=params;
    if (child instanceof BubbleTextView) {
      BubbleTextView bubbleChild=(BubbleTextView)child;
      bubbleChild.setTextVisibility(!mIsHotseat);
    }
    child.setScaleX(getChildrenScale());
    child.setScaleY(getChildrenScale());
    if (lp.cellX >= 0 && lp.cellX <= mCountX - 1 && lp.cellY >= 0 && lp.cellY <= mCountY - 1) {
      if (lp.cellHSpan < 0)       lp.cellHSpan=mCountX;
      if (lp.cellVSpan < 0)       lp.cellVSpan=mCountY;
      child.setId(childId);
      mShortcutsAndWidgets.addView(child,index,lp);
      if (markCells)       markCellsAsOccupiedForView(child);
      return true;
    }
    return false;
  }
  @Override public void removeAllViews(){
    clearOccupiedCells();
    mShortcutsAndWidgets.removeAllViews();
  }
  @Override public void removeAllViewsInLayout(){
    if (mShortcutsAndWidgets.getChildCount() > 0) {
      clearOccupiedCells();
      mShortcutsAndWidgets.removeAllViewsInLayout();
    }
  }
  public void removeViewWithoutMarkingCells(  View view){
    mShortcutsAndWidgets.removeView(view);
  }
  @Override public void removeView(  View view){
    markCellsAsUnoccupiedForView(view);
    mShortcutsAndWidgets.removeView(view);
  }
  @Override public void removeViewAt(  int index){
    markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));
    mShortcutsAndWidgets.removeViewAt(index);
  }
  @Override public void removeViewInLayout(  View view){
    markCellsAsUnoccupiedForView(view);
    mShortcutsAndWidgets.removeViewInLayout(view);
  }
  @Override public void removeViews(  int start,  int count){
    for (int i=start; i < start + count; i++) {
      markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
    }
    mShortcutsAndWidgets.removeViews(start,count);
  }
  @Override public void removeViewsInLayout(  int start,  int count){
    for (int i=start; i < start + count; i++) {
      markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
    }
    mShortcutsAndWidgets.removeViewsInLayout(start,count);
  }
  @Override protected void onAttachedToWindow(){
    super.onAttachedToWindow();
    if (getParent() instanceof Workspace) {
      Workspace workspace=(Workspace)getParent();
      mCellInfo.screenId=workspace.getIdForScreen(this);
    }
  }
  public void setTagToCellInfoForPoint(  int touchX,  int touchY){
    final CellInfo cellInfo=mCellInfo;
    Rect frame=mRect;
    final int x=touchX + getScrollX();
    final int y=touchY + getScrollY();
    final int count=mShortcutsAndWidgets.getChildCount();
    boolean found=false;
    for (int i=count - 1; i >= 0; i--) {
      final View child=mShortcutsAndWidgets.getChildAt(i);
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) && lp.isLockedToGrid) {
        child.getHitRect(frame);
        float scale=child.getScaleX();
        frame=new Rect(child.getLeft(),child.getTop(),child.getRight(),child.getBottom());
        frame.offset(getPaddingLeft(),getPaddingTop());
        frame.inset((int)(frame.width() * (1f - scale) / 2),(int)(frame.height() * (1f - scale) / 2));
        if (frame.contains(x,y)) {
          cellInfo.cell=child;
          cellInfo.cellX=lp.cellX;
          cellInfo.cellY=lp.cellY;
          cellInfo.spanX=lp.cellHSpan;
          cellInfo.spanY=lp.cellVSpan;
          found=true;
          break;
        }
      }
    }
    mLastDownOnOccupiedCell=found;
    if (!found) {
      final int cellXY[]=mTmpXY;
      pointToCellExact(x,y,cellXY);
      cellInfo.cell=null;
      cellInfo.cellX=cellXY[0];
      cellInfo.cellY=cellXY[1];
      cellInfo.spanX=1;
      cellInfo.spanY=1;
    }
    setTag(cellInfo);
  }
  @Override public boolean onInterceptTouchEvent(  MotionEvent ev){
    final int action=ev.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
      clearTagCellInfo();
    }
    if (mInterceptTouchListener != null && mInterceptTouchListener.onTouch(this,ev)) {
      return true;
    }
    if (action == MotionEvent.ACTION_DOWN) {
      setTagToCellInfoForPoint((int)ev.getX(),(int)ev.getY());
    }
    return false;
  }
  private void clearTagCellInfo(){
    final CellInfo cellInfo=mCellInfo;
    cellInfo.cell=null;
    cellInfo.cellX=-1;
    cellInfo.cellY=-1;
    cellInfo.spanX=0;
    cellInfo.spanY=0;
    setTag(cellInfo);
  }
  public CellInfo getTag(){
    return (CellInfo)super.getTag();
  }
  void pointToCellExact(  int x,  int y,  int[] result){
    final int hStartPadding=getPaddingLeft();
    final int vStartPadding=getPaddingTop();
    result[0]=(x - hStartPadding) / (mCellWidth + mWidthGap);
    result[1]=(y - vStartPadding) / (mCellHeight + mHeightGap);
    final int xAxis=mCountX;
    final int yAxis=mCountY;
    if (result[0] < 0)     result[0]=0;
    if (result[0] >= xAxis)     result[0]=xAxis - 1;
    if (result[1] < 0)     result[1]=0;
    if (result[1] >= yAxis)     result[1]=yAxis - 1;
  }
  void pointToCellRounded(  int x,  int y,  int[] result){
    pointToCellExact(x + (mCellWidth / 2),y + (mCellHeight / 2),result);
  }
  void cellToPoint(  int cellX,  int cellY,  int[] result){
    final int hStartPadding=getPaddingLeft();
    final int vStartPadding=getPaddingTop();
    result[0]=hStartPadding + cellX * (mCellWidth + mWidthGap);
    result[1]=vStartPadding + cellY * (mCellHeight + mHeightGap);
  }
  void cellToCenterPoint(  int cellX,  int cellY,  int[] result){
    regionToCenterPoint(cellX,cellY,1,1,result);
  }
  void regionToCenterPoint(  int cellX,  int cellY,  int spanX,  int spanY,  int[] result){
    final int hStartPadding=getPaddingLeft();
    final int vStartPadding=getPaddingTop();
    result[0]=hStartPadding + cellX * (mCellWidth + mWidthGap) + (spanX * mCellWidth + (spanX - 1) * mWidthGap) / 2;
    result[1]=vStartPadding + cellY * (mCellHeight + mHeightGap) + (spanY * mCellHeight + (spanY - 1) * mHeightGap) / 2;
  }
  void regionToRect(  int cellX,  int cellY,  int spanX,  int spanY,  Rect result){
    final int hStartPadding=getPaddingLeft();
    final int vStartPadding=getPaddingTop();
    final int left=hStartPadding + cellX * (mCellWidth + mWidthGap);
    final int top=vStartPadding + cellY * (mCellHeight + mHeightGap);
    result.set(left,top,left + (spanX * mCellWidth + (spanX - 1) * mWidthGap),top + (spanY * mCellHeight + (spanY - 1) * mHeightGap));
  }
  public float getDistanceFromCell(  float x,  float y,  int[] cell){
    cellToCenterPoint(cell[0],cell[1],mTmpPoint);
    float distance=(float)Math.sqrt(Math.pow(x - mTmpPoint[0],2) + Math.pow(y - mTmpPoint[1],2));
    return distance;
  }
  int getCellWidth(){
    return mCellWidth;
  }
  int getCellHeight(){
    return mCellHeight;
  }
  int getWidthGap(){
    return mWidthGap;
  }
  int getHeightGap(){
    return mHeightGap;
  }
  Rect getContentRect(  Rect r){
    if (r == null) {
      r=new Rect();
    }
    int left=getPaddingLeft();
    int top=getPaddingTop();
    int right=left + getWidth() - getPaddingLeft() - getPaddingRight();
    int bottom=top + getHeight() - getPaddingTop() - getPaddingBottom();
    r.set(left,top,right,bottom);
    return r;
  }
  static void getMetrics(  Rect metrics,  int paddedMeasureWidth,  int paddedMeasureHeight,  int countX,  int countY){
    LauncherAppState app=LauncherAppState.getInstance();
    DeviceProfile grid=app.getDynamicGrid().getDeviceProfile();
    metrics.set(grid.calculateCellWidth(paddedMeasureWidth,countX),grid.calculateCellHeight(paddedMeasureHeight,countY),0,0);
  }
  public void setFixedSize(  int width,  int height){
    mFixedWidth=width;
    mFixedHeight=height;
  }
  @Override protected void onMeasure(  int widthMeasureSpec,  int heightMeasureSpec){
    LauncherAppState app=LauncherAppState.getInstance();
    DeviceProfile grid=app.getDynamicGrid().getDeviceProfile();
    int widthSpecMode=MeasureSpec.getMode(widthMeasureSpec);
    int heightSpecMode=MeasureSpec.getMode(heightMeasureSpec);
    int widthSize=MeasureSpec.getSize(widthMeasureSpec);
    int heightSize=MeasureSpec.getSize(heightMeasureSpec);
    int childWidthSize=widthSize - (getPaddingLeft() + getPaddingRight());
    int childHeightSize=heightSize - (getPaddingTop() + getPaddingBottom());
    if (mFixedCellWidth < 0 || mFixedCellHeight < 0) {
      int cw=grid.calculateCellWidth(childWidthSize,mCountX);
      int ch=grid.calculateCellHeight(childHeightSize,mCountY);
      if (cw != mCellWidth || ch != mCellHeight) {
        mCellWidth=cw;
        mCellHeight=ch;
        mShortcutsAndWidgets.setCellDimensions(mCellWidth,mCellHeight,mWidthGap,mHeightGap,mCountX,mCountY);
      }
    }
    int newWidth=childWidthSize;
    int newHeight=childHeightSize;
    if (mFixedWidth > 0 && mFixedHeight > 0) {
      newWidth=mFixedWidth;
      newHeight=mFixedHeight;
    }
 else     if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
      throw new RuntimeException("CellLayout cannot have UNSPECIFIED dimensions");
    }
    int numWidthGaps=mCountX - 1;
    int numHeightGaps=mCountY - 1;
    if (mOriginalWidthGap < 0 || mOriginalHeightGap < 0) {
      int hSpace=childWidthSize;
      int vSpace=childHeightSize;
      int hFreeSpace=hSpace - (mCountX * mCellWidth);
      int vFreeSpace=vSpace - (mCountY * mCellHeight);
      mWidthGap=Math.min(mMaxGap,numWidthGaps > 0 ? (hFreeSpace / numWidthGaps) : 0);
      mHeightGap=Math.min(mMaxGap,numHeightGaps > 0 ? (vFreeSpace / numHeightGaps) : 0);
      mShortcutsAndWidgets.setCellDimensions(mCellWidth,mCellHeight,mWidthGap,mHeightGap,mCountX,mCountY);
    }
 else {
      mWidthGap=mOriginalWidthGap;
      mHeightGap=mOriginalHeightGap;
    }
    int count=getChildCount();
    int maxWidth=0;
    int maxHeight=0;
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      int childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(newWidth,MeasureSpec.EXACTLY);
      int childheightMeasureSpec=MeasureSpec.makeMeasureSpec(newHeight,MeasureSpec.EXACTLY);
      child.measure(childWidthMeasureSpec,childheightMeasureSpec);
      maxWidth=Math.max(maxWidth,child.getMeasuredWidth());
      maxHeight=Math.max(maxHeight,child.getMeasuredHeight());
    }
    if (mFixedWidth > 0 && mFixedHeight > 0) {
      setMeasuredDimension(maxWidth,maxHeight);
    }
 else {
      setMeasuredDimension(widthSize,heightSize);
    }
  }
  @Override protected void onLayout(  boolean changed,  int l,  int t,  int r,  int b){
    int offset=getMeasuredWidth() - getPaddingLeft() - getPaddingRight()- (mCountX * mCellWidth);
    int left=getPaddingLeft() + (int)Math.ceil(offset / 2f);
    int top=getPaddingTop();
    int count=getChildCount();
    for (int i=0; i < count; i++) {
      View child=getChildAt(i);
      child.layout(left,top,left + r - l,top + b - t);
    }
  }
  @Override protected void onSizeChanged(  int w,  int h,  int oldw,  int oldh){
    super.onSizeChanged(w,h,oldw,oldh);
    Rect padding=new Rect();
    mNormalBackground.getPadding(padding);
    mBackgroundRect.set(-padding.left,-padding.top,w + padding.right,h + padding.bottom);
    mForegroundRect.set(mForegroundPadding,mForegroundPadding,w - mForegroundPadding,h - mForegroundPadding);
  }
  @Override protected void setChildrenDrawingCacheEnabled(  boolean enabled){
    mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);
  }
  @Override protected void setChildrenDrawnWithCacheEnabled(  boolean enabled){
    mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);
  }
  public float getBackgroundAlpha(){
    return mBackgroundAlpha;
  }
  public void setBackgroundAlphaMultiplier(  float multiplier){
    if (mBackgroundAlphaMultiplier != multiplier) {
      mBackgroundAlphaMultiplier=multiplier;
      invalidate();
    }
  }
  public float getBackgroundAlphaMultiplier(){
    return mBackgroundAlphaMultiplier;
  }
  public void setBackgroundAlpha(  float alpha){
    if (mBackgroundAlpha != alpha) {
      mBackgroundAlpha=alpha;
      invalidate();
    }
  }
  public void setShortcutAndWidgetAlpha(  float alpha){
    final int childCount=getChildCount();
    for (int i=0; i < childCount; i++) {
      getChildAt(i).setAlpha(alpha);
    }
  }
  public ShortcutAndWidgetContainer getShortcutsAndWidgets(){
    if (getChildCount() > 0) {
      return (ShortcutAndWidgetContainer)getChildAt(0);
    }
    return null;
  }
  public View getChildAt(  int x,  int y){
    return mShortcutsAndWidgets.getChildAt(x,y);
  }
  public boolean animateChildToPosition(  final View child,  int cellX,  int cellY,  int duration,  int delay,  boolean permanent,  boolean adjustOccupied){
    ShortcutAndWidgetContainer clc=getShortcutsAndWidgets();
    boolean[][] occupied=mOccupied;
    if (!permanent) {
      occupied=mTmpOccupied;
    }
    if (clc.indexOfChild(child) != -1) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final ItemInfo info=(ItemInfo)child.getTag();
      if (mReorderAnimators.containsKey(lp)) {
        mReorderAnimators.get(lp).cancel();
        mReorderAnimators.remove(lp);
      }
      final int oldX=lp.x;
      final int oldY=lp.y;
      if (adjustOccupied) {
        occupied[lp.cellX][lp.cellY]=false;
        occupied[cellX][cellY]=true;
      }
      lp.isLockedToGrid=true;
      if (permanent) {
        lp.cellX=info.cellX=cellX;
        lp.cellY=info.cellY=cellY;
      }
 else {
        lp.tmpCellX=cellX;
        lp.tmpCellY=cellY;
      }
      clc.setupLp(lp);
      lp.isLockedToGrid=false;
      final int newX=lp.x;
      final int newY=lp.y;
      lp.x=oldX;
      lp.y=oldY;
      if (oldX == newX && oldY == newY) {
        lp.isLockedToGrid=true;
        return true;
      }
      ValueAnimator va=LauncherAnimUtils.ofFloat(child,0f,1f);
      va.setDuration(duration);
      mReorderAnimators.put(lp,va);
      va.addUpdateListener(new AnimatorUpdateListener(){
        @Override public void onAnimationUpdate(        ValueAnimator animation){
          float r=((Float)animation.getAnimatedValue()).floatValue();
          lp.x=(int)((1 - r) * oldX + r * newX);
          lp.y=(int)((1 - r) * oldY + r * newY);
          child.requestLayout();
        }
      }
);
      va.addListener(new AnimatorListenerAdapter(){
        boolean cancelled=false;
        public void onAnimationEnd(        Animator animation){
          if (!cancelled) {
            lp.isLockedToGrid=true;
            child.requestLayout();
          }
          if (mReorderAnimators.containsKey(lp)) {
            mReorderAnimators.remove(lp);
          }
        }
        public void onAnimationCancel(        Animator animation){
          cancelled=true;
        }
      }
);
      va.setStartDelay(delay);
      va.start();
      return true;
    }
    return false;
  }
  void estimateDropCell(  int originX,  int originY,  int spanX,  int spanY,  int[] result){
    final int countX=mCountX;
    final int countY=mCountY;
    pointToCellRounded(originX,originY,result);
    int rightOverhang=result[0] + spanX - countX;
    if (rightOverhang > 0) {
      result[0]-=rightOverhang;
    }
    result[0]=Math.max(0,result[0]);
    int bottomOverhang=result[1] + spanY - countY;
    if (bottomOverhang > 0) {
      result[1]-=bottomOverhang;
    }
    result[1]=Math.max(0,result[1]);
  }
  void visualizeDropLocation(  View v,  Bitmap dragOutline,  int originX,  int originY,  int cellX,  int cellY,  int spanX,  int spanY,  boolean resize,  Point dragOffset,  Rect dragRegion){
    final int oldDragCellX=mDragCell[0];
    final int oldDragCellY=mDragCell[1];
    if (dragOutline == null && v == null) {
      return;
    }
    if (cellX != oldDragCellX || cellY != oldDragCellY) {
      mDragCell[0]=cellX;
      mDragCell[1]=cellY;
      final int[] topLeft=mTmpPoint;
      cellToPoint(cellX,cellY,topLeft);
      int left=topLeft[0];
      int top=topLeft[1];
      if (v != null && dragOffset == null) {
        MarginLayoutParams lp=(MarginLayoutParams)v.getLayoutParams();
        left+=lp.leftMargin;
        top+=lp.topMargin;
        top+=(v.getHeight() - dragOutline.getHeight()) / 2;
        left+=((mCellWidth * spanX) + ((spanX - 1) * mWidthGap) - dragOutline.getWidth()) / 2;
      }
 else {
        if (dragOffset != null && dragRegion != null) {
          left+=dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap) - dragRegion.width()) / 2;
          int cHeight=getShortcutsAndWidgets().getCellContentHeight();
          int cellPaddingY=(int)Math.max(0,((mCellHeight - cHeight) / 2f));
          top+=dragOffset.y + cellPaddingY;
        }
 else {
          left+=((mCellWidth * spanX) + ((spanX - 1) * mWidthGap) - dragOutline.getWidth()) / 2;
          top+=((mCellHeight * spanY) + ((spanY - 1) * mHeightGap) - dragOutline.getHeight()) / 2;
        }
      }
      final int oldIndex=mDragOutlineCurrent;
      mDragOutlineAnims[oldIndex].animateOut();
      mDragOutlineCurrent=(oldIndex + 1) % mDragOutlines.length;
      Rect r=mDragOutlines[mDragOutlineCurrent];
      r.set(left,top,left + dragOutline.getWidth(),top + dragOutline.getHeight());
      if (resize) {
        cellToRect(cellX,cellY,spanX,spanY,r);
      }
      mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
      mDragOutlineAnims[mDragOutlineCurrent].animateIn();
    }
  }
  public void clearDragOutlines(){
    final int oldIndex=mDragOutlineCurrent;
    mDragOutlineAnims[oldIndex].animateOut();
    mDragCell[0]=mDragCell[1]=-1;
  }
  int[] findNearestVacantArea(  int pixelX,  int pixelY,  int spanX,  int spanY,  int[] result){
    return findNearestVacantArea(pixelX,pixelY,spanX,spanY,null,result);
  }
  int[] findNearestVacantArea(  int pixelX,  int pixelY,  int minSpanX,  int minSpanY,  int spanX,  int spanY,  int[] result,  int[] resultSpan){
    return findNearestVacantArea(pixelX,pixelY,minSpanX,minSpanY,spanX,spanY,null,result,resultSpan);
  }
  int[] findNearestArea(  int pixelX,  int pixelY,  int spanX,  int spanY,  View ignoreView,  boolean ignoreOccupied,  int[] result){
    return findNearestArea(pixelX,pixelY,spanX,spanY,spanX,spanY,ignoreView,ignoreOccupied,result,null,mOccupied);
  }
  private final Stack<Rect> mTempRectStack=new Stack<Rect>();
  private void lazyInitTempRectStack(){
    if (mTempRectStack.isEmpty()) {
      for (int i=0; i < mCountX * mCountY; i++) {
        mTempRectStack.push(new Rect());
      }
    }
  }
  private void recycleTempRects(  Stack<Rect> used){
    while (!used.isEmpty()) {
      mTempRectStack.push(used.pop());
    }
  }
  int[] findNearestArea(  int pixelX,  int pixelY,  int minSpanX,  int minSpanY,  int spanX,  int spanY,  View ignoreView,  boolean ignoreOccupied,  int[] result,  int[] resultSpan,  boolean[][] occupied){
    lazyInitTempRectStack();
    markCellsAsUnoccupiedForView(ignoreView,occupied);
    pixelX-=(mCellWidth + mWidthGap) * (spanX - 1) / 2f;
    pixelY-=(mCellHeight + mHeightGap) * (spanY - 1) / 2f;
    final int[] bestXY=result != null ? result : new int[2];
    double bestDistance=Double.MAX_VALUE;
    final Rect bestRect=new Rect(-1,-1,-1,-1);
    final Stack<Rect> validRegions=new Stack<Rect>();
    final int countX=mCountX;
    final int countY=mCountY;
    if (minSpanX <= 0 || minSpanY <= 0 || spanX <= 0 || spanY <= 0 || spanX < minSpanX || spanY < minSpanY) {
      return bestXY;
    }
    for (int y=0; y < countY - (minSpanY - 1); y++) {
      inner:       for (int x=0; x < countX - (minSpanX - 1); x++) {
        int ySize=-1;
        int xSize=-1;
        if (ignoreOccupied) {
          for (int i=0; i < minSpanX; i++) {
            for (int j=0; j < minSpanY; j++) {
              if (occupied[x + i][y + j]) {
                continue inner;
              }
            }
          }
          xSize=minSpanX;
          ySize=minSpanY;
          boolean incX=true;
          boolean hitMaxX=xSize >= spanX;
          boolean hitMaxY=ySize >= spanY;
          while (!(hitMaxX && hitMaxY)) {
            if (incX && !hitMaxX) {
              for (int j=0; j < ySize; j++) {
                if (x + xSize > countX - 1 || occupied[x + xSize][y + j]) {
                  hitMaxX=true;
                }
              }
              if (!hitMaxX) {
                xSize++;
              }
            }
 else             if (!hitMaxY) {
              for (int i=0; i < xSize; i++) {
                if (y + ySize > countY - 1 || occupied[x + i][y + ySize]) {
                  hitMaxY=true;
                }
              }
              if (!hitMaxY) {
                ySize++;
              }
            }
            hitMaxX|=xSize >= spanX;
            hitMaxY|=ySize >= spanY;
            incX=!incX;
          }
          incX=true;
          hitMaxX=xSize >= spanX;
          hitMaxY=ySize >= spanY;
        }
        final int[] cellXY=mTmpXY;
        cellToCenterPoint(x,y,cellXY);
        Rect currentRect=mTempRectStack.pop();
        currentRect.set(x,y,x + xSize,y + ySize);
        boolean contained=false;
        for (        Rect r : validRegions) {
          if (r.contains(currentRect)) {
            contained=true;
            break;
          }
        }
        validRegions.push(currentRect);
        double distance=Math.sqrt(Math.pow(cellXY[0] - pixelX,2) + Math.pow(cellXY[1] - pixelY,2));
        if ((distance <= bestDistance && !contained) || currentRect.contains(bestRect)) {
          bestDistance=distance;
          bestXY[0]=x;
          bestXY[1]=y;
          if (resultSpan != null) {
            resultSpan[0]=xSize;
            resultSpan[1]=ySize;
          }
          bestRect.set(currentRect);
        }
      }
    }
    markCellsAsOccupiedForView(ignoreView,occupied);
    if (bestDistance == Double.MAX_VALUE) {
      bestXY[0]=-1;
      bestXY[1]=-1;
    }
    recycleTempRects(validRegions);
    return bestXY;
  }
  private int[] findNearestArea(  int cellX,  int cellY,  int spanX,  int spanY,  int[] direction,  boolean[][] occupied,  boolean blockOccupied[][],  int[] result){
    final int[] bestXY=result != null ? result : new int[2];
    float bestDistance=Float.MAX_VALUE;
    int bestDirectionScore=Integer.MIN_VALUE;
    final int countX=mCountX;
    final int countY=mCountY;
    for (int y=0; y < countY - (spanY - 1); y++) {
      inner:       for (int x=0; x < countX - (spanX - 1); x++) {
        for (int i=0; i < spanX; i++) {
          for (int j=0; j < spanY; j++) {
            if (occupied[x + i][y + j] && (blockOccupied == null || blockOccupied[i][j])) {
              continue inner;
            }
          }
        }
        float distance=(float)Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
        int[] curDirection=mTmpPoint;
        computeDirectionVector(x - cellX,y - cellY,curDirection);
        int curDirectionScore=direction[0] * curDirection[0] + direction[1] * curDirection[1];
        boolean exactDirectionOnly=false;
        boolean directionMatches=direction[0] == curDirection[0] && direction[0] == curDirection[0];
        if ((directionMatches || !exactDirectionOnly) && Float.compare(distance,bestDistance) < 0 || (Float.compare(distance,bestDistance) == 0 && curDirectionScore > bestDirectionScore)) {
          bestDistance=distance;
          bestDirectionScore=curDirectionScore;
          bestXY[0]=x;
          bestXY[1]=y;
        }
      }
    }
    if (bestDistance == Float.MAX_VALUE) {
      bestXY[0]=-1;
      bestXY[1]=-1;
    }
    return bestXY;
  }
  private boolean addViewToTempLocation(  View v,  Rect rectOccupiedByPotentialDrop,  int[] direction,  ItemConfiguration currentState){
    CellAndSpan c=currentState.map.get(v);
    boolean success=false;
    markCellsForView(c.x,c.y,c.spanX,c.spanY,mTmpOccupied,false);
    markCellsForRect(rectOccupiedByPotentialDrop,mTmpOccupied,true);
    findNearestArea(c.x,c.y,c.spanX,c.spanY,direction,mTmpOccupied,null,mTempLocation);
    if (mTempLocation[0] >= 0 && mTempLocation[1] >= 0) {
      c.x=mTempLocation[0];
      c.y=mTempLocation[1];
      success=true;
    }
    markCellsForView(c.x,c.y,c.spanX,c.spanY,mTmpOccupied,true);
    return success;
  }
private class ViewCluster {
    final static int LEFT=0;
    final static int TOP=1;
    final static int RIGHT=2;
    final static int BOTTOM=3;
    ArrayList<View> views;
    ItemConfiguration config;
    Rect boundingRect=new Rect();
    int[] leftEdge=new int[mCountY];
    int[] rightEdge=new int[mCountY];
    int[] topEdge=new int[mCountX];
    int[] bottomEdge=new int[mCountX];
    boolean leftEdgeDirty, rightEdgeDirty, topEdgeDirty, bottomEdgeDirty, boundingRectDirty;
    @SuppressWarnings("unchecked") public ViewCluster(    ArrayList<View> views,    ItemConfiguration config){
      this.views=(ArrayList<View>)views.clone();
      this.config=config;
      resetEdges();
    }
    void resetEdges(){
      for (int i=0; i < mCountX; i++) {
        topEdge[i]=-1;
        bottomEdge[i]=-1;
      }
      for (int i=0; i < mCountY; i++) {
        leftEdge[i]=-1;
        rightEdge[i]=-1;
      }
      leftEdgeDirty=true;
      rightEdgeDirty=true;
      bottomEdgeDirty=true;
      topEdgeDirty=true;
      boundingRectDirty=true;
    }
    void computeEdge(    int which,    int[] edge){
      int count=views.size();
      for (int i=0; i < count; i++) {
        CellAndSpan cs=config.map.get(views.get(i));
switch (which) {
case LEFT:
          int left=cs.x;
        for (int j=cs.y; j < cs.y + cs.spanY; j++) {
          if (left < edge[j] || edge[j] < 0) {
            edge[j]=left;
          }
        }
      break;
case RIGHT:
    int right=cs.x + cs.spanX;
  for (int j=cs.y; j < cs.y + cs.spanY; j++) {
    if (right > edge[j]) {
      edge[j]=right;
    }
  }
break;
case TOP:
int top=cs.y;
for (int j=cs.x; j < cs.x + cs.spanX; j++) {
if (top < edge[j] || edge[j] < 0) {
edge[j]=top;
}
}
break;
case BOTTOM:
int bottom=cs.y + cs.spanY;
for (int j=cs.x; j < cs.x + cs.spanX; j++) {
if (bottom > edge[j]) {
edge[j]=bottom;
}
}
break;
}
}
}
boolean isViewTouchingEdge(View v,int whichEdge){
CellAndSpan cs=config.map.get(v);
int[] edge=getEdge(whichEdge);
switch (whichEdge) {
case LEFT:
for (int i=cs.y; i < cs.y + cs.spanY; i++) {
if (edge[i] == cs.x + cs.spanX) {
return true;
}
}
break;
case RIGHT:
for (int i=cs.y; i < cs.y + cs.spanY; i++) {
if (edge[i] == cs.x) {
return true;
}
}
break;
case TOP:
for (int i=cs.x; i < cs.x + cs.spanX; i++) {
if (edge[i] == cs.y + cs.spanY) {
return true;
}
}
break;
case BOTTOM:
for (int i=cs.x; i < cs.x + cs.spanX; i++) {
if (edge[i] == cs.y) {
return true;
}
}
break;
}
return false;
}
void shift(int whichEdge,int delta){
for (View v : views) {
CellAndSpan c=config.map.get(v);
switch (whichEdge) {
case LEFT:
c.x-=delta;
break;
case RIGHT:
c.x+=delta;
break;
case TOP:
c.y-=delta;
break;
case BOTTOM:
default :
c.y+=delta;
break;
}
}
resetEdges();
}
public void addView(View v){
views.add(v);
resetEdges();
}
public Rect getBoundingRect(){
if (boundingRectDirty) {
boolean first=true;
for (View v : views) {
CellAndSpan c=config.map.get(v);
if (first) {
boundingRect.set(c.x,c.y,c.x + c.spanX,c.y + c.spanY);
first=false;
}
 else {
boundingRect.union(c.x,c.y,c.x + c.spanX,c.y + c.spanY);
}
}
}
return boundingRect;
}
public int[] getEdge(int which){
switch (which) {
case LEFT:
return getLeftEdge();
case RIGHT:
return getRightEdge();
case TOP:
return getTopEdge();
case BOTTOM:
default :
return getBottomEdge();
}
}
public int[] getLeftEdge(){
if (leftEdgeDirty) {
computeEdge(LEFT,leftEdge);
}
return leftEdge;
}
public int[] getRightEdge(){
if (rightEdgeDirty) {
computeEdge(RIGHT,rightEdge);
}
return rightEdge;
}
public int[] getTopEdge(){
if (topEdgeDirty) {
computeEdge(TOP,topEdge);
}
return topEdge;
}
public int[] getBottomEdge(){
if (bottomEdgeDirty) {
computeEdge(BOTTOM,bottomEdge);
}
return bottomEdge;
}
PositionComparator comparator=new PositionComparator();
class PositionComparator implements Comparator<View> {
int whichEdge=0;
public int compare(View left,View right){
CellAndSpan l=config.map.get(left);
CellAndSpan r=config.map.get(right);
switch (whichEdge) {
case LEFT:
return (r.x + r.spanX) - (l.x + l.spanX);
case RIGHT:
return l.x - r.x;
case TOP:
return (r.y + r.spanY) - (l.y + l.spanY);
case BOTTOM:
default :
return l.y - r.y;
}
}
}
public void sortConfigurationForEdgePush(int edge){
comparator.whichEdge=edge;
Collections.sort(config.sortedViews,comparator);
}
}
private boolean pushViewsToTempLocation(ArrayList<View> views,Rect rectOccupiedByPotentialDrop,int[] direction,View dragView,ItemConfiguration currentState){
ViewCluster cluster=new ViewCluster(views,currentState);
Rect clusterRect=cluster.getBoundingRect();
int whichEdge;
int pushDistance;
boolean fail=false;
if (direction[0] < 0) {
whichEdge=ViewCluster.LEFT;
pushDistance=clusterRect.right - rectOccupiedByPotentialDrop.left;
}
 else if (direction[0] > 0) {
whichEdge=ViewCluster.RIGHT;
pushDistance=rectOccupiedByPotentialDrop.right - clusterRect.left;
}
 else if (direction[1] < 0) {
whichEdge=ViewCluster.TOP;
pushDistance=clusterRect.bottom - rectOccupiedByPotentialDrop.top;
}
 else {
whichEdge=ViewCluster.BOTTOM;
pushDistance=rectOccupiedByPotentialDrop.bottom - clusterRect.top;
}
if (pushDistance <= 0) {
return false;
}
for (View v : views) {
CellAndSpan c=currentState.map.get(v);
markCellsForView(c.x,c.y,c.spanX,c.spanY,mTmpOccupied,false);
}
currentState.save();
cluster.sortConfigurationForEdgePush(whichEdge);
while (pushDistance > 0 && !fail) {
for (View v : currentState.sortedViews) {
if (!cluster.views.contains(v) && v != dragView) {
if (cluster.isViewTouchingEdge(v,whichEdge)) {
LayoutParams lp=(LayoutParams)v.getLayoutParams();
if (!lp.canReorder) {
fail=true;
break;
}
cluster.addView(v);
CellAndSpan c=currentState.map.get(v);
markCellsForView(c.x,c.y,c.spanX,c.spanY,mTmpOccupied,false);
}
}
}
pushDistance--;
cluster.shift(whichEdge,1);
}
boolean foundSolution=false;
clusterRect=cluster.getBoundingRect();
if (!fail && clusterRect.left >= 0 && clusterRect.right <= mCountX && clusterRect.top >= 0 && clusterRect.bottom <= mCountY) {
foundSolution=true;
}
 else {
currentState.restore();
}
for (View v : cluster.views) {
CellAndSpan c=currentState.map.get(v);
markCellsForView(c.x,c.y,c.spanX,c.spanY,mTmpOccupied,true);
}
return foundSolution;
}
private boolean addViewsToTempLocation(ArrayList<View> views,Rect rectOccupiedByPotentialDrop,int[] direction,View dragView,ItemConfiguration currentState){
if (views.size() == 0) return true;
boolean success=false;
Rect boundingRect=null;
for (View v : views) {
CellAndSpan c=currentState.map.get(v);
if (boundingRect == null) {
boundingRect=new Rect(c.x,c.y,c.x + c.spanX,c.y + c.spanY);
}
 else {
boundingRect.union(c.x,c.y,c.x + c.spanX,c.y + c.spanY);
}
}
for (View v : views) {
CellAndSpan c=currentState.map.get(v);
markCellsForView(c.x,c.y,c.spanX,c.spanY,mTmpOccupied,false);
}
boolean[][] blockOccupied=new boolean[boundingRect.width()][boundingRect.height()];
int top=boundingRect.top;
int left=boundingRect.left;
for (View v : views) {
CellAndSpan c=currentState.map.get(v);
markCellsForView(c.x - left,c.y - top,c.spanX,c.spanY,blockOccupied,true);
}
markCellsForRect(rectOccupiedByPotentialDrop,mTmpOccupied,true);
findNearestArea(boundingRect.left,boundingRect.top,boundingRect.width(),boundingRect.height(),direction,mTmpOccupied,blockOccupied,mTempLocation);
if (mTempLocation[0] >= 0 && mTempLocation[1] >= 0) {
int deltaX=mTempLocation[0] - boundingRect.left;
int deltaY=mTempLocation[1] - boundingRect.top;
for (View v : views) {
CellAndSpan c=currentState.map.get(v);
c.x+=deltaX;
c.y+=deltaY;
}
success=true;
}
for (View v : views) {
CellAndSpan c=currentState.map.get(v);
markCellsForView(c.x,c.y,c.spanX,c.spanY,mTmpOccupied,true);
}
return success;
}
private void markCellsForRect(Rect r,boolean[][] occupied,boolean value){
markCellsForView(r.left,r.top,r.width(),r.height(),occupied,value);
}
private boolean attemptPushInDirection(ArrayList<View> intersectingViews,Rect occupied,int[] direction,View ignoreView,ItemConfiguration solution){
if ((Math.abs(direction[0]) + Math.abs(direction[1])) > 1) {
int temp=direction[1];
direction[1]=0;
if (pushViewsToTempLocation(intersectingViews,occupied,direction,ignoreView,solution)) {
return true;
}
direction[1]=temp;
temp=direction[0];
direction[0]=0;
if (pushViewsToTempLocation(intersectingViews,occupied,direction,ignoreView,solution)) {
return true;
}
direction[0]=temp;
direction[0]*=-1;
direction[1]*=-1;
temp=direction[1];
direction[1]=0;
if (pushViewsToTempLocation(intersectingViews,occupied,direction,ignoreView,solution)) {
return true;
}
direction[1]=temp;
temp=direction[0];
direction[0]=0;
if (pushViewsToTempLocation(intersectingViews,occupied,direction,ignoreView,solution)) {
return true;
}
direction[0]=temp;
direction[0]*=-1;
direction[1]*=-1;
}
 else {
if (pushViewsToTempLocation(intersectingViews,occupied,direction,ignoreView,solution)) {
return true;
}
direction[0]*=-1;
direction[1]*=-1;
if (pushViewsToTempLocation(intersectingViews,occupied,direction,ignoreView,solution)) {
return true;
}
direction[0]*=-1;
direction[1]*=-1;
int temp=direction[1];
direction[1]=direction[0];
direction[0]=temp;
if (pushViewsToTempLocation(intersectingViews,occupied,direction,ignoreView,solution)) {
return true;
}
direction[0]*=-1;
direction[1]*=-1;
if (pushViewsToTempLocation(intersectingViews,occupied,direction,ignoreView,solution)) {
return true;
}
direction[0]*=-1;
direction[1]*=-1;
temp=direction[1];
direction[1]=direction[0];
direction[0]=temp;
}
return false;
}
private boolean rearrangementExists(int cellX,int cellY,int spanX,int spanY,int[] direction,View ignoreView,ItemConfiguration solution){
if (cellX < 0 || cellY < 0) return false;
mIntersectingViews.clear();
mOccupiedRect.set(cellX,cellY,cellX + spanX,cellY + spanY);
if (ignoreView != null) {
CellAndSpan c=solution.map.get(ignoreView);
if (c != null) {
c.x=cellX;
c.y=cellY;
}
}
Rect r0=new Rect(cellX,cellY,cellX + spanX,cellY + spanY);
Rect r1=new Rect();
for (View child : solution.map.keySet()) {
if (child == ignoreView) continue;
CellAndSpan c=solution.map.get(child);
LayoutParams lp=(LayoutParams)child.getLayoutParams();
r1.set(c.x,c.y,c.x + c.spanX,c.y + c.spanY);
if (Rect.intersects(r0,r1)) {
if (!lp.canReorder) {
return false;
}
mIntersectingViews.add(child);
}
}
solution.intersectingViews=new ArrayList<View>(mIntersectingViews);
if (attemptPushInDirection(mIntersectingViews,mOccupiedRect,direction,ignoreView,solution)) {
return true;
}
if (addViewsToTempLocation(mIntersectingViews,mOccupiedRect,direction,ignoreView,solution)) {
return true;
}
for (View v : mIntersectingViews) {
if (!addViewToTempLocation(v,mOccupiedRect,direction,solution)) {
return false;
}
}
return true;
}
private void computeDirectionVector(float deltaX,float deltaY,int[] result){
double angle=Math.atan(((float)deltaY) / deltaX);
result[0]=0;
result[1]=0;
if (Math.abs(Math.cos(angle)) > 0.5f) {
result[0]=(int)Math.signum(deltaX);
}
if (Math.abs(Math.sin(angle)) > 0.5f) {
result[1]=(int)Math.signum(deltaY);
}
}
private void copyOccupiedArray(boolean[][] occupied){
for (int i=0; i < mCountX; i++) {
for (int j=0; j < mCountY; j++) {
occupied[i][j]=mOccupied[i][j];
}
}
}
ItemConfiguration findReorderSolution(int pixelX,int pixelY,int minSpanX,int minSpanY,int spanX,int spanY,int[] direction,View dragView,boolean decX,ItemConfiguration solution){
copyCurrentStateToSolution(solution,false);
copyOccupiedArray(mTmpOccupied);
int result[]=new int[2];
result=findNearestArea(pixelX,pixelY,spanX,spanY,result);
boolean success=false;
success=rearrangementExists(result[0],result[1],spanX,spanY,direction,dragView,solution);
if (!success) {
if (spanX > minSpanX && (minSpanY == spanY || decX)) {
return findReorderSolution(pixelX,pixelY,minSpanX,minSpanY,spanX - 1,spanY,direction,dragView,false,solution);
}
 else if (spanY > minSpanY) {
return findReorderSolution(pixelX,pixelY,minSpanX,minSpanY,spanX,spanY - 1,direction,dragView,true,solution);
}
solution.isSolution=false;
}
 else {
solution.isSolution=true;
solution.dragViewX=result[0];
solution.dragViewY=result[1];
solution.dragViewSpanX=spanX;
solution.dragViewSpanY=spanY;
}
return solution;
}
private void copyCurrentStateToSolution(ItemConfiguration solution,boolean temp){
int childCount=mShortcutsAndWidgets.getChildCount();
for (int i=0; i < childCount; i++) {
View child=mShortcutsAndWidgets.getChildAt(i);
LayoutParams lp=(LayoutParams)child.getLayoutParams();
CellAndSpan c;
if (temp) {
c=new CellAndSpan(lp.tmpCellX,lp.tmpCellY,lp.cellHSpan,lp.cellVSpan);
}
 else {
c=new CellAndSpan(lp.cellX,lp.cellY,lp.cellHSpan,lp.cellVSpan);
}
solution.add(child,c);
}
}
private void copySolutionToTempState(ItemConfiguration solution,View dragView){
for (int i=0; i < mCountX; i++) {
for (int j=0; j < mCountY; j++) {
mTmpOccupied[i][j]=false;
}
}
int childCount=mShortcutsAndWidgets.getChildCount();
for (int i=0; i < childCount; i++) {
View child=mShortcutsAndWidgets.getChildAt(i);
if (child == dragView) continue;
LayoutParams lp=(LayoutParams)child.getLayoutParams();
CellAndSpan c=solution.map.get(child);
if (c != null) {
lp.tmpCellX=c.x;
lp.tmpCellY=c.y;
lp.cellHSpan=c.spanX;
lp.cellVSpan=c.spanY;
markCellsForView(c.x,c.y,c.spanX,c.spanY,mTmpOccupied,true);
}
}
markCellsForView(solution.dragViewX,solution.dragViewY,solution.dragViewSpanX,solution.dragViewSpanY,mTmpOccupied,true);
}
private void animateItemsToSolution(ItemConfiguration solution,View dragView,boolean commitDragView){
boolean[][] occupied=DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
for (int i=0; i < mCountX; i++) {
for (int j=0; j < mCountY; j++) {
occupied[i][j]=false;
}
}
int childCount=mShortcutsAndWidgets.getChildCount();
for (int i=0; i < childCount; i++) {
View child=mShortcutsAndWidgets.getChildAt(i);
if (child == dragView) continue;
CellAndSpan c=solution.map.get(child);
if (c != null) {
animateChildToPosition(child,c.x,c.y,REORDER_ANIMATION_DURATION,0,DESTRUCTIVE_REORDER,false);
markCellsForView(c.x,c.y,c.spanX,c.spanY,occupied,true);
}
}
if (commitDragView) {
markCellsForView(solution.dragViewX,solution.dragViewY,solution.dragViewSpanX,solution.dragViewSpanY,occupied,true);
}
}
private void beginOrAdjustReorderPreviewAnimations(ItemConfiguration solution,View dragView,int delay,int mode){
int childCount=mShortcutsAndWidgets.getChildCount();
for (int i=0; i < childCount; i++) {
View child=mShortcutsAndWidgets.getChildAt(i);
if (child == dragView) continue;
CellAndSpan c=solution.map.get(child);
boolean skip=mode == ReorderPreviewAnimation.MODE_HINT && solution.intersectingViews != null && !solution.intersectingViews.contains(child);
LayoutParams lp=(LayoutParams)child.getLayoutParams();
if (c != null && !skip) {
ReorderPreviewAnimation rha=new ReorderPreviewAnimation(child,mode,lp.cellX,lp.cellY,c.x,c.y,c.spanX,c.spanY);
rha.animate();
}
}
}
class ReorderPreviewAnimation {
View child;
float finalDeltaX;
float finalDeltaY;
float initDeltaX;
float initDeltaY;
float finalScale;
float initScale;
int mode;
boolean repeating=false;
private static final int PREVIEW_DURATION=300;
private static final int HINT_DURATION=Workspace.REORDER_TIMEOUT;
public static final int MODE_HINT=0;
public static final int MODE_PREVIEW=1;
Animator a;
public ReorderPreviewAnimation(View child,int mode,int cellX0,int cellY0,int cellX1,int cellY1,int spanX,int spanY){
regionToCenterPoint(cellX0,cellY0,spanX,spanY,mTmpPoint);
final int x0=mTmpPoint[0];
final int y0=mTmpPoint[1];
regionToCenterPoint(cellX1,cellY1,spanX,spanY,mTmpPoint);
final int x1=mTmpPoint[0];
final int y1=mTmpPoint[1];
final int dX=x1 - x0;
final int dY=y1 - y0;
finalDeltaX=0;
finalDeltaY=0;
int dir=mode == MODE_HINT ? -1 : 1;
if (dX == dY && dX == 0) {
}
 else {
if (dY == 0) {
finalDeltaX=-dir * Math.signum(dX) * mReorderPreviewAnimationMagnitude;
}
 else if (dX == 0) {
finalDeltaY=-dir * Math.signum(dY) * mReorderPreviewAnimationMagnitude;
}
 else {
double angle=Math.atan((float)(dY) / dX);
finalDeltaX=(int)(-dir * Math.signum(dX) * Math.abs(Math.cos(angle) * mReorderPreviewAnimationMagnitude));
finalDeltaY=(int)(-dir * Math.signum(dY) * Math.abs(Math.sin(angle) * mReorderPreviewAnimationMagnitude));
}
}
this.mode=mode;
initDeltaX=child.getTranslationX();
initDeltaY=child.getTranslationY();
finalScale=getChildrenScale() - 4.0f / child.getWidth();
initScale=child.getScaleX();
this.child=child;
}
void animate(){
if (mShakeAnimators.containsKey(child)) {
ReorderPreviewAnimation oldAnimation=mShakeAnimators.get(child);
oldAnimation.cancel();
mShakeAnimators.remove(child);
if (finalDeltaX == 0 && finalDeltaY == 0) {
completeAnimationImmediately();
return;
}
}
if (finalDeltaX == 0 && finalDeltaY == 0) {
return;
}
ValueAnimator va=LauncherAnimUtils.ofFloat(child,0f,1f);
a=va;
va.setRepeatMode(ValueAnimator.REVERSE);
va.setRepeatCount(ValueAnimator.INFINITE);
va.setDuration(mode == MODE_HINT ? HINT_DURATION : PREVIEW_DURATION);
va.setStartDelay((int)(Math.random() * 60));
va.addUpdateListener(new AnimatorUpdateListener(){
@Override public void onAnimationUpdate(ValueAnimator animation){
float r=((Float)animation.getAnimatedValue()).floatValue();
float r1=(mode == MODE_HINT && repeating) ? 1.0f : r;
float x=r1 * finalDeltaX + (1 - r1) * initDeltaX;
float y=r1 * finalDeltaY + (1 - r1) * initDeltaY;
child.setTranslationX(x);
child.setTranslationY(y);
float s=r * finalScale + (1 - r) * initScale;
child.setScaleX(s);
child.setScaleY(s);
}
}
);
va.addListener(new AnimatorListenerAdapter(){
public void onAnimationRepeat(Animator animation){
initDeltaX=0;
initDeltaY=0;
initScale=getChildrenScale();
repeating=true;
}
}
);
mShakeAnimators.put(child,this);
va.start();
}
private void cancel(){
if (a != null) {
a.cancel();
}
}
private void completeAnimationImmediately(){
if (a != null) {
a.cancel();
}
AnimatorSet s=LauncherAnimUtils.createAnimatorSet();
a=s;
s.playTogether(LauncherAnimUtils.ofFloat(child,"scaleX",getChildrenScale()),LauncherAnimUtils.ofFloat(child,"scaleY",getChildrenScale()),LauncherAnimUtils.ofFloat(child,"translationX",0f),LauncherAnimUtils.ofFloat(child,"translationY",0f));
s.setDuration(REORDER_ANIMATION_DURATION);
s.setInterpolator(new android.view.animation.DecelerateInterpolator(1.5f));
s.start();
}
}
private void completeAndClearReorderPreviewAnimations(){
for (ReorderPreviewAnimation a : mShakeAnimators.values()) {
a.completeAnimationImmediately();
}
mShakeAnimators.clear();
}
private void commitTempPlacement(){
for (int i=0; i < mCountX; i++) {
for (int j=0; j < mCountY; j++) {
mOccupied[i][j]=mTmpOccupied[i][j];
}
}
int childCount=mShortcutsAndWidgets.getChildCount();
for (int i=0; i < childCount; i++) {
View child=mShortcutsAndWidgets.getChildAt(i);
LayoutParams lp=(LayoutParams)child.getLayoutParams();
ItemInfo info=(ItemInfo)child.getTag();
if (info != null) {
if (info.cellX != lp.tmpCellX || info.cellY != lp.tmpCellY || info.spanX != lp.cellHSpan || info.spanY != lp.cellVSpan) {
info.requiresDbUpdate=true;
}
info.cellX=lp.cellX=lp.tmpCellX;
info.cellY=lp.cellY=lp.tmpCellY;
info.spanX=lp.cellHSpan;
info.spanY=lp.cellVSpan;
}
}
mLauncher.getWorkspace().updateItemLocationsInDatabase(this);
}
public void setUseTempCoords(boolean useTempCoords){
int childCount=mShortcutsAndWidgets.getChildCount();
for (int i=0; i < childCount; i++) {
LayoutParams lp=(LayoutParams)mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
lp.useTmpCoords=useTempCoords;
}
}
ItemConfiguration findConfigurationNoShuffle(int pixelX,int pixelY,int minSpanX,int minSpanY,int spanX,int spanY,View dragView,ItemConfiguration solution){
int[] result=new int[2];
int[] resultSpan=new int[2];
findNearestVacantArea(pixelX,pixelY,minSpanX,minSpanY,spanX,spanY,null,result,resultSpan);
if (result[0] >= 0 && result[1] >= 0) {
copyCurrentStateToSolution(solution,false);
solution.dragViewX=result[0];
solution.dragViewY=result[1];
solution.dragViewSpanX=resultSpan[0];
solution.dragViewSpanY=resultSpan[1];
solution.isSolution=true;
}
 else {
solution.isSolution=false;
}
return solution;
}
public void prepareChildForDrag(View child){
markCellsAsUnoccupiedForView(child);
}
private void getDirectionVectorForDrop(int dragViewCenterX,int dragViewCenterY,int spanX,int spanY,View dragView,int[] resultDirection){
int[] targetDestination=new int[2];
findNearestArea(dragViewCenterX,dragViewCenterY,spanX,spanY,targetDestination);
Rect dragRect=new Rect();
regionToRect(targetDestination[0],targetDestination[1],spanX,spanY,dragRect);
dragRect.offset(dragViewCenterX - dragRect.centerX(),dragViewCenterY - dragRect.centerY());
Rect dropRegionRect=new Rect();
getViewsIntersectingRegion(targetDestination[0],targetDestination[1],spanX,spanY,dragView,dropRegionRect,mIntersectingViews);
int dropRegionSpanX=dropRegionRect.width();
int dropRegionSpanY=dropRegionRect.height();
regionToRect(dropRegionRect.left,dropRegionRect.top,dropRegionRect.width(),dropRegionRect.height(),dropRegionRect);
int deltaX=(dropRegionRect.centerX() - dragViewCenterX) / spanX;
int deltaY=(dropRegionRect.centerY() - dragViewCenterY) / spanY;
if (dropRegionSpanX == mCountX || spanX == mCountX) {
deltaX=0;
}
if (dropRegionSpanY == mCountY || spanY == mCountY) {
deltaY=0;
}
if (deltaX == 0 && deltaY == 0) {
resultDirection[0]=1;
resultDirection[1]=0;
}
 else {
computeDirectionVector(deltaX,deltaY,resultDirection);
}
}
private void getViewsIntersectingRegion(int cellX,int cellY,int spanX,int spanY,View dragView,Rect boundingRect,ArrayList<View> intersectingViews){
if (boundingRect != null) {
boundingRect.set(cellX,cellY,cellX + spanX,cellY + spanY);
}
intersectingViews.clear();
Rect r0=new Rect(cellX,cellY,cellX + spanX,cellY + spanY);
Rect r1=new Rect();
final int count=mShortcutsAndWidgets.getChildCount();
for (int i=0; i < count; i++) {
View child=mShortcutsAndWidgets.getChildAt(i);
if (child == dragView) continue;
LayoutParams lp=(LayoutParams)child.getLayoutParams();
r1.set(lp.cellX,lp.cellY,lp.cellX + lp.cellHSpan,lp.cellY + lp.cellVSpan);
if (Rect.intersects(r0,r1)) {
mIntersectingViews.add(child);
if (boundingRect != null) {
boundingRect.union(r1);
}
}
}
}
boolean isNearestDropLocationOccupied(int pixelX,int pixelY,int spanX,int spanY,View dragView,int[] result){
result=findNearestArea(pixelX,pixelY,spanX,spanY,result);
getViewsIntersectingRegion(result[0],result[1],spanX,spanY,dragView,null,mIntersectingViews);
return !mIntersectingViews.isEmpty();
}
void revertTempState(){
completeAndClearReorderPreviewAnimations();
if (isItemPlacementDirty() && !DESTRUCTIVE_REORDER) {
final int count=mShortcutsAndWidgets.getChildCount();
for (int i=0; i < count; i++) {
View child=mShortcutsAndWidgets.getChildAt(i);
LayoutParams lp=(LayoutParams)child.getLayoutParams();
if (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.cellY) {
lp.tmpCellX=lp.cellX;
lp.tmpCellY=lp.cellY;
animateChildToPosition(child,lp.cellX,lp.cellY,REORDER_ANIMATION_DURATION,0,false,false);
}
}
setItemPlacementDirty(false);
}
}
boolean createAreaForResize(int cellX,int cellY,int spanX,int spanY,View dragView,int[] direction,boolean commit){
int[] pixelXY=new int[2];
regionToCenterPoint(cellX,cellY,spanX,spanY,pixelXY);
ItemConfiguration swapSolution=findReorderSolution(pixelXY[0],pixelXY[1],spanX,spanY,spanX,spanY,direction,dragView,true,new ItemConfiguration());
setUseTempCoords(true);
if (swapSolution != null && swapSolution.isSolution) {
copySolutionToTempState(swapSolution,dragView);
setItemPlacementDirty(true);
animateItemsToSolution(swapSolution,dragView,commit);
if (commit) {
commitTempPlacement();
completeAndClearReorderPreviewAnimations();
setItemPlacementDirty(false);
}
 else {
beginOrAdjustReorderPreviewAnimations(swapSolution,dragView,REORDER_ANIMATION_DURATION,ReorderPreviewAnimation.MODE_PREVIEW);
}
mShortcutsAndWidgets.requestLayout();
}
return swapSolution.isSolution;
}
int[] performReorder(int pixelX,int pixelY,int minSpanX,int minSpanY,int spanX,int spanY,View dragView,int[] result,int resultSpan[],int mode){
result=findNearestArea(pixelX,pixelY,spanX,spanY,result);
if (resultSpan == null) {
resultSpan=new int[2];
}
if ((mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL || mode == MODE_ACCEPT_DROP) && mPreviousReorderDirection[0] != INVALID_DIRECTION) {
mDirectionVector[0]=mPreviousReorderDirection[0];
mDirectionVector[1]=mPreviousReorderDirection[1];
if (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
mPreviousReorderDirection[0]=INVALID_DIRECTION;
mPreviousReorderDirection[1]=INVALID_DIRECTION;
}
}
 else {
getDirectionVectorForDrop(pixelX,pixelY,spanX,spanY,dragView,mDirectionVector);
mPreviousReorderDirection[0]=mDirectionVector[0];
mPreviousReorderDirection[1]=mDirectionVector[1];
}
ItemConfiguration swapSolution=findReorderSolution(pixelX,pixelY,minSpanX,minSpanY,spanX,spanY,mDirectionVector,dragView,true,new ItemConfiguration());
ItemConfiguration noShuffleSolution=findConfigurationNoShuffle(pixelX,pixelY,minSpanX,minSpanY,spanX,spanY,dragView,new ItemConfiguration());
ItemConfiguration finalSolution=null;
if (swapSolution.isSolution && swapSolution.area() >= noShuffleSolution.area()) {
finalSolution=swapSolution;
}
 else if (noShuffleSolution.isSolution) {
finalSolution=noShuffleSolution;
}
if (mode == MODE_SHOW_REORDER_HINT) {
beginOrAdjustReorderPreviewAnimations(finalSolution,dragView,0,ReorderPreviewAnimation.MODE_HINT);
if (finalSolution != null) {
result[0]=finalSolution.dragViewX;
result[1]=finalSolution.dragViewY;
resultSpan[0]=finalSolution.dragViewSpanX;
resultSpan[1]=finalSolution.dragViewSpanY;
}
 else {
result[0]=result[1]=resultSpan[0]=resultSpan[1]=-1;
}
return result;
}
boolean foundSolution=true;
if (!DESTRUCTIVE_REORDER) {
setUseTempCoords(true);
}
if (finalSolution != null) {
result[0]=finalSolution.dragViewX;
result[1]=finalSolution.dragViewY;
resultSpan[0]=finalSolution.dragViewSpanX;
resultSpan[1]=finalSolution.dragViewSpanY;
if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
if (!DESTRUCTIVE_REORDER) {
copySolutionToTempState(finalSolution,dragView);
}
setItemPlacementDirty(true);
animateItemsToSolution(finalSolution,dragView,mode == MODE_ON_DROP);
if (!DESTRUCTIVE_REORDER && (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL)) {
commitTempPlacement();
completeAndClearReorderPreviewAnimations();
setItemPlacementDirty(false);
}
 else {
beginOrAdjustReorderPreviewAnimations(finalSolution,dragView,REORDER_ANIMATION_DURATION,ReorderPreviewAnimation.MODE_PREVIEW);
}
}
}
 else {
foundSolution=false;
result[0]=result[1]=resultSpan[0]=resultSpan[1]=-1;
}
if ((mode == MODE_ON_DROP || !foundSolution) && !DESTRUCTIVE_REORDER) {
setUseTempCoords(false);
}
mShortcutsAndWidgets.requestLayout();
return result;
}
void setItemPlacementDirty(boolean dirty){
mItemPlacementDirty=dirty;
}
boolean isItemPlacementDirty(){
return mItemPlacementDirty;
}
private class ItemConfiguration {
HashMap<View,CellAndSpan> map=new HashMap<View,CellAndSpan>();
private HashMap<View,CellAndSpan> savedMap=new HashMap<View,CellAndSpan>();
ArrayList<View> sortedViews=new ArrayList<View>();
ArrayList<View> intersectingViews;
boolean isSolution=false;
int dragViewX, dragViewY, dragViewSpanX, dragViewSpanY;
void save(){
for (View v : map.keySet()) {
map.get(v).copy(savedMap.get(v));
}
}
void restore(){
for (View v : savedMap.keySet()) {
savedMap.get(v).copy(map.get(v));
}
}
void add(View v,CellAndSpan cs){
map.put(v,cs);
savedMap.put(v,new CellAndSpan());
sortedViews.add(v);
}
int area(){
return dragViewSpanX * dragViewSpanY;
}
}
private class CellAndSpan {
int x, y;
int spanX, spanY;
public CellAndSpan(){
}
public void copy(CellAndSpan copy){
copy.x=x;
copy.y=y;
copy.spanX=spanX;
copy.spanY=spanY;
}
public CellAndSpan(int x,int y,int spanX,int spanY){
this.x=x;
this.y=y;
this.spanX=spanX;
this.spanY=spanY;
}
public String toString(){
return "(" + x + ", "+ y+ ": "+ spanX+ ", "+ spanY+ ")";
}
}
int[] findNearestVacantArea(int pixelX,int pixelY,int spanX,int spanY,View ignoreView,int[] result){
return findNearestArea(pixelX,pixelY,spanX,spanY,ignoreView,true,result);
}
int[] findNearestVacantArea(int pixelX,int pixelY,int minSpanX,int minSpanY,int spanX,int spanY,View ignoreView,int[] result,int[] resultSpan){
return findNearestArea(pixelX,pixelY,minSpanX,minSpanY,spanX,spanY,ignoreView,true,result,resultSpan,mOccupied);
}
int[] findNearestArea(int pixelX,int pixelY,int spanX,int spanY,int[] result){
return findNearestArea(pixelX,pixelY,spanX,spanY,null,false,result);
}
boolean existsEmptyCell(){
return findCellForSpan(null,1,1);
}
boolean findCellForSpan(int[] cellXY,int spanX,int spanY){
return findCellForSpanThatIntersectsIgnoring(cellXY,spanX,spanY,-1,-1,null,mOccupied);
}
boolean findCellForSpanIgnoring(int[] cellXY,int spanX,int spanY,View ignoreView){
return findCellForSpanThatIntersectsIgnoring(cellXY,spanX,spanY,-1,-1,ignoreView,mOccupied);
}
boolean findCellForSpanThatIntersects(int[] cellXY,int spanX,int spanY,int intersectX,int intersectY){
return findCellForSpanThatIntersectsIgnoring(cellXY,spanX,spanY,intersectX,intersectY,null,mOccupied);
}
boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY,int spanX,int spanY,int intersectX,int intersectY,View ignoreView,boolean occupied[][]){
markCellsAsUnoccupiedForView(ignoreView,occupied);
boolean foundCell=false;
while (true) {
int startX=0;
if (intersectX >= 0) {
startX=Math.max(startX,intersectX - (spanX - 1));
}
int endX=mCountX - (spanX - 1);
if (intersectX >= 0) {
endX=Math.min(endX,intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
}
int startY=0;
if (intersectY >= 0) {
startY=Math.max(startY,intersectY - (spanY - 1));
}
int endY=mCountY - (spanY - 1);
if (intersectY >= 0) {
endY=Math.min(endY,intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
}
for (int y=startY; y < endY && !foundCell; y++) {
inner: for (int x=startX; x < endX; x++) {
for (int i=0; i < spanX; i++) {
for (int j=0; j < spanY; j++) {
if (occupied[x + i][y + j]) {
x+=i;
continue inner;
}
}
}
if (cellXY != null) {
cellXY[0]=x;
cellXY[1]=y;
}
foundCell=true;
break;
}
}
if (intersectX == -1 && intersectY == -1) {
break;
}
 else {
intersectX=-1;
intersectY=-1;
continue;
}
}
markCellsAsOccupiedForView(ignoreView,occupied);
return foundCell;
}
void onDragEnter(){
mDragEnforcer.onDragEnter();
mDragging=true;
}
void onDragExit(){
mDragEnforcer.onDragExit();
if (mDragging) {
mDragging=false;
}
mDragCell[0]=mDragCell[1]=-1;
mDragOutlineAnims[mDragOutlineCurrent].animateOut();
mDragOutlineCurrent=(mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
revertTempState();
setIsDragOverlapping(false);
}
void onDropChild(View child){
if (child != null) {
LayoutParams lp=(LayoutParams)child.getLayoutParams();
lp.dropped=true;
child.requestLayout();
}
}
public void cellToRect(int cellX,int cellY,int cellHSpan,int cellVSpan,Rect resultRect){
final int cellWidth=mCellWidth;
final int cellHeight=mCellHeight;
final int widthGap=mWidthGap;
final int heightGap=mHeightGap;
final int hStartPadding=getPaddingLeft();
final int vStartPadding=getPaddingTop();
int width=cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
int height=cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
int x=hStartPadding + cellX * (cellWidth + widthGap);
int y=vStartPadding + cellY * (cellHeight + heightGap);
resultRect.set(x,y,x + width,y + height);
}
public static int[] rectToCell(int width,int height,int[] result){
LauncherAppState app=LauncherAppState.getInstance();
DeviceProfile grid=app.getDynamicGrid().getDeviceProfile();
Rect padding=grid.getWorkspacePadding(grid.isLandscape ? CellLayout.LANDSCAPE : CellLayout.PORTRAIT);
int parentWidth=grid.calculateCellWidth(grid.widthPx - padding.left - padding.right,(int)grid.numColumns);
int parentHeight=grid.calculateCellHeight(grid.heightPx - padding.top - padding.bottom,(int)grid.numRows);
int smallerSize=Math.min(parentWidth,parentHeight);
int spanX=(int)Math.ceil(width / (float)smallerSize);
int spanY=(int)Math.ceil(height / (float)smallerSize);
if (result == null) {
return new int[]{spanX,spanY};
}
result[0]=spanX;
result[1]=spanY;
return result;
}
public int[] cellSpansToSize(int hSpans,int vSpans){
int[] size=new int[2];
size[0]=hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
size[1]=vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
return size;
}
public void calculateSpans(ItemInfo info){
final int minWidth;
final int minHeight;
if (info instanceof LauncherAppWidgetInfo) {
minWidth=((LauncherAppWidgetInfo)info).minWidth;
minHeight=((LauncherAppWidgetInfo)info).minHeight;
}
 else if (info instanceof PendingAddWidgetInfo) {
minWidth=((PendingAddWidgetInfo)info).minWidth;
minHeight=((PendingAddWidgetInfo)info).minHeight;
}
 else {
info.spanX=info.spanY=1;
return;
}
int[] spans=rectToCell(minWidth,minHeight,null);
info.spanX=spans[0];
info.spanY=spans[1];
}
public boolean getVacantCell(int[] vacant,int spanX,int spanY){
return findVacantCell(vacant,spanX,spanY,mCountX,mCountY,mOccupied);
}
static boolean findVacantCell(int[] vacant,int spanX,int spanY,int xCount,int yCount,boolean[][] occupied){
for (int y=0; y < yCount; y++) {
for (int x=0; x < xCount; x++) {
boolean available=!occupied[x][y];
out: for (int i=x; i < x + spanX - 1 && x < xCount; i++) {
for (int j=y; j < y + spanY - 1 && y < yCount; j++) {
available=available && !occupied[i][j];
if (!available) break out;
}
}
if (available) {
vacant[0]=x;
vacant[1]=y;
return true;
}
}
}
return false;
}
private void clearOccupiedCells(){
for (int x=0; x < mCountX; x++) {
for (int y=0; y < mCountY; y++) {
mOccupied[x][y]=false;
}
}
}
public void onMove(View view,int newCellX,int newCellY,int newSpanX,int newSpanY){
markCellsAsUnoccupiedForView(view);
markCellsForView(newCellX,newCellY,newSpanX,newSpanY,mOccupied,true);
}
public void markCellsAsOccupiedForView(View view){
markCellsAsOccupiedForView(view,mOccupied);
}
public void markCellsAsOccupiedForView(View view,boolean[][] occupied){
if (view == null || view.getParent() != mShortcutsAndWidgets) return;
LayoutParams lp=(LayoutParams)view.getLayoutParams();
markCellsForView(lp.cellX,lp.cellY,lp.cellHSpan,lp.cellVSpan,occupied,true);
}
public void markCellsAsUnoccupiedForView(View view){
markCellsAsUnoccupiedForView(view,mOccupied);
}
public void markCellsAsUnoccupiedForView(View view,boolean occupied[][]){
if (view == null || view.getParent() != mShortcutsAndWidgets) return;
LayoutParams lp=(LayoutParams)view.getLayoutParams();
markCellsForView(lp.cellX,lp.cellY,lp.cellHSpan,lp.cellVSpan,occupied,false);
}
private void markCellsForView(int cellX,int cellY,int spanX,int spanY,boolean[][] occupied,boolean value){
if (cellX < 0 || cellY < 0) return;
for (int x=cellX; x < cellX + spanX && x < mCountX; x++) {
for (int y=cellY; y < cellY + spanY && y < mCountY; y++) {
occupied[x][y]=value;
}
}
}
public int getDesiredWidth(){
return getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth)+ (Math.max((mCountX - 1),0) * mWidthGap);
}
public int getDesiredHeight(){
return getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight)+ (Math.max((mCountY - 1),0) * mHeightGap);
}
public boolean isOccupied(int x,int y){
if (x < mCountX && y < mCountY) {
return mOccupied[x][y];
}
 else {
throw new RuntimeException("Position exceeds the bound of this CellLayout");
}
}
@Override public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs){
return new CellLayout.LayoutParams(getContext(),attrs);
}
@Override protected boolean checkLayoutParams(ViewGroup.LayoutParams p){
return p instanceof CellLayout.LayoutParams;
}
@Override protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p){
return new CellLayout.LayoutParams(p);
}
public static class CellLayoutAnimationController extends LayoutAnimationController {
public CellLayoutAnimationController(Animation animation,float delay){
super(animation,delay);
}
@Override protected long getDelayForView(View view){
return (int)(Math.random() * 150);
}
}
public static class LayoutParams extends ViewGroup.MarginLayoutParams {
@ViewDebug.ExportedProperty public int cellX;
@ViewDebug.ExportedProperty public int cellY;
public int tmpCellX;
public int tmpCellY;
public boolean useTmpCoords;
@ViewDebug.ExportedProperty public int cellHSpan;
@ViewDebug.ExportedProperty public int cellVSpan;
public boolean isLockedToGrid=true;
public boolean isFullscreen=false;
public boolean canReorder=true;
@ViewDebug.ExportedProperty int x;
@ViewDebug.ExportedProperty int y;
boolean dropped;
public LayoutParams(Context c,AttributeSet attrs){
super(c,attrs);
cellHSpan=1;
cellVSpan=1;
}
public LayoutParams(ViewGroup.LayoutParams source){
super(source);
cellHSpan=1;
cellVSpan=1;
}
public LayoutParams(LayoutParams source){
super(source);
this.cellX=source.cellX;
this.cellY=source.cellY;
this.cellHSpan=source.cellHSpan;
this.cellVSpan=source.cellVSpan;
}
public LayoutParams(int cellX,int cellY,int cellHSpan,int cellVSpan){
super(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT);
this.cellX=cellX;
this.cellY=cellY;
this.cellHSpan=cellHSpan;
this.cellVSpan=cellVSpan;
}
public void setup(int cellWidth,int cellHeight,int widthGap,int heightGap,boolean invertHorizontally,int colCount){
if (isLockedToGrid) {
final int myCellHSpan=cellHSpan;
final int myCellVSpan=cellVSpan;
int myCellX=useTmpCoords ? tmpCellX : cellX;
int myCellY=useTmpCoords ? tmpCellY : cellY;
if (invertHorizontally) {
myCellX=colCount - myCellX - cellHSpan;
}
width=myCellHSpan * cellWidth + ((myCellHSpan - 1) * widthGap) - leftMargin - rightMargin;
height=myCellVSpan * cellHeight + ((myCellVSpan - 1) * heightGap) - topMargin - bottomMargin;
x=(int)(myCellX * (cellWidth + widthGap) + leftMargin);
y=(int)(myCellY * (cellHeight + heightGap) + topMargin);
}
}
public String toString(){
return "(" + this.cellX + ", "+ this.cellY+ ")";
}
public void setWidth(int width){
this.width=width;
}
public int getWidth(){
return width;
}
public void setHeight(int height){
this.height=height;
}
public int getHeight(){
return height;
}
public void setX(int x){
this.x=x;
}
public int getX(){
return x;
}
public void setY(int y){
this.y=y;
}
public int getY(){
return y;
}
}
static final class CellInfo {
View cell;
int cellX=-1;
int cellY=-1;
int spanX;
int spanY;
long screenId;
long container;
@Override public String toString(){
return "Cell[view=" + (cell == null ? "null" : cell.getClass()) + ", x="+ cellX+ ", y="+ cellY+ "]";
}
}
public boolean lastDownOnOccupiedCell(){
return mLastDownOnOccupiedCell;
}
}
