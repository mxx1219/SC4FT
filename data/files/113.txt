package org.elasticsearch.snapshots;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import org.apache.lucene.util.CollectionUtil;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.ExceptionsHelper;
import org.elasticsearch.Version;
import org.elasticsearch.action.search.ShardSearchFailure;
import org.elasticsearch.action.support.IndicesOptions;
import org.elasticsearch.cluster.*;
import org.elasticsearch.cluster.metadata.*;
import org.elasticsearch.cluster.metadata.SnapshotMetaData.ShardSnapshotStatus;
import org.elasticsearch.cluster.metadata.SnapshotMetaData.State;
import org.elasticsearch.cluster.node.DiscoveryNode;
import org.elasticsearch.cluster.node.DiscoveryNodes;
import org.elasticsearch.cluster.routing.IndexRoutingTable;
import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
import org.elasticsearch.cluster.routing.RoutingTable;
import org.elasticsearch.cluster.routing.ShardRouting;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.component.AbstractLifecycleComponent;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.io.stream.StreamOutput;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.index.shard.ShardId;
import org.elasticsearch.index.snapshots.IndexShardRepository;
import org.elasticsearch.index.snapshots.IndexShardSnapshotAndRestoreService;
import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;
import org.elasticsearch.indices.IndicesService;
import org.elasticsearch.repositories.RepositoriesService;
import org.elasticsearch.repositories.Repository;
import org.elasticsearch.repositories.RepositoryMissingException;
import org.elasticsearch.search.SearchShardTarget;
import org.elasticsearch.threadpool.ThreadPool;
import org.elasticsearch.transport.*;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import com.google.common.collect.Lists.newArrayList;
import com.google.common.collect.Maps.newHashMap;
import com.google.common.collect.Sets.newHashSet;
public class SnapshotsService extends AbstractLifecycleComponent<SnapshotsService> implements ClusterStateListener {
  private final ClusterService clusterService;
  private final RepositoriesService repositoriesService;
  private final ThreadPool threadPool;
  private final IndicesService indicesService;
  private final TransportService transportService;
  private volatile ImmutableMap<SnapshotId,SnapshotShards> shardSnapshots=ImmutableMap.of();
  private final Lock shutdownLock=new ReentrantLock();
  private final Condition shutdownCondition=shutdownLock.newCondition();
  private final CopyOnWriteArrayList<SnapshotCompletionListener> snapshotCompletionListeners=new CopyOnWriteArrayList<>();
  @Inject public SnapshotsService(  Settings settings,  ClusterService clusterService,  RepositoriesService repositoriesService,  ThreadPool threadPool,  IndicesService indicesService,  TransportService transportService){
    super(settings);
    this.clusterService=clusterService;
    this.repositoriesService=repositoriesService;
    this.threadPool=threadPool;
    this.indicesService=indicesService;
    this.transportService=transportService;
    transportService.registerHandler(UpdateSnapshotStateRequestHandler.ACTION,new UpdateSnapshotStateRequestHandler());
    clusterService.addLast(this);
  }
  public Snapshot snapshot(  SnapshotId snapshotId){
    return repositoriesService.repository(snapshotId.getRepository()).readSnapshot(snapshotId);
  }
  public ImmutableList<Snapshot> snapshots(  String repositoryName){
    ArrayList<Snapshot> snapshotList=newArrayList();
    Repository repository=repositoriesService.repository(repositoryName);
    ImmutableList<SnapshotId> snapshotIds=repository.snapshots();
    for (    SnapshotId snapshotId : snapshotIds) {
      snapshotList.add(repository.readSnapshot(snapshotId));
    }
    CollectionUtil.timSort(snapshotList);
    return ImmutableList.copyOf(snapshotList);
  }
  public void createSnapshot(  final SnapshotRequest request,  final CreateSnapshotListener listener){
    final SnapshotId snapshotId=new SnapshotId(request.repository(),request.name());
    clusterService.submitStateUpdateTask(request.cause(),new TimeoutClusterStateUpdateTask(){
      private SnapshotMetaData.Entry newSnapshot=null;
      @Override public ClusterState execute(      ClusterState currentState){
        validate(request,currentState);
        MetaData metaData=currentState.metaData();
        MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
        SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
        if (snapshots == null || snapshots.entries().isEmpty()) {
          ImmutableList<String> indices=ImmutableList.copyOf(metaData.concreteIndices(request.indicesOptions(),request.indices()));
          logger.trace("[{}][{}] creating snapshot for indices [{}]",request.repository(),request.name(),indices);
          newSnapshot=new SnapshotMetaData.Entry(snapshotId,request.includeGlobalState(),State.INIT,indices,null);
          snapshots=new SnapshotMetaData(newSnapshot);
        }
 else {
          throw new ConcurrentSnapshotExecutionException(snapshotId,"a snapshot is already running");
        }
        mdBuilder.putCustom(SnapshotMetaData.TYPE,snapshots);
        return ClusterState.builder(currentState).metaData(mdBuilder).build();
      }
      @Override public void onFailure(      String source,      Throwable t){
        logger.warn("[{}][{}] failed to create snapshot",t,request.repository(),request.name());
        newSnapshot=null;
        listener.onFailure(t);
      }
      @Override public void clusterStateProcessed(      String source,      ClusterState oldState,      final ClusterState newState){
        if (newSnapshot != null) {
          threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new Runnable(){
            @Override public void run(){
              beginSnapshot(newState,newSnapshot,request.partial,listener);
            }
          }
);
        }
      }
      @Override public TimeValue timeout(){
        return request.masterNodeTimeout();
      }
    }
);
  }
  private void validate(  SnapshotRequest request,  ClusterState state) throws ElasticsearchException {
    RepositoriesMetaData repositoriesMetaData=state.getMetaData().custom(RepositoriesMetaData.TYPE);
    if (repositoriesMetaData == null || repositoriesMetaData.repository(request.repository()) == null) {
      throw new RepositoryMissingException(request.repository());
    }
    if (!Strings.hasLength(request.name())) {
      throw new InvalidSnapshotNameException(new SnapshotId(request.repository(),request.name()),"cannot be empty");
    }
    if (request.name().contains(" ")) {
      throw new InvalidSnapshotNameException(new SnapshotId(request.repository(),request.name()),"must not contain whitespace");
    }
    if (request.name().contains(",")) {
      throw new InvalidSnapshotNameException(new SnapshotId(request.repository(),request.name()),"must not contain ','");
    }
    if (request.name().contains("#")) {
      throw new InvalidSnapshotNameException(new SnapshotId(request.repository(),request.name()),"must not contain '#'");
    }
    if (request.name().charAt(0) == '_') {
      throw new InvalidSnapshotNameException(new SnapshotId(request.repository(),request.name()),"must not start with '_'");
    }
    if (!request.name().toLowerCase(Locale.ROOT).equals(request.name())) {
      throw new InvalidSnapshotNameException(new SnapshotId(request.repository(),request.name()),"must be lowercase");
    }
    if (!Strings.validFileName(request.name())) {
      throw new InvalidSnapshotNameException(new SnapshotId(request.repository(),request.name()),"must not contain the following characters " + Strings.INVALID_FILENAME_CHARS);
    }
  }
  private void beginSnapshot(  ClusterState clusterState,  final SnapshotMetaData.Entry snapshot,  final boolean partial,  final CreateSnapshotListener userCreateSnapshotListener){
    boolean snapshotCreated=false;
    try {
      Repository repository=repositoriesService.repository(snapshot.snapshotId().getRepository());
      MetaData metaData=clusterState.metaData();
      if (!snapshot.includeGlobalState()) {
        MetaData.Builder builder=MetaData.builder();
        for (        String index : snapshot.indices()) {
          builder.put(metaData.index(index),false);
        }
        metaData=builder.build();
      }
      repository.initializeSnapshot(snapshot.snapshotId(),snapshot.indices(),metaData);
      snapshotCreated=true;
      if (snapshot.indices().isEmpty()) {
        userCreateSnapshotListener.onResponse();
        endSnapshot(snapshot);
        return;
      }
      clusterService.submitStateUpdateTask("update_snapshot [" + snapshot + "]",new ProcessedClusterStateUpdateTask(){
        boolean accepted=false;
        SnapshotMetaData.Entry updatedSnapshot;
        String failure=null;
        @Override public ClusterState execute(        ClusterState currentState){
          MetaData metaData=currentState.metaData();
          MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
          SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
          ImmutableList.Builder<SnapshotMetaData.Entry> entries=ImmutableList.builder();
          for (          SnapshotMetaData.Entry entry : snapshots.entries()) {
            if (entry.snapshotId().equals(snapshot.snapshotId())) {
              ImmutableMap<ShardId,SnapshotMetaData.ShardSnapshotStatus> shards=shards(snapshot.snapshotId(),currentState,snapshot.indices());
              if (!partial) {
                Set<String> indicesWithMissingShards=indicesWithMissingShards(shards);
                if (indicesWithMissingShards != null) {
                  updatedSnapshot=new SnapshotMetaData.Entry(snapshot.snapshotId(),snapshot.includeGlobalState(),State.FAILED,snapshot.indices(),shards);
                  entries.add(updatedSnapshot);
                  failure="Indices don't have primary shards +[" + indicesWithMissingShards + "]";
                  continue;
                }
              }
              updatedSnapshot=new SnapshotMetaData.Entry(snapshot.snapshotId(),snapshot.includeGlobalState(),State.STARTED,snapshot.indices(),shards);
              entries.add(updatedSnapshot);
              if (!completed(shards.values())) {
                accepted=true;
              }
            }
 else {
              entries.add(entry);
            }
          }
          mdBuilder.putCustom(SnapshotMetaData.TYPE,new SnapshotMetaData(entries.build()));
          return ClusterState.builder(currentState).metaData(mdBuilder).build();
        }
        @Override public void onFailure(        String source,        Throwable t){
          logger.warn("[{}] failed to create snapshot",t,snapshot.snapshotId());
          userCreateSnapshotListener.onFailure(t);
        }
        @Override public void clusterStateProcessed(        String source,        ClusterState oldState,        ClusterState newState){
          userCreateSnapshotListener.onResponse();
          if (!accepted && updatedSnapshot != null) {
            endSnapshot(updatedSnapshot,failure);
          }
        }
      }
);
    }
 catch (    Throwable t) {
      logger.warn("failed to create snapshot [{}]",t,snapshot.snapshotId());
      clusterService.submitStateUpdateTask("fail_snapshot [" + snapshot.snapshotId() + "]",new ClusterStateUpdateTask(){
        @Override public ClusterState execute(        ClusterState currentState){
          MetaData metaData=currentState.metaData();
          MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
          SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
          ImmutableList.Builder<SnapshotMetaData.Entry> entries=ImmutableList.builder();
          for (          SnapshotMetaData.Entry entry : snapshots.entries()) {
            if (!entry.snapshotId().equals(snapshot.snapshotId())) {
              entries.add(entry);
            }
          }
          mdBuilder.putCustom(SnapshotMetaData.TYPE,new SnapshotMetaData(entries.build()));
          return ClusterState.builder(currentState).metaData(mdBuilder).build();
        }
        @Override public void onFailure(        String source,        Throwable t){
          logger.warn("[{}] failed to delete snapshot",t,snapshot.snapshotId());
        }
      }
);
      if (snapshotCreated) {
        try {
          repositoriesService.repository(snapshot.snapshotId().getRepository()).finalizeSnapshot(snapshot.snapshotId(),ExceptionsHelper.detailedMessage(t),0,ImmutableList.<SnapshotShardFailure>of());
        }
 catch (        Throwable t2) {
          logger.warn("[{}] failed to close snapshot in repository",snapshot.snapshotId());
        }
      }
      userCreateSnapshotListener.onFailure(t);
    }
  }
  public ImmutableList<SnapshotMetaData.Entry> currentSnapshots(  String repository,  String[] snapshots){
    MetaData metaData=clusterService.state().metaData();
    SnapshotMetaData snapshotMetaData=metaData.custom(SnapshotMetaData.TYPE);
    if (snapshotMetaData == null || snapshotMetaData.entries().isEmpty()) {
      return ImmutableList.of();
    }
    if ("_all".equals(repository)) {
      return snapshotMetaData.entries();
    }
    if (snapshotMetaData.entries().size() == 1) {
      SnapshotMetaData.Entry entry=snapshotMetaData.entries().get(0);
      if (!entry.snapshotId().getRepository().equals(repository)) {
        return ImmutableList.of();
      }
      if (snapshots != null && snapshots.length > 0) {
        for (        String snapshot : snapshots) {
          if (entry.snapshotId().getSnapshot().equals(snapshot)) {
            return snapshotMetaData.entries();
          }
        }
        return ImmutableList.of();
      }
 else {
        return snapshotMetaData.entries();
      }
    }
    ImmutableList.Builder<SnapshotMetaData.Entry> builder=ImmutableList.builder();
    for (    SnapshotMetaData.Entry entry : snapshotMetaData.entries()) {
      if (!entry.snapshotId().getRepository().equals(repository)) {
        continue;
      }
      if (snapshots != null && snapshots.length > 0) {
        for (        String snapshot : snapshots) {
          if (entry.snapshotId().getSnapshot().equals(snapshot)) {
            builder.add(entry);
            break;
          }
        }
      }
 else {
        builder.add(entry);
      }
    }
    return builder.build();
  }
  public ImmutableMap<ShardId,IndexShardSnapshotStatus> currentSnapshotShards(  SnapshotId snapshotId){
    SnapshotShards snapshotShards=shardSnapshots.get(snapshotId);
    if (snapshotShards == null) {
      return null;
    }
 else {
      return snapshotShards.shards;
    }
  }
  public ImmutableMap<ShardId,IndexShardSnapshotStatus> snapshotShards(  SnapshotId snapshotId){
    ImmutableMap.Builder<ShardId,IndexShardSnapshotStatus> shardStatusBuilder=ImmutableMap.builder();
    Repository repository=repositoriesService.repository(snapshotId.getRepository());
    IndexShardRepository indexShardRepository=repositoriesService.indexShardRepository(snapshotId.getRepository());
    Snapshot snapshot=repository.readSnapshot(snapshotId);
    MetaData metaData=repository.readSnapshotMetaData(snapshotId,snapshot.indices());
    for (    String index : snapshot.indices()) {
      IndexMetaData indexMetaData=metaData.indices().get(index);
      if (indexMetaData != null) {
        int numberOfShards=indexMetaData.getNumberOfShards();
        for (int i=0; i < numberOfShards; i++) {
          ShardId shardId=new ShardId(index,i);
          SnapshotShardFailure shardFailure=findShardFailure(snapshot.shardFailures(),shardId);
          if (shardFailure != null) {
            IndexShardSnapshotStatus shardSnapshotStatus=new IndexShardSnapshotStatus();
            shardSnapshotStatus.updateStage(IndexShardSnapshotStatus.Stage.FAILURE);
            shardSnapshotStatus.failure(shardFailure.reason());
            shardStatusBuilder.put(shardId,shardSnapshotStatus);
          }
 else {
            IndexShardSnapshotStatus shardSnapshotStatus=indexShardRepository.snapshotStatus(snapshotId,shardId);
            shardStatusBuilder.put(shardId,shardSnapshotStatus);
          }
        }
      }
    }
    return shardStatusBuilder.build();
  }
  private SnapshotShardFailure findShardFailure(  ImmutableList<SnapshotShardFailure> shardFailures,  ShardId shardId){
    for (    SnapshotShardFailure shardFailure : shardFailures) {
      if (shardId.getIndex().equals(shardFailure.index()) && shardId.getId() == shardFailure.shardId()) {
        return shardFailure;
      }
    }
    return null;
  }
  @Override public void clusterChanged(  ClusterChangedEvent event){
    try {
      if (event.localNodeMaster()) {
        if (event.nodesRemoved()) {
          processSnapshotsOnRemovedNodes(event);
        }
        if (event.routingTableChanged()) {
          processStartedShards(event);
        }
      }
      SnapshotMetaData prev=event.previousState().metaData().custom(SnapshotMetaData.TYPE);
      SnapshotMetaData curr=event.state().metaData().custom(SnapshotMetaData.TYPE);
      if (prev == null) {
        if (curr != null) {
          processIndexShardSnapshots(curr);
        }
      }
 else {
        if (!prev.equals(curr)) {
          processIndexShardSnapshots(curr);
        }
      }
    }
 catch (    Throwable t) {
      logger.warn("Failed to update snapshot state ",t);
    }
  }
  private void processSnapshotsOnRemovedNodes(  ClusterChangedEvent event){
    if (removedNodesCleanupNeeded(event)) {
      final boolean newMaster=!event.previousState().nodes().localNodeMaster();
      clusterService.submitStateUpdateTask("update snapshot state after node removal",new ClusterStateUpdateTask(){
        @Override public ClusterState execute(        ClusterState currentState) throws Exception {
          DiscoveryNodes nodes=currentState.nodes();
          MetaData metaData=currentState.metaData();
          MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
          SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
          if (snapshots == null) {
            return currentState;
          }
          boolean changed=false;
          ArrayList<SnapshotMetaData.Entry> entries=newArrayList();
          for (          final SnapshotMetaData.Entry snapshot : snapshots.entries()) {
            SnapshotMetaData.Entry updatedSnapshot=snapshot;
            boolean snapshotChanged=false;
            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {
              ImmutableMap.Builder<ShardId,ShardSnapshotStatus> shards=ImmutableMap.builder();
              for (              ImmutableMap.Entry<ShardId,ShardSnapshotStatus> shardEntry : snapshot.shards().entrySet()) {
                ShardSnapshotStatus shardStatus=shardEntry.getValue();
                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {
                  if (nodes.nodeExists(shardStatus.nodeId())) {
                    shards.put(shardEntry);
                  }
 else {
                    snapshotChanged=true;
                    logger.warn("failing snapshot of shard [{}] on closed node [{}]",shardEntry.getKey(),shardStatus.nodeId());
                    shards.put(shardEntry.getKey(),new ShardSnapshotStatus(shardStatus.nodeId(),State.FAILED,"node shutdown"));
                  }
                }
              }
              if (snapshotChanged) {
                changed=true;
                ImmutableMap<ShardId,ShardSnapshotStatus> shardsMap=shards.build();
                if (!snapshot.state().completed() && completed(shardsMap.values())) {
                  updatedSnapshot=new SnapshotMetaData.Entry(snapshot.snapshotId(),snapshot.includeGlobalState(),State.SUCCESS,snapshot.indices(),shardsMap);
                  endSnapshot(updatedSnapshot);
                }
 else {
                  updatedSnapshot=new SnapshotMetaData.Entry(snapshot.snapshotId(),snapshot.includeGlobalState(),snapshot.state(),snapshot.indices(),shardsMap);
                }
              }
              entries.add(updatedSnapshot);
            }
 else             if (snapshot.state() == State.INIT && newMaster) {
              deleteSnapshot(snapshot.snapshotId(),new DeleteSnapshotListener(){
                @Override public void onResponse(){
                  logger.debug("cleaned up abandoned snapshot {} in INIT state",snapshot.snapshotId());
                }
                @Override public void onFailure(                Throwable t){
                  logger.warn("failed to clean up abandoned snapshot {} in INIT state",snapshot.snapshotId());
                }
              }
);
            }
 else             if (snapshot.state() == State.SUCCESS && newMaster) {
              endSnapshot(snapshot);
            }
          }
          if (changed) {
            snapshots=new SnapshotMetaData(entries.toArray(new SnapshotMetaData.Entry[entries.size()]));
            mdBuilder.putCustom(SnapshotMetaData.TYPE,snapshots);
            return ClusterState.builder(currentState).metaData(mdBuilder).build();
          }
          return currentState;
        }
        @Override public void onFailure(        String source,        Throwable t){
          logger.warn("failed to update snapshot state after node removal");
        }
      }
);
    }
  }
  private void processStartedShards(  ClusterChangedEvent event){
    if (waitingShardsStartedOrUnassigned(event)) {
      clusterService.submitStateUpdateTask("update snapshot state after shards started",new ClusterStateUpdateTask(){
        @Override public ClusterState execute(        ClusterState currentState) throws Exception {
          MetaData metaData=currentState.metaData();
          RoutingTable routingTable=currentState.routingTable();
          MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
          SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
          if (snapshots != null) {
            boolean changed=false;
            ArrayList<SnapshotMetaData.Entry> entries=newArrayList();
            for (            final SnapshotMetaData.Entry snapshot : snapshots.entries()) {
              SnapshotMetaData.Entry updatedSnapshot=snapshot;
              if (snapshot.state() == State.STARTED) {
                ImmutableMap<ShardId,ShardSnapshotStatus> shards=processWaitingShards(snapshot.shards(),routingTable);
                if (shards != null) {
                  changed=true;
                  if (!snapshot.state().completed() && completed(shards.values())) {
                    updatedSnapshot=new SnapshotMetaData.Entry(snapshot.snapshotId(),snapshot.includeGlobalState(),State.SUCCESS,snapshot.indices(),shards);
                    endSnapshot(updatedSnapshot);
                  }
 else {
                    updatedSnapshot=new SnapshotMetaData.Entry(snapshot.snapshotId(),snapshot.includeGlobalState(),snapshot.state(),snapshot.indices(),shards);
                  }
                }
                entries.add(updatedSnapshot);
              }
            }
            if (changed) {
              snapshots=new SnapshotMetaData(entries.toArray(new SnapshotMetaData.Entry[entries.size()]));
              mdBuilder.putCustom(SnapshotMetaData.TYPE,snapshots);
              return ClusterState.builder(currentState).metaData(mdBuilder).build();
            }
          }
          return currentState;
        }
        @Override public void onFailure(        String source,        Throwable t){
          logger.warn("failed to update snapshot state after shards started from [{}] ",t,source);
        }
      }
);
    }
  }
  private ImmutableMap<ShardId,ShardSnapshotStatus> processWaitingShards(  ImmutableMap<ShardId,ShardSnapshotStatus> snapshotShards,  RoutingTable routingTable){
    boolean snapshotChanged=false;
    ImmutableMap.Builder<ShardId,ShardSnapshotStatus> shards=ImmutableMap.builder();
    for (    ImmutableMap.Entry<ShardId,ShardSnapshotStatus> shardEntry : snapshotShards.entrySet()) {
      ShardSnapshotStatus shardStatus=shardEntry.getValue();
      if (shardStatus.state() == State.WAITING) {
        ShardId shardId=shardEntry.getKey();
        IndexRoutingTable indexShardRoutingTable=routingTable.index(shardId.getIndex());
        if (indexShardRoutingTable != null) {
          IndexShardRoutingTable shardRouting=indexShardRoutingTable.shard(shardId.id());
          if (shardRouting != null && shardRouting.primaryShard() != null) {
            if (shardRouting.primaryShard().started()) {
              snapshotChanged=true;
              logger.trace("starting shard that we were waiting for [{}] on node [{}]",shardEntry.getKey(),shardStatus.nodeId());
              shards.put(shardEntry.getKey(),new ShardSnapshotStatus(shardRouting.primaryShard().currentNodeId()));
              continue;
            }
 else             if (shardRouting.primaryShard().initializing() || shardRouting.primaryShard().relocating()) {
              shards.put(shardEntry);
              continue;
            }
          }
        }
        snapshotChanged=true;
        logger.warn("failing snapshot of shard [{}] on unassigned shard [{}]",shardEntry.getKey(),shardStatus.nodeId());
        shards.put(shardEntry.getKey(),new ShardSnapshotStatus(shardStatus.nodeId(),State.FAILED,"shard is unassigned"));
      }
 else {
        shards.put(shardEntry);
      }
    }
    if (snapshotChanged) {
      return shards.build();
    }
 else {
      return null;
    }
  }
  private boolean waitingShardsStartedOrUnassigned(  ClusterChangedEvent event){
    SnapshotMetaData curr=event.state().metaData().custom(SnapshotMetaData.TYPE);
    if (curr != null) {
      for (      SnapshotMetaData.Entry entry : curr.entries()) {
        if (entry.state() == State.STARTED && !entry.waitingIndices().isEmpty()) {
          for (          String index : entry.waitingIndices().keySet()) {
            if (event.indexRoutingTableChanged(index)) {
              IndexRoutingTable indexShardRoutingTable=event.state().getRoutingTable().index(index);
              for (              ShardId shardId : entry.waitingIndices().get(index)) {
                ShardRouting shardRouting=indexShardRoutingTable.shard(shardId.id()).primaryShard();
                if (shardRouting != null && (shardRouting.started() || shardRouting.unassigned())) {
                  return true;
                }
              }
            }
          }
        }
      }
    }
    return false;
  }
  private boolean removedNodesCleanupNeeded(  ClusterChangedEvent event){
    boolean newMaster=!event.previousState().nodes().localNodeMaster();
    SnapshotMetaData snapshotMetaData=event.state().getMetaData().custom(SnapshotMetaData.TYPE);
    if (snapshotMetaData == null) {
      return false;
    }
    for (    SnapshotMetaData.Entry snapshot : snapshotMetaData.entries()) {
      if (newMaster && (snapshot.state() == State.SUCCESS || snapshot.state() == State.INIT)) {
        return true;
      }
      for (      DiscoveryNode node : event.nodesDelta().removedNodes()) {
        for (        ImmutableMap.Entry<ShardId,ShardSnapshotStatus> shardEntry : snapshot.shards().entrySet()) {
          ShardSnapshotStatus shardStatus=shardEntry.getValue();
          if (!shardStatus.state().completed() && node.getId().equals(shardStatus.nodeId())) {
            return true;
          }
        }
      }
    }
    return false;
  }
  private void processIndexShardSnapshots(  SnapshotMetaData snapshotMetaData){
    Map<SnapshotId,SnapshotShards> survivors=newHashMap();
    for (    Map.Entry<SnapshotId,SnapshotShards> entry : shardSnapshots.entrySet()) {
      if (snapshotMetaData != null && snapshotMetaData.snapshot(entry.getKey()) != null) {
        survivors.put(entry.getKey(),entry.getValue());
      }
    }
    Map<SnapshotId,Map<ShardId,IndexShardSnapshotStatus>> newSnapshots=newHashMap();
    final String localNodeId=clusterService.localNode().id();
    for (    SnapshotMetaData.Entry entry : snapshotMetaData.entries()) {
      if (entry.state() == State.STARTED) {
        Map<ShardId,IndexShardSnapshotStatus> startedShards=newHashMap();
        SnapshotShards snapshotShards=shardSnapshots.get(entry.snapshotId());
        for (        Map.Entry<ShardId,SnapshotMetaData.ShardSnapshotStatus> shard : entry.shards().entrySet()) {
          if (localNodeId.equals(shard.getValue().nodeId())) {
            if (shard.getValue().state() == State.INIT && (snapshotShards == null || !snapshotShards.shards.containsKey(shard.getKey()))) {
              logger.trace("[{}] - Adding shard to the queue",shard.getKey());
              startedShards.put(shard.getKey(),new IndexShardSnapshotStatus());
            }
          }
        }
        if (!startedShards.isEmpty()) {
          newSnapshots.put(entry.snapshotId(),startedShards);
          if (snapshotShards != null) {
            ImmutableMap.Builder<ShardId,IndexShardSnapshotStatus> shards=ImmutableMap.builder();
            shards.putAll(snapshotShards.shards);
            shards.putAll(startedShards);
            survivors.put(entry.snapshotId(),new SnapshotShards(shards.build()));
          }
 else {
            survivors.put(entry.snapshotId(),new SnapshotShards(ImmutableMap.copyOf(startedShards)));
          }
        }
      }
 else       if (entry.state() == State.ABORTED) {
        SnapshotShards snapshotShards=shardSnapshots.get(entry.snapshotId());
        if (snapshotShards != null) {
          for (          Map.Entry<ShardId,SnapshotMetaData.ShardSnapshotStatus> shard : entry.shards().entrySet()) {
            IndexShardSnapshotStatus snapshotStatus=snapshotShards.shards.get(shard.getKey());
            if (snapshotStatus != null) {
              snapshotStatus.abort();
            }
          }
        }
      }
    }
    shutdownLock.lock();
    try {
      shardSnapshots=ImmutableMap.copyOf(survivors);
      if (shardSnapshots.isEmpty()) {
        shutdownCondition.signalAll();
      }
    }
  finally {
      shutdownLock.unlock();
    }
    if (!newSnapshots.isEmpty()) {
      for (      final Map.Entry<SnapshotId,Map<ShardId,IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {
        for (        final Map.Entry<ShardId,IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {
          try {
            final IndexShardSnapshotAndRestoreService shardSnapshotService=indicesService.indexServiceSafe(shardEntry.getKey().getIndex()).shardInjectorSafe(shardEntry.getKey().id()).getInstance(IndexShardSnapshotAndRestoreService.class);
            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new Runnable(){
              @Override public void run(){
                try {
                  shardSnapshotService.snapshot(entry.getKey(),shardEntry.getValue());
                  updateIndexShardSnapshotStatus(new UpdateIndexShardSnapshotStatusRequest(entry.getKey(),shardEntry.getKey(),new ShardSnapshotStatus(localNodeId,SnapshotMetaData.State.SUCCESS)));
                }
 catch (                Throwable t) {
                  logger.warn("[{}] [{}] failed to create snapshot",t,shardEntry.getKey(),entry.getKey());
                  updateIndexShardSnapshotStatus(new UpdateIndexShardSnapshotStatusRequest(entry.getKey(),shardEntry.getKey(),new ShardSnapshotStatus(localNodeId,SnapshotMetaData.State.FAILED,ExceptionsHelper.detailedMessage(t))));
                }
              }
            }
);
          }
 catch (          Throwable t) {
            updateIndexShardSnapshotStatus(new UpdateIndexShardSnapshotStatusRequest(entry.getKey(),shardEntry.getKey(),new ShardSnapshotStatus(localNodeId,SnapshotMetaData.State.FAILED,ExceptionsHelper.detailedMessage(t))));
          }
        }
      }
    }
  }
  private void updateIndexShardSnapshotStatus(  UpdateIndexShardSnapshotStatusRequest request){
    try {
      if (clusterService.state().nodes().localNodeMaster()) {
        innerUpdateSnapshotState(request);
      }
 else {
        transportService.sendRequest(clusterService.state().nodes().masterNode(),UpdateSnapshotStateRequestHandler.ACTION,request,EmptyTransportResponseHandler.INSTANCE_SAME);
      }
    }
 catch (    Throwable t) {
      logger.warn("[{}] [{}] failed to update snapshot state",t,request.snapshotId(),request.status());
    }
  }
  private boolean completed(  Collection<SnapshotMetaData.ShardSnapshotStatus> shards){
    for (    ShardSnapshotStatus status : shards) {
      if (!status.state().completed()) {
        return false;
      }
    }
    return true;
  }
  private Set<String> indicesWithMissingShards(  ImmutableMap<ShardId,SnapshotMetaData.ShardSnapshotStatus> shards){
    Set<String> indices=null;
    for (    ImmutableMap.Entry<ShardId,SnapshotMetaData.ShardSnapshotStatus> entry : shards.entrySet()) {
      if (entry.getValue().state() == State.MISSING) {
        if (indices == null) {
          indices=newHashSet();
        }
        indices.add(entry.getKey().getIndex());
      }
    }
    return indices;
  }
  private void innerUpdateSnapshotState(  final UpdateIndexShardSnapshotStatusRequest request){
    clusterService.submitStateUpdateTask("update snapshot state",new ClusterStateUpdateTask(){
      @Override public ClusterState execute(      ClusterState currentState){
        MetaData metaData=currentState.metaData();
        MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
        SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
        if (snapshots != null) {
          boolean changed=false;
          ArrayList<SnapshotMetaData.Entry> entries=newArrayList();
          for (          SnapshotMetaData.Entry entry : snapshots.entries()) {
            if (entry.snapshotId().equals(request.snapshotId())) {
              HashMap<ShardId,ShardSnapshotStatus> shards=newHashMap(entry.shards());
              logger.trace("[{}] Updating shard [{}] with status [{}]",request.snapshotId(),request.shardId(),request.status().state());
              shards.put(request.shardId(),request.status());
              if (!completed(shards.values())) {
                entries.add(new SnapshotMetaData.Entry(entry.snapshotId(),entry.includeGlobalState(),entry.state(),entry.indices(),ImmutableMap.copyOf(shards)));
              }
 else {
                SnapshotMetaData.Entry updatedEntry=new SnapshotMetaData.Entry(entry.snapshotId(),entry.includeGlobalState(),State.SUCCESS,entry.indices(),ImmutableMap.copyOf(shards));
                entries.add(updatedEntry);
                endSnapshot(updatedEntry);
                logger.info("snapshot [{}] is done",updatedEntry.snapshotId());
              }
              changed=true;
            }
 else {
              entries.add(entry);
            }
          }
          if (changed) {
            snapshots=new SnapshotMetaData(entries.toArray(new SnapshotMetaData.Entry[entries.size()]));
            mdBuilder.putCustom(SnapshotMetaData.TYPE,snapshots);
            return ClusterState.builder(currentState).metaData(mdBuilder).build();
          }
        }
        return currentState;
      }
      @Override public void onFailure(      String source,      Throwable t){
        logger.warn("[{}][{}] failed to update snapshot status to [{}]",t,request.snapshotId(),request.shardId(),request.status());
      }
    }
);
  }
  private void endSnapshot(  SnapshotMetaData.Entry entry){
    endSnapshot(entry,null);
  }
  private void endSnapshot(  final SnapshotMetaData.Entry entry,  final String failure){
    threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new Runnable(){
      @Override public void run(){
        SnapshotId snapshotId=entry.snapshotId();
        try {
          final Repository repository=repositoriesService.repository(snapshotId.getRepository());
          logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]",snapshotId,entry.state(),failure);
          ArrayList<ShardSearchFailure> failures=newArrayList();
          ArrayList<SnapshotShardFailure> shardFailures=newArrayList();
          for (          Map.Entry<ShardId,ShardSnapshotStatus> shardStatus : entry.shards().entrySet()) {
            ShardId shardId=shardStatus.getKey();
            ShardSnapshotStatus status=shardStatus.getValue();
            if (status.state().failed()) {
              failures.add(new ShardSearchFailure(status.reason(),new SearchShardTarget(status.nodeId(),shardId.getIndex(),shardId.id())));
              shardFailures.add(new SnapshotShardFailure(status.nodeId(),shardId.getIndex(),shardId.id(),status.reason()));
            }
          }
          Snapshot snapshot=repository.finalizeSnapshot(snapshotId,failure,entry.shards().size(),ImmutableList.copyOf(shardFailures));
          removeSnapshotFromClusterState(snapshotId,new SnapshotInfo(snapshot),null);
        }
 catch (        Throwable t) {
          logger.warn("[{}] failed to finalize snapshot",t,snapshotId);
          removeSnapshotFromClusterState(snapshotId,null,t);
        }
      }
    }
);
  }
  private void removeSnapshotFromClusterState(  final SnapshotId snapshotId,  final SnapshotInfo snapshot,  final Throwable t){
    clusterService.submitStateUpdateTask("remove snapshot metadata",new ProcessedClusterStateUpdateTask(){
      @Override public ClusterState execute(      ClusterState currentState){
        MetaData metaData=currentState.metaData();
        MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
        SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
        if (snapshots != null) {
          boolean changed=false;
          ArrayList<SnapshotMetaData.Entry> entries=newArrayList();
          for (          SnapshotMetaData.Entry entry : snapshots.entries()) {
            if (entry.snapshotId().equals(snapshotId)) {
              changed=true;
            }
 else {
              entries.add(entry);
            }
          }
          if (changed) {
            snapshots=new SnapshotMetaData(entries.toArray(new SnapshotMetaData.Entry[entries.size()]));
            mdBuilder.putCustom(SnapshotMetaData.TYPE,snapshots);
            return ClusterState.builder(currentState).metaData(mdBuilder).build();
          }
        }
        return currentState;
      }
      @Override public void onFailure(      String source,      Throwable t){
        logger.warn("[{}][{}] failed to remove snapshot metadata",t,snapshotId);
      }
      @Override public void clusterStateProcessed(      String source,      ClusterState oldState,      ClusterState newState){
        for (        SnapshotCompletionListener listener : snapshotCompletionListeners) {
          try {
            if (snapshot != null) {
              listener.onSnapshotCompletion(snapshotId,snapshot);
            }
 else {
              listener.onSnapshotFailure(snapshotId,t);
            }
          }
 catch (          Throwable t) {
            logger.warn("failed to refresh settings for [{}]",t,listener);
          }
        }
      }
    }
);
  }
  public void deleteSnapshot(  final SnapshotId snapshotId,  final DeleteSnapshotListener listener){
    clusterService.submitStateUpdateTask("delete snapshot",new ProcessedClusterStateUpdateTask(){
      boolean waitForSnapshot=false;
      @Override public ClusterState execute(      ClusterState currentState) throws Exception {
        MetaData metaData=currentState.metaData();
        MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
        SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
        if (snapshots == null) {
          return currentState;
        }
        SnapshotMetaData.Entry snapshot=snapshots.snapshot(snapshotId);
        if (snapshot == null) {
          if (!snapshots.entries().isEmpty()) {
            throw new ConcurrentSnapshotExecutionException(snapshotId,"another snapshot is currently running cannot delete");
          }
          return currentState;
        }
 else {
          waitForSnapshot=true;
          ImmutableMap<ShardId,ShardSnapshotStatus> shards;
          if (snapshot.state() == State.STARTED && snapshot.shards() != null) {
            ImmutableMap.Builder<ShardId,ShardSnapshotStatus> shardsBuilder=ImmutableMap.builder();
            for (            ImmutableMap.Entry<ShardId,ShardSnapshotStatus> shardEntry : snapshot.shards().entrySet()) {
              ShardSnapshotStatus status=shardEntry.getValue();
              if (!status.state().completed()) {
                shardsBuilder.put(shardEntry.getKey(),new ShardSnapshotStatus(status.nodeId(),State.ABORTED));
              }
 else {
                shardsBuilder.put(shardEntry.getKey(),status);
              }
            }
            shards=shardsBuilder.build();
          }
 else           if (snapshot.state() == State.INIT) {
            shards=snapshot.shards();
            endSnapshot(snapshot);
          }
 else {
            logger.trace("trying to delete completed snapshot - save to delete");
            return currentState;
          }
          SnapshotMetaData.Entry newSnapshot=new SnapshotMetaData.Entry(snapshotId,snapshot.includeGlobalState(),State.ABORTED,snapshot.indices(),shards);
          snapshots=new SnapshotMetaData(newSnapshot);
          mdBuilder.putCustom(SnapshotMetaData.TYPE,snapshots);
          return ClusterState.builder(currentState).metaData(mdBuilder).build();
        }
      }
      @Override public void onFailure(      String source,      Throwable t){
        listener.onFailure(t);
      }
      @Override public void clusterStateProcessed(      String source,      ClusterState oldState,      ClusterState newState){
        if (waitForSnapshot) {
          logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish");
          addListener(new SnapshotCompletionListener(){
            @Override public void onSnapshotCompletion(            SnapshotId snapshotId,            SnapshotInfo snapshot){
              logger.trace("deleted snapshot completed - deleting files");
              removeListener(this);
              deleteSnapshotFromRepository(snapshotId,listener);
            }
            @Override public void onSnapshotFailure(            SnapshotId snapshotId,            Throwable t){
              logger.trace("deleted snapshot failed - deleting files",t);
              removeListener(this);
              deleteSnapshotFromRepository(snapshotId,listener);
            }
          }
);
        }
 else {
          logger.trace("deleted snapshot is not running - deleting files");
          deleteSnapshotFromRepository(snapshotId,listener);
        }
      }
    }
);
  }
  public static boolean isRepositoryInUse(  ClusterState clusterState,  String repository){
    MetaData metaData=clusterState.metaData();
    SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
    if (snapshots != null) {
      for (      SnapshotMetaData.Entry snapshot : snapshots.entries()) {
        if (repository.equals(snapshot.snapshotId().getRepository())) {
          return true;
        }
      }
    }
    return false;
  }
  private void deleteSnapshotFromRepository(  final SnapshotId snapshotId,  final DeleteSnapshotListener listener){
    threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new Runnable(){
      @Override public void run(){
        try {
          Repository repository=repositoriesService.repository(snapshotId.getRepository());
          repository.deleteSnapshot(snapshotId);
          listener.onResponse();
        }
 catch (        Throwable t) {
          listener.onFailure(t);
        }
      }
    }
);
  }
  private ImmutableMap<ShardId,SnapshotMetaData.ShardSnapshotStatus> shards(  SnapshotId snapshotId,  ClusterState clusterState,  ImmutableList<String> indices){
    ImmutableMap.Builder<ShardId,SnapshotMetaData.ShardSnapshotStatus> builder=ImmutableMap.builder();
    MetaData metaData=clusterState.metaData();
    for (    String index : indices) {
      IndexMetaData indexMetaData=metaData.index(index);
      IndexRoutingTable indexRoutingTable=clusterState.getRoutingTable().index(index);
      if (indexRoutingTable == null) {
        throw new SnapshotCreationException(snapshotId,"Missing routing table for index [" + index + "]");
      }
      for (int i=0; i < indexMetaData.numberOfShards(); i++) {
        ShardId shardId=new ShardId(index,i);
        ShardRouting primary=indexRoutingTable.shard(i).primaryShard();
        if (primary == null || !primary.assignedToNode()) {
          builder.put(shardId,new SnapshotMetaData.ShardSnapshotStatus(null,State.MISSING,"primary shard is not allocated"));
        }
 else         if (clusterState.getNodes().smallestVersion().onOrAfter(Version.V_1_2_0) && (primary.relocating() || primary.initializing())) {
          builder.put(shardId,new SnapshotMetaData.ShardSnapshotStatus(primary.currentNodeId(),State.WAITING));
        }
 else         if (!primary.started()) {
          builder.put(shardId,new SnapshotMetaData.ShardSnapshotStatus(primary.currentNodeId(),State.MISSING,"primary shard hasn't been started yet"));
        }
 else {
          builder.put(shardId,new SnapshotMetaData.ShardSnapshotStatus(primary.currentNodeId()));
        }
      }
    }
    return builder.build();
  }
  public void addListener(  SnapshotCompletionListener listener){
    this.snapshotCompletionListeners.add(listener);
  }
  public void removeListener(  SnapshotCompletionListener listener){
    this.snapshotCompletionListeners.remove(listener);
  }
  @Override protected void doStart() throws ElasticsearchException {
  }
  @Override protected void doStop() throws ElasticsearchException {
    shutdownLock.lock();
    try {
      while (!shardSnapshots.isEmpty() && shutdownCondition.await(5,TimeUnit.SECONDS)) {
      }
    }
 catch (    InterruptedException ex) {
      Thread.currentThread().interrupt();
    }
 finally {
      shutdownLock.unlock();
    }
  }
  @Override protected void doClose() throws ElasticsearchException {
  }
public static interface CreateSnapshotListener {
    void onResponse();
    void onFailure(    Throwable t);
  }
public static interface DeleteSnapshotListener {
    void onResponse();
    void onFailure(    Throwable t);
  }
public static interface SnapshotCompletionListener {
    void onSnapshotCompletion(    SnapshotId snapshotId,    SnapshotInfo snapshot);
    void onSnapshotFailure(    SnapshotId snapshotId,    Throwable t);
  }
public static class SnapshotRequest {
    private String cause;
    private String name;
    private String repository;
    private String[] indices;
    private IndicesOptions indicesOptions=IndicesOptions.strictExpandOpen();
    private boolean partial;
    private Settings settings;
    private boolean includeGlobalState;
    private TimeValue masterNodeTimeout;
    public SnapshotRequest(    String cause,    String name,    String repository){
      this.cause=cause;
      this.name=name;
      this.repository=repository;
    }
    public SnapshotRequest indices(    String[] indices){
      this.indices=indices;
      return this;
    }
    public SnapshotRequest settings(    Settings settings){
      this.settings=settings;
      return this;
    }
    public SnapshotRequest includeGlobalState(    boolean includeGlobalState){
      this.includeGlobalState=includeGlobalState;
      return this;
    }
    public SnapshotRequest masterNodeTimeout(    TimeValue masterNodeTimeout){
      this.masterNodeTimeout=masterNodeTimeout;
      return this;
    }
    public SnapshotRequest indicesOptions(    IndicesOptions indicesOptions){
      this.indicesOptions=indicesOptions;
      return this;
    }
    public SnapshotRequest partial(    boolean partial){
      this.partial=partial;
      return this;
    }
    public String cause(){
      return cause;
    }
    public String name(){
      return name;
    }
    public String repository(){
      return repository;
    }
    public String[] indices(){
      return indices;
    }
    public IndicesOptions indicesOptions(){
      return indicesOptions;
    }
    public Settings settings(){
      return settings;
    }
    public boolean includeGlobalState(){
      return includeGlobalState;
    }
    public TimeValue masterNodeTimeout(){
      return masterNodeTimeout;
    }
  }
private static class SnapshotShards {
    private final ImmutableMap<ShardId,IndexShardSnapshotStatus> shards;
    private SnapshotShards(    ImmutableMap<ShardId,IndexShardSnapshotStatus> shards){
      this.shards=shards;
    }
  }
private static class UpdateIndexShardSnapshotStatusRequest extends TransportRequest {
    private SnapshotId snapshotId;
    private ShardId shardId;
    private SnapshotMetaData.ShardSnapshotStatus status;
    private UpdateIndexShardSnapshotStatusRequest(){
    }
    private UpdateIndexShardSnapshotStatusRequest(    SnapshotId snapshotId,    ShardId shardId,    SnapshotMetaData.ShardSnapshotStatus status){
      this.snapshotId=snapshotId;
      this.shardId=shardId;
      this.status=status;
    }
    @Override public void readFrom(    StreamInput in) throws IOException {
      super.readFrom(in);
      snapshotId=SnapshotId.readSnapshotId(in);
      shardId=ShardId.readShardId(in);
      status=SnapshotMetaData.ShardSnapshotStatus.readShardSnapshotStatus(in);
    }
    @Override public void writeTo(    StreamOutput out) throws IOException {
      super.writeTo(out);
      snapshotId.writeTo(out);
      shardId.writeTo(out);
      status.writeTo(out);
    }
    public SnapshotId snapshotId(){
      return snapshotId;
    }
    public ShardId shardId(){
      return shardId;
    }
    public SnapshotMetaData.ShardSnapshotStatus status(){
      return status;
    }
  }
private class UpdateSnapshotStateRequestHandler extends BaseTransportRequestHandler<UpdateIndexShardSnapshotStatusRequest> {
    static final String ACTION="cluster/snapshot/update_snapshot";
    @Override public UpdateIndexShardSnapshotStatusRequest newInstance(){
      return new UpdateIndexShardSnapshotStatusRequest();
    }
    @Override public void messageReceived(    UpdateIndexShardSnapshotStatusRequest request,    final TransportChannel channel) throws Exception {
      innerUpdateSnapshotState(request);
      channel.sendResponse(TransportResponse.Empty.INSTANCE);
    }
    @Override public String executor(){
      return ThreadPool.Names.SAME;
    }
  }
}
