package com.android.launcher2;
import android.animation.Animator;
import android.animation.AnimatorInflater;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.ValueAnimator;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.AttributeSet;
import android.util.Log;
import android.view.ActionMode;
import android.view.InputDevice;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.animation.Interpolator;
import android.widget.Checkable;
import android.widget.ImageView;
import android.widget.Scroller;
import com.android.launcher.R;
import java.util.ArrayList;
public abstract class PagedView extends ViewGroup {
  private static final String TAG="PagedView";
  private static final boolean DEBUG=false;
  protected static final int INVALID_PAGE=-1;
  private static final int MIN_LENGTH_FOR_FLING=25;
  private static final int MIN_LENGTH_FOR_MOVE=200;
  private static final int PAGE_SNAP_ANIMATION_DURATION=550;
  protected static final float NANOTIME_DIV=1000000000.0f;
  private static final float OVERSCROLL_ACCELERATE_FACTOR=2;
  private static final float OVERSCROLL_DAMP_FACTOR=0.14f;
  private static final int MINIMUM_SNAP_VELOCITY=2200;
  private static final int MIN_FLING_VELOCITY=250;
  private static final float RETURN_TO_ORIGINAL_PAGE_THRESHOLD=0.33f;
  protected int mSnapVelocity=500;
  protected float mDensity;
  protected float mSmoothingTime;
  protected float mTouchX;
  protected boolean mFirstLayout=true;
  protected int mCurrentPage;
  protected int mNextPage=INVALID_PAGE;
  protected int mMaxScrollX;
  protected Scroller mScroller;
  private VelocityTracker mVelocityTracker;
  private float mDownMotionX;
  protected float mLastMotionX;
  protected float mLastMotionXRemainder;
  protected float mLastMotionY;
  protected float mTotalMotionX;
  private int mLastScreenCenter=-1;
  private int[] mChildOffsets;
  private int[] mChildRelativeOffsets;
  private int[] mChildOffsetsWithLayoutScale;
  protected final static int TOUCH_STATE_REST=0;
  protected final static int TOUCH_STATE_SCROLLING=1;
  protected final static int TOUCH_STATE_PREV_PAGE=2;
  protected final static int TOUCH_STATE_NEXT_PAGE=3;
  protected final static float ALPHA_QUANTIZE_LEVEL=0.0001f;
  protected int mTouchState=TOUCH_STATE_REST;
  protected boolean mForceScreenScrolled=false;
  protected OnLongClickListener mLongClickListener;
  protected boolean mAllowLongPress=true;
  protected int mTouchSlop;
  private int mPagingTouchSlop;
  private int mMaximumVelocity;
  private int mMinimumWidth;
  protected int mPageSpacing;
  protected int mPageLayoutPaddingTop;
  protected int mPageLayoutPaddingBottom;
  protected int mPageLayoutPaddingLeft;
  protected int mPageLayoutPaddingRight;
  protected int mPageLayoutWidthGap;
  protected int mPageLayoutHeightGap;
  protected int mCellCountX=0;
  protected int mCellCountY=0;
  protected boolean mCenterPagesVertically;
  protected boolean mAllowOverScroll=true;
  protected int mUnboundedScrollX;
  protected int[] mTempVisiblePagesRange=new int[2];
  protected int mOverScrollX;
  protected float mLayoutScale=1.0f;
  protected static final int INVALID_POINTER=-1;
  protected int mActivePointerId=INVALID_POINTER;
  private PageSwitchListener mPageSwitchListener;
  private ArrayList<Boolean> mDirtyPageContent;
  protected static final int CHOICE_MODE_NONE=0;
  protected static final int CHOICE_MODE_SINGLE=1;
  protected static final int CHOICE_MODE_MULTIPLE=2;
  protected int mChoiceMode;
  private ActionMode mActionMode;
  protected boolean mContentIsRefreshable=true;
  protected boolean mFadeInAdjacentScreens=true;
  protected boolean mUsePagingTouchSlop=true;
  protected boolean mDeferScrollUpdate=false;
  protected boolean mIsPageMoving=false;
  protected boolean mIsDataReady=false;
  private ValueAnimator mScrollIndicatorAnimator;
  private ImageView mScrollIndicator;
  private int mScrollIndicatorPaddingLeft;
  private int mScrollIndicatorPaddingRight;
  private boolean mHasScrollIndicator=true;
  protected static final int sScrollIndicatorFadeInDuration=150;
  protected static final int sScrollIndicatorFadeOutDuration=650;
  protected static final int sScrollIndicatorFlashDuration=650;
  private boolean mDeferLoadAssociatedPagesUntilScrollCompletes;
public interface PageSwitchListener {
    void onPageSwitch(    View newPage,    int newPageIndex);
  }
  public PagedView(  Context context){
    this(context,null);
  }
  public PagedView(  Context context,  AttributeSet attrs){
    this(context,attrs,0);
  }
  public PagedView(  Context context,  AttributeSet attrs,  int defStyle){
    super(context,attrs,defStyle);
    mChoiceMode=CHOICE_MODE_NONE;
    TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.PagedView,defStyle,0);
    mPageSpacing=a.getDimensionPixelSize(R.styleable.PagedView_pageSpacing,0);
    mPageLayoutPaddingTop=a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingTop,0);
    mPageLayoutPaddingBottom=a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingBottom,0);
    mPageLayoutPaddingLeft=a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingLeft,0);
    mPageLayoutPaddingRight=a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingRight,0);
    mPageLayoutWidthGap=a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutWidthGap,0);
    mPageLayoutHeightGap=a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutHeightGap,0);
    mScrollIndicatorPaddingLeft=a.getDimensionPixelSize(R.styleable.PagedView_scrollIndicatorPaddingLeft,0);
    mScrollIndicatorPaddingRight=a.getDimensionPixelSize(R.styleable.PagedView_scrollIndicatorPaddingRight,0);
    a.recycle();
    setHapticFeedbackEnabled(false);
    init();
  }
  protected void init(){
    mDirtyPageContent=new ArrayList<Boolean>();
    mDirtyPageContent.ensureCapacity(32);
    mScroller=new Scroller(getContext(),new ScrollInterpolator());
    mCurrentPage=0;
    mCenterPagesVertically=true;
    final ViewConfiguration configuration=ViewConfiguration.get(getContext());
    mTouchSlop=configuration.getScaledTouchSlop();
    mPagingTouchSlop=configuration.getScaledPagingTouchSlop();
    mMaximumVelocity=configuration.getScaledMaximumFlingVelocity();
    mDensity=getResources().getDisplayMetrics().density;
  }
  public void setPageSwitchListener(  PageSwitchListener pageSwitchListener){
    mPageSwitchListener=pageSwitchListener;
    if (mPageSwitchListener != null) {
      mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage),mCurrentPage);
    }
  }
  protected void setDataIsReady(){
    mIsDataReady=true;
  }
  protected boolean isDataReady(){
    return mIsDataReady;
  }
  int getCurrentPage(){
    return mCurrentPage;
  }
  int getPageCount(){
    return getChildCount();
  }
  View getPageAt(  int index){
    return getChildAt(index);
  }
  protected int indexToPage(  int index){
    return index;
  }
  protected void updateCurrentPageScroll(){
    int newX=getChildOffset(mCurrentPage) - getRelativeChildOffset(mCurrentPage);
    scrollTo(newX,0);
    mScroller.setFinalX(newX);
  }
  void setCurrentPage(  int currentPage){
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
    if (getChildCount() == 0) {
      return;
    }
    mCurrentPage=Math.max(0,Math.min(currentPage,getPageCount() - 1));
    updateCurrentPageScroll();
    updateScrollingIndicator();
    notifyPageSwitchListener();
    invalidate();
  }
  protected void notifyPageSwitchListener(){
    if (mPageSwitchListener != null) {
      mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage),mCurrentPage);
    }
  }
  protected void pageBeginMoving(){
    if (!mIsPageMoving) {
      mIsPageMoving=true;
      onPageBeginMoving();
    }
  }
  protected void pageEndMoving(){
    if (mIsPageMoving) {
      mIsPageMoving=false;
      onPageEndMoving();
    }
  }
  protected boolean isPageMoving(){
    return mIsPageMoving;
  }
  protected void onPageBeginMoving(){
    showScrollingIndicator(false);
  }
  protected void onPageEndMoving(){
    hideScrollingIndicator(false);
  }
  @Override public void setOnLongClickListener(  OnLongClickListener l){
    mLongClickListener=l;
    final int count=getPageCount();
    for (int i=0; i < count; i++) {
      getPageAt(i).setOnLongClickListener(l);
    }
  }
  @Override public void scrollBy(  int x,  int y){
    scrollTo(mUnboundedScrollX + x,mScrollY + y);
  }
  @Override public void scrollTo(  int x,  int y){
    mUnboundedScrollX=x;
    if (x < 0) {
      super.scrollTo(0,y);
      if (mAllowOverScroll) {
        overScroll(x);
      }
    }
 else     if (x > mMaxScrollX) {
      super.scrollTo(mMaxScrollX,y);
      if (mAllowOverScroll) {
        overScroll(x - mMaxScrollX);
      }
    }
 else {
      mOverScrollX=x;
      super.scrollTo(x,y);
    }
    mTouchX=x;
    mSmoothingTime=System.nanoTime() / NANOTIME_DIV;
  }
  protected boolean computeScrollHelper(){
    if (mScroller.computeScrollOffset()) {
      if (mScrollX != mScroller.getCurrX() || mScrollY != mScroller.getCurrY()) {
        scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
      }
      invalidate();
      return true;
    }
 else     if (mNextPage != INVALID_PAGE) {
      mCurrentPage=Math.max(0,Math.min(mNextPage,getPageCount() - 1));
      mNextPage=INVALID_PAGE;
      notifyPageSwitchListener();
      if (mDeferLoadAssociatedPagesUntilScrollCompletes) {
        loadAssociatedPages(mCurrentPage);
        mDeferLoadAssociatedPagesUntilScrollCompletes=false;
      }
      if (mTouchState == TOUCH_STATE_REST) {
        pageEndMoving();
      }
      if (AccessibilityManager.getInstance(getContext()).isEnabled()) {
        AccessibilityEvent ev=AccessibilityEvent.obtain(AccessibilityEvent.TYPE_VIEW_SCROLLED);
        ev.getText().add(getCurrentPageDescription());
        sendAccessibilityEventUnchecked(ev);
      }
      return true;
    }
    return false;
  }
  @Override public void computeScroll(){
    computeScrollHelper();
  }
  @Override protected void onMeasure(  int widthMeasureSpec,  int heightMeasureSpec){
    if (!mIsDataReady) {
      super.onMeasure(widthMeasureSpec,heightMeasureSpec);
      return;
    }
    final int widthMode=MeasureSpec.getMode(widthMeasureSpec);
    final int widthSize=MeasureSpec.getSize(widthMeasureSpec);
    if (widthMode != MeasureSpec.EXACTLY) {
      throw new IllegalStateException("Workspace can only be used in EXACTLY mode.");
    }
    final int heightMode=MeasureSpec.getMode(heightMeasureSpec);
    int heightSize=MeasureSpec.getSize(heightMeasureSpec);
    int maxChildHeight=0;
    final int verticalPadding=mPaddingTop + mPaddingBottom;
    final int horizontalPadding=mPaddingLeft + mPaddingRight;
    if (DEBUG)     Log.d(TAG,"PagedView.onMeasure(): " + widthSize + ", "+ heightSize);
    final int childCount=getChildCount();
    for (int i=0; i < childCount; i++) {
      final View child=getPageAt(i);
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      int childWidthMode;
      if (lp.width == LayoutParams.WRAP_CONTENT) {
        childWidthMode=MeasureSpec.AT_MOST;
      }
 else {
        childWidthMode=MeasureSpec.EXACTLY;
      }
      int childHeightMode;
      if (lp.height == LayoutParams.WRAP_CONTENT) {
        childHeightMode=MeasureSpec.AT_MOST;
      }
 else {
        childHeightMode=MeasureSpec.EXACTLY;
      }
      final int childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(widthSize - horizontalPadding,childWidthMode);
      final int childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(heightSize - verticalPadding,childHeightMode);
      child.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      maxChildHeight=Math.max(maxChildHeight,child.getMeasuredHeight());
      if (DEBUG)       Log.d(TAG,"\tmeasure-child" + i + ": "+ child.getMeasuredWidth()+ ", "+ child.getMeasuredHeight());
    }
    if (heightMode == MeasureSpec.AT_MOST) {
      heightSize=maxChildHeight + verticalPadding;
    }
    setMeasuredDimension(widthSize,heightSize);
    invalidateCachedOffsets();
    updateScrollingIndicatorPosition();
    if (childCount > 0) {
      mMaxScrollX=getChildOffset(childCount - 1) - getRelativeChildOffset(childCount - 1);
    }
 else {
      mMaxScrollX=0;
    }
  }
  protected void scrollToNewPageWithoutMovingPages(  int newCurrentPage){
    int newX=getChildOffset(newCurrentPage) - getRelativeChildOffset(newCurrentPage);
    int delta=newX - mScrollX;
    final int pageCount=getChildCount();
    for (int i=0; i < pageCount; i++) {
      View page=(View)getPageAt(i);
      page.setX(page.getX() + delta);
    }
    setCurrentPage(newCurrentPage);
  }
  public void setLayoutScale(  float childrenScale){
    mLayoutScale=childrenScale;
    invalidateCachedOffsets();
    int childCount=getChildCount();
    float childrenX[]=new float[childCount];
    float childrenY[]=new float[childCount];
    for (int i=0; i < childCount; i++) {
      final View child=getPageAt(i);
      childrenX[i]=child.getX();
      childrenY[i]=child.getY();
    }
    int widthSpec=MeasureSpec.makeMeasureSpec(getMeasuredWidth(),MeasureSpec.EXACTLY);
    int heightSpec=MeasureSpec.makeMeasureSpec(getMeasuredHeight(),MeasureSpec.EXACTLY);
    requestLayout();
    measure(widthSpec,heightSpec);
    layout(mLeft,mTop,mRight,mBottom);
    for (int i=0; i < childCount; i++) {
      final View child=getPageAt(i);
      child.setX(childrenX[i]);
      child.setY(childrenY[i]);
    }
    scrollToNewPageWithoutMovingPages(mCurrentPage);
  }
  @Override protected void onLayout(  boolean changed,  int left,  int top,  int right,  int bottom){
    if (!mIsDataReady) {
      return;
    }
    if (DEBUG)     Log.d(TAG,"PagedView.onLayout()");
    final int verticalPadding=mPaddingTop + mPaddingBottom;
    final int childCount=getChildCount();
    int childLeft=0;
    if (childCount > 0) {
      if (DEBUG)       Log.d(TAG,"getRelativeChildOffset(): " + getMeasuredWidth() + ", "+ getChildWidth(0));
      childLeft=getRelativeChildOffset(0);
      if (mPageSpacing < 0) {
        mPageSpacing=((right - left) - getChildAt(0).getMeasuredWidth()) / 2;
      }
    }
    for (int i=0; i < childCount; i++) {
      final View child=getPageAt(i);
      if (child.getVisibility() != View.GONE) {
        final int childWidth=getScaledMeasuredWidth(child);
        final int childHeight=child.getMeasuredHeight();
        int childTop=mPaddingTop;
        if (mCenterPagesVertically) {
          childTop+=((getMeasuredHeight() - verticalPadding) - childHeight) / 2;
        }
        if (DEBUG)         Log.d(TAG,"\tlayout-child" + i + ": "+ childLeft+ ", "+ childTop);
        child.layout(childLeft,childTop,childLeft + child.getMeasuredWidth(),childTop + childHeight);
        childLeft+=childWidth + mPageSpacing;
      }
    }
    if (mFirstLayout && mCurrentPage >= 0 && mCurrentPage < getChildCount()) {
      setHorizontalScrollBarEnabled(false);
      int newX=getChildOffset(mCurrentPage) - getRelativeChildOffset(mCurrentPage);
      scrollTo(newX,0);
      mScroller.setFinalX(newX);
      setHorizontalScrollBarEnabled(true);
      mFirstLayout=false;
    }
    if (mFirstLayout && mCurrentPage >= 0 && mCurrentPage < getChildCount()) {
      mFirstLayout=false;
    }
  }
  protected void screenScrolled(  int screenCenter){
    if (isScrollingIndicatorEnabled()) {
      updateScrollingIndicator();
    }
    if (mFadeInAdjacentScreens) {
      for (int i=0; i < getChildCount(); i++) {
        View child=getChildAt(i);
        if (child != null) {
          float scrollProgress=getScrollProgress(screenCenter,child,i);
          float alpha=1 - Math.abs(scrollProgress);
          child.setFastAlpha(alpha);
          child.fastInvalidate();
        }
      }
      invalidate();
    }
  }
  @Override protected void onViewAdded(  View child){
    super.onViewAdded(child);
    mForceScreenScrolled=true;
    invalidate();
    invalidateCachedOffsets();
  }
  protected void invalidateCachedOffsets(){
    int count=getChildCount();
    if (count == 0) {
      mChildOffsets=null;
      mChildRelativeOffsets=null;
      mChildOffsetsWithLayoutScale=null;
      return;
    }
    mChildOffsets=new int[count];
    mChildRelativeOffsets=new int[count];
    mChildOffsetsWithLayoutScale=new int[count];
    for (int i=0; i < count; i++) {
      mChildOffsets[i]=-1;
      mChildRelativeOffsets[i]=-1;
      mChildOffsetsWithLayoutScale[i]=-1;
    }
  }
  protected int getChildOffset(  int index){
    int[] childOffsets=Float.compare(mLayoutScale,1f) == 0 ? mChildOffsets : mChildOffsetsWithLayoutScale;
    if (childOffsets != null && childOffsets[index] != -1) {
      return childOffsets[index];
    }
 else {
      if (getChildCount() == 0)       return 0;
      int offset=getRelativeChildOffset(0);
      for (int i=0; i < index; ++i) {
        offset+=getScaledMeasuredWidth(getPageAt(i)) + mPageSpacing;
      }
      if (childOffsets != null) {
        childOffsets[index]=offset;
      }
      return offset;
    }
  }
  protected int getRelativeChildOffset(  int index){
    if (mChildRelativeOffsets != null && mChildRelativeOffsets[index] != -1) {
      return mChildRelativeOffsets[index];
    }
 else {
      final int padding=mPaddingLeft + mPaddingRight;
      final int offset=mPaddingLeft + (getMeasuredWidth() - padding - getChildWidth(index)) / 2;
      if (mChildRelativeOffsets != null) {
        mChildRelativeOffsets[index]=offset;
      }
      return offset;
    }
  }
  protected int getScaledRelativeChildOffset(  int index){
    final int padding=mPaddingLeft + mPaddingRight;
    final int offset=mPaddingLeft + (getMeasuredWidth() - padding - getScaledMeasuredWidth(getPageAt(index))) / 2;
    return offset;
  }
  protected int getScaledMeasuredWidth(  View child){
    final int measuredWidth=child.getMeasuredWidth();
    final int minWidth=mMinimumWidth;
    final int maxWidth=(minWidth > measuredWidth) ? minWidth : measuredWidth;
    return (int)(maxWidth * mLayoutScale + 0.5f);
  }
  protected void getVisiblePages(  int[] range){
    final int pageCount=getChildCount();
    if (pageCount > 0) {
      final int pageWidth=getScaledMeasuredWidth(getPageAt(0));
      final int screenWidth=getMeasuredWidth();
      int x=getScaledRelativeChildOffset(0) + pageWidth;
      int leftScreen=0;
      int rightScreen=0;
      while (x <= mScrollX && leftScreen < pageCount - 1) {
        leftScreen++;
        x+=getScaledMeasuredWidth(getPageAt(leftScreen)) + mPageSpacing;
      }
      rightScreen=leftScreen;
      while (x < mScrollX + screenWidth && rightScreen < pageCount - 1) {
        rightScreen++;
        x+=getScaledMeasuredWidth(getPageAt(rightScreen)) + mPageSpacing;
      }
      range[0]=leftScreen;
      range[1]=rightScreen;
    }
 else {
      range[0]=-1;
      range[1]=-1;
    }
  }
  @Override protected void dispatchDraw(  Canvas canvas){
    int halfScreenSize=getMeasuredWidth() / 2;
    int screenCenter=mOverScrollX + halfScreenSize;
    if (screenCenter != mLastScreenCenter || mForceScreenScrolled) {
      screenScrolled(screenCenter);
      mLastScreenCenter=screenCenter;
      mForceScreenScrolled=false;
    }
    final int pageCount=getChildCount();
    if (pageCount > 0) {
      getVisiblePages(mTempVisiblePagesRange);
      final int leftScreen=mTempVisiblePagesRange[0];
      final int rightScreen=mTempVisiblePagesRange[1];
      final long drawingTime=getDrawingTime();
      canvas.save();
      canvas.clipRect(mScrollX,mScrollY,mScrollX + mRight - mLeft,mScrollY + mBottom - mTop);
      for (int i=rightScreen; i >= leftScreen; i--) {
        drawChild(canvas,getPageAt(i),drawingTime);
      }
      canvas.restore();
    }
  }
  @Override public boolean requestChildRectangleOnScreen(  View child,  Rect rectangle,  boolean immediate){
    int page=indexToPage(indexOfChild(child));
    if (page != mCurrentPage || !mScroller.isFinished()) {
      snapToPage(page);
      return true;
    }
    return false;
  }
  @Override protected boolean onRequestFocusInDescendants(  int direction,  Rect previouslyFocusedRect){
    int focusablePage;
    if (mNextPage != INVALID_PAGE) {
      focusablePage=mNextPage;
    }
 else {
      focusablePage=mCurrentPage;
    }
    View v=getPageAt(focusablePage);
    if (v != null) {
      return v.requestFocus(direction,previouslyFocusedRect);
    }
    return false;
  }
  @Override public boolean dispatchUnhandledMove(  View focused,  int direction){
    if (direction == View.FOCUS_LEFT) {
      if (getCurrentPage() > 0) {
        snapToPage(getCurrentPage() - 1);
        return true;
      }
    }
 else     if (direction == View.FOCUS_RIGHT) {
      if (getCurrentPage() < getPageCount() - 1) {
        snapToPage(getCurrentPage() + 1);
        return true;
      }
    }
    return super.dispatchUnhandledMove(focused,direction);
  }
  @Override public void addFocusables(  ArrayList<View> views,  int direction,  int focusableMode){
    if (mCurrentPage >= 0 && mCurrentPage < getPageCount()) {
      getPageAt(mCurrentPage).addFocusables(views,direction);
    }
    if (direction == View.FOCUS_LEFT) {
      if (mCurrentPage > 0) {
        getPageAt(mCurrentPage - 1).addFocusables(views,direction);
      }
    }
 else     if (direction == View.FOCUS_RIGHT) {
      if (mCurrentPage < getPageCount() - 1) {
        getPageAt(mCurrentPage + 1).addFocusables(views,direction);
      }
    }
  }
  @Override public void focusableViewAvailable(  View focused){
    View current=getPageAt(mCurrentPage);
    View v=focused;
    while (true) {
      if (v == current) {
        super.focusableViewAvailable(focused);
        return;
      }
      if (v == this) {
        return;
      }
      ViewParent parent=v.getParent();
      if (parent instanceof View) {
        v=(View)v.getParent();
      }
 else {
        return;
      }
    }
  }
  @Override public void requestDisallowInterceptTouchEvent(  boolean disallowIntercept){
    if (disallowIntercept) {
      final View currentPage=getPageAt(mCurrentPage);
      currentPage.cancelLongPress();
    }
    super.requestDisallowInterceptTouchEvent(disallowIntercept);
  }
  protected boolean hitsPreviousPage(  float x,  float y){
    return (x < getRelativeChildOffset(mCurrentPage) - mPageSpacing);
  }
  protected boolean hitsNextPage(  float x,  float y){
    return (x > (getMeasuredWidth() - getRelativeChildOffset(mCurrentPage) + mPageSpacing));
  }
  @Override public boolean onInterceptTouchEvent(  MotionEvent ev){
    acquireVelocityTrackerAndAddMovement(ev);
    if (getChildCount() <= 0)     return super.onInterceptTouchEvent(ev);
    final int action=ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mTouchState == TOUCH_STATE_SCROLLING)) {
      return true;
    }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
        if (mActivePointerId != INVALID_POINTER) {
          determineScrollingStart(ev);
          break;
        }
      }
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      final float y=ev.getY();
      mDownMotionX=x;
      mLastMotionX=x;
      mLastMotionY=y;
      mLastMotionXRemainder=0;
      mTotalMotionX=0;
      mActivePointerId=ev.getPointerId(0);
      mAllowLongPress=true;
      final int xDist=Math.abs(mScroller.getFinalX() - mScroller.getCurrX());
      final boolean finishedScrolling=(mScroller.isFinished() || xDist < mTouchSlop);
      if (finishedScrolling) {
        mTouchState=TOUCH_STATE_REST;
        mScroller.abortAnimation();
      }
 else {
        mTouchState=TOUCH_STATE_SCROLLING;
      }
      if (mTouchState != TOUCH_STATE_PREV_PAGE && mTouchState != TOUCH_STATE_NEXT_PAGE) {
        if (getChildCount() > 0) {
          if (hitsPreviousPage(x,y)) {
            mTouchState=TOUCH_STATE_PREV_PAGE;
          }
 else           if (hitsNextPage(x,y)) {
            mTouchState=TOUCH_STATE_NEXT_PAGE;
          }
        }
      }
      break;
    }
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
  mTouchState=TOUCH_STATE_REST;
mAllowLongPress=false;
mActivePointerId=INVALID_POINTER;
releaseVelocityTracker();
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
releaseVelocityTracker();
break;
}
return mTouchState != TOUCH_STATE_REST;
}
protected void animateClickFeedback(View v,final Runnable r){
ObjectAnimator anim=(ObjectAnimator)AnimatorInflater.loadAnimator(mContext,R.anim.paged_view_click_feedback);
anim.setTarget(v);
anim.addListener(new AnimatorListenerAdapter(){
public void onAnimationRepeat(Animator animation){
r.run();
}
}
);
anim.start();
}
protected void determineScrollingStart(MotionEvent ev){
determineScrollingStart(ev,1.0f);
}
protected void determineScrollingStart(MotionEvent ev,float touchSlopScale){
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
if (pointerIndex == -1) {
return;
}
final float x=ev.getX(pointerIndex);
final float y=ev.getY(pointerIndex);
final int xDiff=(int)Math.abs(x - mLastMotionX);
final int yDiff=(int)Math.abs(y - mLastMotionY);
final int touchSlop=Math.round(touchSlopScale * mTouchSlop);
boolean xPaged=xDiff > mPagingTouchSlop;
boolean xMoved=xDiff > touchSlop;
boolean yMoved=yDiff > touchSlop;
if (xMoved || xPaged || yMoved) {
if (mUsePagingTouchSlop ? xPaged : xMoved) {
mTouchState=TOUCH_STATE_SCROLLING;
mTotalMotionX+=Math.abs(mLastMotionX - x);
mLastMotionX=x;
mLastMotionXRemainder=0;
mTouchX=mScrollX;
mSmoothingTime=System.nanoTime() / NANOTIME_DIV;
pageBeginMoving();
}
cancelCurrentPageLongPress();
}
}
protected void cancelCurrentPageLongPress(){
if (mAllowLongPress) {
mAllowLongPress=false;
final View currentPage=getPageAt(mCurrentPage);
if (currentPage != null) {
currentPage.cancelLongPress();
}
}
}
protected float getScrollProgress(int screenCenter,View v,int page){
final int halfScreenSize=getMeasuredWidth() / 2;
int totalDistance=getScaledMeasuredWidth(v) + mPageSpacing;
int delta=screenCenter - (getChildOffset(page) - getRelativeChildOffset(page) + halfScreenSize);
float scrollProgress=delta / (totalDistance * 1.0f);
scrollProgress=Math.min(scrollProgress,1.0f);
scrollProgress=Math.max(scrollProgress,-1.0f);
return scrollProgress;
}
private float overScrollInfluenceCurve(float f){
f-=1.0f;
return f * f * f + 1.0f;
}
protected void acceleratedOverScroll(float amount){
int screenSize=getMeasuredWidth();
float f=OVERSCROLL_ACCELERATE_FACTOR * (amount / screenSize);
if (f == 0) return;
if (Math.abs(f) >= 1) {
f/=Math.abs(f);
}
int overScrollAmount=(int)Math.round(f * screenSize);
if (amount < 0) {
mOverScrollX=overScrollAmount;
mScrollX=0;
}
 else {
mOverScrollX=mMaxScrollX + overScrollAmount;
mScrollX=mMaxScrollX;
}
invalidate();
}
protected void dampedOverScroll(float amount){
int screenSize=getMeasuredWidth();
float f=(amount / screenSize);
if (f == 0) return;
f=f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
if (Math.abs(f) >= 1) {
f/=Math.abs(f);
}
int overScrollAmount=(int)Math.round(OVERSCROLL_DAMP_FACTOR * f * screenSize);
if (amount < 0) {
mOverScrollX=overScrollAmount;
mScrollX=0;
}
 else {
mOverScrollX=mMaxScrollX + overScrollAmount;
mScrollX=mMaxScrollX;
}
invalidate();
}
protected void overScroll(float amount){
dampedOverScroll(amount);
}
protected float maxOverScroll(){
float f=1.0f;
f=f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
return OVERSCROLL_DAMP_FACTOR * f;
}
@Override public boolean onTouchEvent(MotionEvent ev){
if (getChildCount() <= 0) return super.onTouchEvent(ev);
acquireVelocityTrackerAndAddMovement(ev);
final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
if (!mScroller.isFinished()) {
mScroller.abortAnimation();
}
mDownMotionX=mLastMotionX=ev.getX();
mLastMotionXRemainder=0;
mTotalMotionX=0;
mActivePointerId=ev.getPointerId(0);
if (mTouchState == TOUCH_STATE_SCROLLING) {
pageBeginMoving();
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
final float x=ev.getX(pointerIndex);
final float deltaX=mLastMotionX + mLastMotionXRemainder - x;
mTotalMotionX+=Math.abs(deltaX);
if (Math.abs(deltaX) >= 1.0f) {
mTouchX+=deltaX;
mSmoothingTime=System.nanoTime() / NANOTIME_DIV;
if (!mDeferScrollUpdate) {
scrollBy((int)deltaX,0);
if (DEBUG) Log.d(TAG,"onTouchEvent().Scrolling: " + deltaX);
}
 else {
invalidate();
}
mLastMotionX=x;
mLastMotionXRemainder=deltaX - (int)deltaX;
}
 else {
awakenScrollBars();
}
}
 else {
determineScrollingStart(ev);
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int activePointerId=mActivePointerId;
final int pointerIndex=ev.findPointerIndex(activePointerId);
final float x=ev.getX(pointerIndex);
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity(activePointerId);
final int deltaX=(int)(x - mDownMotionX);
boolean isSignificantMove=Math.abs(deltaX) > MIN_LENGTH_FOR_MOVE;
final int snapVelocity=mSnapVelocity;
mTotalMotionX+=Math.abs(mLastMotionX + mLastMotionXRemainder - x);
boolean returnToOriginalPage=false;
final int pageWidth=getScaledMeasuredWidth(getPageAt(mCurrentPage));
if (Math.abs(deltaX) > pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD && Math.signum(velocityX) != Math.signum(deltaX)) {
returnToOriginalPage=true;
}
boolean isFling=mTotalMotionX > MIN_LENGTH_FOR_FLING && Math.abs(velocityX) > snapVelocity;
int finalPage;
if (((isSignificantMove && deltaX > 0 && !isFling) || (isFling && velocityX > 0)) && mCurrentPage > 0) {
finalPage=returnToOriginalPage ? mCurrentPage : mCurrentPage - 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else if (((isSignificantMove && deltaX < 0 && !isFling) || (isFling && velocityX < 0)) && mCurrentPage < getChildCount() - 1) {
finalPage=returnToOriginalPage ? mCurrentPage : mCurrentPage + 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
int nextPage=Math.max(0,mCurrentPage - 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
int nextPage=Math.min(getChildCount() - 1,mCurrentPage + 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else {
onUnhandledTap(ev);
}
mTouchState=TOUCH_STATE_REST;
mActivePointerId=INVALID_POINTER;
releaseVelocityTracker();
break;
case MotionEvent.ACTION_CANCEL:
if (mTouchState == TOUCH_STATE_SCROLLING) {
snapToDestination();
}
mTouchState=TOUCH_STATE_REST;
mActivePointerId=INVALID_POINTER;
releaseVelocityTracker();
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}
@Override public boolean onGenericMotionEvent(MotionEvent event){
if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
switch (event.getAction()) {
case MotionEvent.ACTION_SCROLL:
{
final float vscroll;
final float hscroll;
if ((event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0) {
vscroll=0;
hscroll=event.getAxisValue(MotionEvent.AXIS_VSCROLL);
}
 else {
vscroll=-event.getAxisValue(MotionEvent.AXIS_VSCROLL);
hscroll=event.getAxisValue(MotionEvent.AXIS_HSCROLL);
}
if (hscroll != 0 || vscroll != 0) {
if (hscroll > 0 || vscroll > 0) {
scrollRight();
}
 else {
scrollLeft();
}
return true;
}
}
}
}
return super.onGenericMotionEvent(event);
}
private void acquireVelocityTrackerAndAddMovement(MotionEvent ev){
if (mVelocityTracker == null) {
mVelocityTracker=VelocityTracker.obtain();
}
mVelocityTracker.addMovement(ev);
}
private void releaseVelocityTracker(){
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
private void onSecondaryPointerUp(MotionEvent ev){
final int pointerIndex=(ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
final int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
final int newPointerIndex=pointerIndex == 0 ? 1 : 0;
mLastMotionX=mDownMotionX=ev.getX(newPointerIndex);
mLastMotionY=ev.getY(newPointerIndex);
mLastMotionXRemainder=0;
mActivePointerId=ev.getPointerId(newPointerIndex);
if (mVelocityTracker != null) {
mVelocityTracker.clear();
}
}
}
protected void onUnhandledTap(MotionEvent ev){
}
@Override public void requestChildFocus(View child,View focused){
super.requestChildFocus(child,focused);
int page=indexToPage(indexOfChild(child));
if (page >= 0 && page != getCurrentPage() && !isInTouchMode()) {
snapToPage(page);
}
}
protected int getChildIndexForRelativeOffset(int relativeOffset){
final int childCount=getChildCount();
int left;
int right;
for (int i=0; i < childCount; ++i) {
left=getRelativeChildOffset(i);
right=(left + getScaledMeasuredWidth(getPageAt(i)));
if (left <= relativeOffset && relativeOffset <= right) {
return i;
}
}
return -1;
}
protected int getChildWidth(int index){
final int measuredWidth=getPageAt(index).getMeasuredWidth();
final int minWidth=mMinimumWidth;
return (minWidth > measuredWidth) ? minWidth : measuredWidth;
}
int getPageNearestToCenterOfScreen(){
int minDistanceFromScreenCenter=Integer.MAX_VALUE;
int minDistanceFromScreenCenterIndex=-1;
int screenCenter=mScrollX + (getMeasuredWidth() / 2);
final int childCount=getChildCount();
for (int i=0; i < childCount; ++i) {
View layout=(View)getPageAt(i);
int childWidth=getScaledMeasuredWidth(layout);
int halfChildWidth=(childWidth / 2);
int childCenter=getChildOffset(i) + halfChildWidth;
int distanceFromScreenCenter=Math.abs(childCenter - screenCenter);
if (distanceFromScreenCenter < minDistanceFromScreenCenter) {
minDistanceFromScreenCenter=distanceFromScreenCenter;
minDistanceFromScreenCenterIndex=i;
}
}
return minDistanceFromScreenCenterIndex;
}
protected void snapToDestination(){
snapToPage(getPageNearestToCenterOfScreen(),PAGE_SNAP_ANIMATION_DURATION);
}
private static class ScrollInterpolator implements Interpolator {
public ScrollInterpolator(){
}
public float getInterpolation(float t){
t-=1.0f;
return t * t * t* t* t + 1;
}
}
float distanceInfluenceForSnapDuration(float f){
f-=0.5f;
f*=0.3f * Math.PI / 2.0f;
return (float)Math.sin(f);
}
protected void snapToPageWithVelocity(int whichPage,int velocity){
whichPage=Math.max(0,Math.min(whichPage,getChildCount() - 1));
int halfScreenSize=getMeasuredWidth() / 2;
if (DEBUG) Log.d(TAG,"snapToPage.getChildOffset(): " + getChildOffset(whichPage));
if (DEBUG) Log.d(TAG,"snapToPageWithVelocity.getRelativeChildOffset(): " + getMeasuredWidth() + ", "+ getChildWidth(whichPage));
final int newX=getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
int delta=newX - mUnboundedScrollX;
int duration=0;
if (Math.abs(velocity) < MIN_FLING_VELOCITY) {
snapToPage(whichPage,PAGE_SNAP_ANIMATION_DURATION);
return;
}
float distanceRatio=Math.min(1f,1.0f * Math.abs(delta) / (2 * halfScreenSize));
float distance=halfScreenSize + halfScreenSize * distanceInfluenceForSnapDuration(distanceRatio);
velocity=Math.abs(velocity);
velocity=Math.max(MINIMUM_SNAP_VELOCITY,velocity);
duration=4 * Math.round(1000 * Math.abs(distance / velocity));
snapToPage(whichPage,delta,duration);
}
protected void snapToPage(int whichPage){
snapToPage(whichPage,PAGE_SNAP_ANIMATION_DURATION);
}
protected void snapToPage(int whichPage,int duration){
whichPage=Math.max(0,Math.min(whichPage,getPageCount() - 1));
if (DEBUG) Log.d(TAG,"snapToPage.getChildOffset(): " + getChildOffset(whichPage));
if (DEBUG) Log.d(TAG,"snapToPage.getRelativeChildOffset(): " + getMeasuredWidth() + ", "+ getChildWidth(whichPage));
int newX=getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
final int sX=mUnboundedScrollX;
final int delta=newX - sX;
snapToPage(whichPage,delta,duration);
}
protected void snapToPage(int whichPage,int delta,int duration){
mNextPage=whichPage;
View focusedChild=getFocusedChild();
if (focusedChild != null && whichPage != mCurrentPage && focusedChild == getPageAt(mCurrentPage)) {
focusedChild.clearFocus();
}
pageBeginMoving();
awakenScrollBars(duration);
if (duration == 0) {
duration=Math.abs(delta);
}
if (!mScroller.isFinished()) mScroller.abortAnimation();
mScroller.startScroll(mUnboundedScrollX,0,delta,0,duration);
if (mDeferScrollUpdate) {
loadAssociatedPages(mNextPage);
}
 else {
mDeferLoadAssociatedPagesUntilScrollCompletes=true;
}
notifyPageSwitchListener();
invalidate();
}
public void scrollLeft(){
if (mScroller.isFinished()) {
if (mCurrentPage > 0) snapToPage(mCurrentPage - 1);
}
 else {
if (mNextPage > 0) snapToPage(mNextPage - 1);
}
}
public void scrollRight(){
if (mScroller.isFinished()) {
if (mCurrentPage < getChildCount() - 1) snapToPage(mCurrentPage + 1);
}
 else {
if (mNextPage < getChildCount() - 1) snapToPage(mNextPage + 1);
}
}
public int getPageForView(View v){
int result=-1;
if (v != null) {
ViewParent vp=v.getParent();
int count=getChildCount();
for (int i=0; i < count; i++) {
if (vp == getPageAt(i)) {
return i;
}
}
}
return result;
}
public boolean allowLongPress(){
return mAllowLongPress;
}
public void setAllowLongPress(boolean allowLongPress){
mAllowLongPress=allowLongPress;
}
public static class SavedState extends BaseSavedState {
int currentPage=-1;
SavedState(Parcelable superState){
super(superState);
}
private SavedState(Parcel in){
super(in);
currentPage=in.readInt();
}
@Override public void writeToParcel(Parcel out,int flags){
super.writeToParcel(out,flags);
out.writeInt(currentPage);
}
public static final Parcelable.Creator<SavedState> CREATOR=new Parcelable.Creator<SavedState>(){
public SavedState createFromParcel(Parcel in){
return new SavedState(in);
}
public SavedState[] newArray(int size){
return new SavedState[size];
}
}
;
}
protected void loadAssociatedPages(int page){
loadAssociatedPages(page,false);
}
protected void loadAssociatedPages(int page,boolean immediateAndOnly){
if (mContentIsRefreshable) {
final int count=getChildCount();
if (page < count) {
int lowerPageBound=getAssociatedLowerPageBound(page);
int upperPageBound=getAssociatedUpperPageBound(page);
if (DEBUG) Log.d(TAG,"loadAssociatedPages: " + lowerPageBound + "/"+ upperPageBound);
for (int i=0; i < count; ++i) {
if ((i != page) && immediateAndOnly) {
continue;
}
Page layout=(Page)getPageAt(i);
final int childCount=layout.getPageChildCount();
if (lowerPageBound <= i && i <= upperPageBound) {
if (mDirtyPageContent.get(i)) {
syncPageItems(i,(i == page) && immediateAndOnly);
mDirtyPageContent.set(i,false);
}
}
 else {
if (childCount > 0) {
layout.removeAllViewsOnPage();
}
mDirtyPageContent.set(i,true);
}
}
}
}
}
protected int getAssociatedLowerPageBound(int page){
return Math.max(0,page - 1);
}
protected int getAssociatedUpperPageBound(int page){
final int count=getChildCount();
return Math.min(page + 1,count - 1);
}
protected void startChoiceMode(int mode,ActionMode.Callback callback){
if (isChoiceMode(CHOICE_MODE_NONE)) {
mChoiceMode=mode;
mActionMode=startActionMode(callback);
}
}
public void endChoiceMode(){
if (!isChoiceMode(CHOICE_MODE_NONE)) {
mChoiceMode=CHOICE_MODE_NONE;
resetCheckedGrandchildren();
if (mActionMode != null) mActionMode.finish();
mActionMode=null;
}
}
protected boolean isChoiceMode(int mode){
return mChoiceMode == mode;
}
protected ArrayList<Checkable> getCheckedGrandchildren(){
ArrayList<Checkable> checked=new ArrayList<Checkable>();
final int childCount=getChildCount();
for (int i=0; i < childCount; ++i) {
Page layout=(Page)getPageAt(i);
final int grandChildCount=layout.getPageChildCount();
for (int j=0; j < grandChildCount; ++j) {
final View v=layout.getChildOnPageAt(j);
if (v instanceof Checkable && ((Checkable)v).isChecked()) {
checked.add((Checkable)v);
}
}
}
return checked;
}
protected Checkable getSingleCheckedGrandchild(){
if (mChoiceMode != CHOICE_MODE_MULTIPLE) {
final int childCount=getChildCount();
for (int i=0; i < childCount; ++i) {
Page layout=(Page)getPageAt(i);
final int grandChildCount=layout.getPageChildCount();
for (int j=0; j < grandChildCount; ++j) {
final View v=layout.getChildOnPageAt(j);
if (v instanceof Checkable && ((Checkable)v).isChecked()) {
return (Checkable)v;
}
}
}
}
return null;
}
protected void resetCheckedGrandchildren(){
final ArrayList<Checkable> checked=getCheckedGrandchildren();
for (int i=0; i < checked.size(); ++i) {
final Checkable c=checked.get(i);
c.setChecked(false);
}
}
public abstract void syncPages();
public abstract void syncPageItems(int page,boolean immediate);
protected void invalidatePageData(){
invalidatePageData(-1,false);
}
protected void invalidatePageData(int currentPage){
invalidatePageData(currentPage,false);
}
protected void invalidatePageData(int currentPage,boolean immediateAndOnly){
if (!mIsDataReady) {
return;
}
if (mContentIsRefreshable) {
mScroller.forceFinished(true);
mNextPage=INVALID_PAGE;
syncPages();
measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(getMeasuredHeight(),MeasureSpec.EXACTLY));
if (currentPage > -1) {
setCurrentPage(Math.min(getPageCount() - 1,currentPage));
}
final int count=getChildCount();
mDirtyPageContent.clear();
for (int i=0; i < count; ++i) {
mDirtyPageContent.add(true);
}
loadAssociatedPages(mCurrentPage,immediateAndOnly);
requestLayout();
}
}
protected ImageView getScrollingIndicator(){
if (mHasScrollIndicator && mScrollIndicator == null) {
ViewGroup parent=(ViewGroup)getParent();
mScrollIndicator=(ImageView)(parent.findViewById(R.id.paged_view_indicator));
mHasScrollIndicator=mScrollIndicator != null;
if (mHasScrollIndicator) {
mScrollIndicator.setVisibility(View.VISIBLE);
}
}
return mScrollIndicator;
}
protected boolean isScrollingIndicatorEnabled(){
return !LauncherApplication.isScreenLarge();
}
Runnable hideScrollingIndicatorRunnable=new Runnable(){
@Override public void run(){
hideScrollingIndicator(false);
}
}
;
protected void flashScrollingIndicator(){
removeCallbacks(hideScrollingIndicatorRunnable);
showScrollingIndicator(false);
postDelayed(hideScrollingIndicatorRunnable,sScrollIndicatorFlashDuration);
}
protected void showScrollingIndicator(boolean immediately){
if (getChildCount() <= 1) return;
if (!isScrollingIndicatorEnabled()) return;
getScrollingIndicator();
if (mScrollIndicator != null) {
updateScrollingIndicatorPosition();
mScrollIndicator.setVisibility(View.VISIBLE);
cancelScrollingIndicatorAnimations();
if (immediately) {
mScrollIndicator.setAlpha(1f);
}
 else {
mScrollIndicatorAnimator=ObjectAnimator.ofFloat(mScrollIndicator,"alpha",1f);
mScrollIndicatorAnimator.setDuration(sScrollIndicatorFadeInDuration);
mScrollIndicatorAnimator.start();
}
}
}
protected void cancelScrollingIndicatorAnimations(){
if (mScrollIndicatorAnimator != null) {
mScrollIndicatorAnimator.cancel();
}
}
protected void hideScrollingIndicator(boolean immediately){
if (getChildCount() <= 1) return;
if (!isScrollingIndicatorEnabled()) return;
getScrollingIndicator();
if (mScrollIndicator != null) {
updateScrollingIndicatorPosition();
cancelScrollingIndicatorAnimations();
if (immediately) {
mScrollIndicator.setVisibility(View.INVISIBLE);
mScrollIndicator.setAlpha(0f);
}
 else {
mScrollIndicatorAnimator=ObjectAnimator.ofFloat(mScrollIndicator,"alpha",0f);
mScrollIndicatorAnimator.setDuration(sScrollIndicatorFadeOutDuration);
mScrollIndicatorAnimator.addListener(new AnimatorListenerAdapter(){
private boolean cancelled=false;
@Override public void onAnimationCancel(android.animation.Animator animation){
cancelled=true;
}
@Override public void onAnimationEnd(Animator animation){
if (!cancelled) {
mScrollIndicator.setVisibility(View.INVISIBLE);
}
}
}
);
mScrollIndicatorAnimator.start();
}
}
}
protected boolean hasElasticScrollIndicator(){
return true;
}
private void updateScrollingIndicator(){
if (getChildCount() <= 1) return;
if (!isScrollingIndicatorEnabled()) return;
getScrollingIndicator();
if (mScrollIndicator != null) {
updateScrollingIndicatorPosition();
}
}
private void updateScrollingIndicatorPosition(){
if (!isScrollingIndicatorEnabled()) return;
if (mScrollIndicator == null) return;
int numPages=getChildCount();
int pageWidth=getMeasuredWidth();
int lastChildIndex=Math.max(0,getChildCount() - 1);
int maxScrollX=getChildOffset(lastChildIndex) - getRelativeChildOffset(lastChildIndex);
int trackWidth=pageWidth - mScrollIndicatorPaddingLeft - mScrollIndicatorPaddingRight;
int indicatorWidth=mScrollIndicator.getMeasuredWidth() - mScrollIndicator.getPaddingLeft() - mScrollIndicator.getPaddingRight();
float offset=Math.max(0f,Math.min(1f,(float)getScrollX() / maxScrollX));
int indicatorSpace=trackWidth / numPages;
int indicatorPos=(int)(offset * (trackWidth - indicatorSpace)) + mScrollIndicatorPaddingLeft;
if (hasElasticScrollIndicator()) {
if (mScrollIndicator.getMeasuredWidth() != indicatorSpace) {
mScrollIndicator.getLayoutParams().width=indicatorSpace;
mScrollIndicator.requestLayout();
}
}
 else {
int indicatorCenterOffset=indicatorSpace / 2 - indicatorWidth / 2;
indicatorPos+=indicatorCenterOffset;
}
mScrollIndicator.setTranslationX(indicatorPos);
mScrollIndicator.invalidate();
}
public void showScrollIndicatorTrack(){
}
public void hideScrollIndicatorTrack(){
}
@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
super.onInitializeAccessibilityNodeInfo(info);
info.setScrollable(true);
}
@Override public void onInitializeAccessibilityEvent(AccessibilityEvent event){
super.onInitializeAccessibilityEvent(event);
event.setScrollable(true);
if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SCROLLED) {
event.setFromIndex(mCurrentPage);
event.setToIndex(mCurrentPage);
event.setItemCount(getChildCount());
}
}
protected String getCurrentPageDescription(){
int page=(mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
return String.format(mContext.getString(R.string.default_scroll_format),page + 1,getChildCount());
}
@Override public boolean onHoverEvent(android.view.MotionEvent event){
return true;
}
}
