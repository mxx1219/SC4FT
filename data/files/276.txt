package android.webkit;
import android.annotation.Widget;
import android.app.AlertDialog;
import android.content.BroadcastReceiver;
import android.content.ClipboardManager;
import android.content.ComponentCallbacks2;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.database.DataSetObserver;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.BitmapShader;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.DrawFilter;
import android.graphics.Paint;
import android.graphics.PaintFlagsDrawFilter;
import android.graphics.Picture;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Region;
import android.graphics.RegionIterator;
import android.graphics.Shader;
import android.graphics.drawable.Drawable;
import android.net.Proxy;
import android.net.ProxyProperties;
import android.net.Uri;
import android.net.http.SslCertificate;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.os.StrictMode;
import android.provider.Settings;
import android.speech.tts.TextToSpeech;
import android.util.AttributeSet;
import android.util.EventLog;
import android.util.Log;
import android.view.Gravity;
import android.view.HardwareCanvas;
import android.view.InputDevice;
import android.view.KeyCharacterMap;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.SoundEffectConstants;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.view.ViewTreeObserver;
import android.view.accessibility.AccessibilityManager;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputConnection;
import android.view.inputmethod.InputMethodManager;
import android.webkit.WebTextView.AutoCompleteAdapter;
import android.webkit.WebViewCore.DrawData;
import android.webkit.WebViewCore.EventHub;
import android.webkit.WebViewCore.TouchEventData;
import android.webkit.WebViewCore.TouchHighlightData;
import android.widget.AbsoluteLayout;
import android.widget.Adapter;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.CheckedTextView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.OverScroller;
import android.widget.Toast;
import junit.framework.Assert;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
@Widget public class WebView extends AbsoluteLayout implements ViewTreeObserver.OnGlobalFocusChangeListener, ViewGroup.OnHierarchyChangeListener {
private class InnerGlobalLayoutListener implements ViewTreeObserver.OnGlobalLayoutListener {
    public void onGlobalLayout(){
      if (isShown()) {
        setGLRectViewport();
      }
    }
  }
private class InnerScrollChangedListener implements ViewTreeObserver.OnScrollChangedListener {
    public void onScrollChanged(){
      if (isShown()) {
        setGLRectViewport();
      }
    }
  }
  private InnerGlobalLayoutListener mGlobalLayoutListener=null;
  private InnerScrollChangedListener mScrollChangedListener=null;
  static private final boolean AUTO_REDRAW_HACK=false;
  private boolean mAutoRedraw;
  private AlertDialog mListBoxDialog=null;
  static final String LOGTAG="webview";
  private ZoomManager mZoomManager;
  private final Rect mGLRectViewport=new Rect();
  private final Rect mViewRectViewport=new Rect();
  private boolean mGLViewportEmpty=false;
public class WebViewTransport {
    private WebView mWebview;
    public synchronized void setWebView(    WebView webview){
      mWebview=webview;
    }
    public synchronized WebView getWebView(){
      return mWebview;
    }
  }
private static class OnTrimMemoryListener implements ComponentCallbacks2 {
    private static OnTrimMemoryListener sInstance=null;
    static void init(    Context c){
      if (sInstance == null) {
        sInstance=new OnTrimMemoryListener(c.getApplicationContext());
      }
    }
    private OnTrimMemoryListener(    Context c){
      c.registerComponentCallbacks(this);
    }
    @Override public void onConfigurationChanged(    Configuration newConfig){
    }
    @Override public void onLowMemory(){
    }
    @Override public void onTrimMemory(    int level){
      if (DebugFlags.WEB_VIEW) {
        Log.d("WebView","onTrimMemory: " + level);
      }
      WebView.nativeOnTrimMemory(level);
    }
  }
  private final CallbackProxy mCallbackProxy;
  private final WebViewDatabase mDatabase;
  private SslCertificate mCertificate;
  private int mNativeClass;
  private WebViewCore mWebViewCore;
  final Handler mPrivateHandler=new PrivateHandler();
  private WebTextView mWebTextView;
  private int mTextGeneration;
  void incrementTextGeneration(){
    mTextGeneration++;
  }
  final ViewManager mViewManager;
  PluginFullScreenHolder mFullScreenHolder;
  private int mLastTouchX;
  private int mLastTouchY;
  private int mStartTouchX;
  private int mStartTouchY;
  private float mAverageAngle;
  private long mLastTouchTime;
  private long mLastSentTouchTime;
  private static final int TOUCH_SENT_INTERVAL=0;
  private int mCurrentTouchInterval=TOUCH_SENT_INTERVAL;
  VelocityTracker mVelocityTracker;
  private int mMaximumFling;
  private float mLastVelocity;
  private float mLastVelX;
  private float mLastVelY;
  private int mScrollingLayer;
  private Rect mScrollingLayerRect=new Rect();
  private static final float MINIMUM_VELOCITY_RATIO_FOR_ACCELERATION=0.2f;
  private int mTouchMode=TOUCH_DONE_MODE;
  private static final int TOUCH_INIT_MODE=1;
  private static final int TOUCH_DRAG_START_MODE=2;
  private static final int TOUCH_DRAG_MODE=3;
  private static final int TOUCH_SHORTPRESS_START_MODE=4;
  private static final int TOUCH_SHORTPRESS_MODE=5;
  private static final int TOUCH_DOUBLE_TAP_MODE=6;
  private static final int TOUCH_DONE_MODE=7;
  private static final int TOUCH_PINCH_DRAG=8;
  private static final int TOUCH_DRAG_LAYER_MODE=9;
  private boolean mForwardTouchEvents=false;
  private static final int PREVENT_DEFAULT_NO=0;
  private static final int PREVENT_DEFAULT_MAYBE_YES=1;
  private static final int PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN=2;
  private static final int PREVENT_DEFAULT_YES=3;
  private static final int PREVENT_DEFAULT_IGNORE=4;
  private int mPreventDefault=PREVENT_DEFAULT_IGNORE;
  private boolean mConfirmMove;
  private boolean mDeferTouchProcess;
  private int mDeferTouchMode=TOUCH_DONE_MODE;
  private float mLastDeferTouchX;
  private float mLastDeferTouchY;
  boolean mDragFromTextInput;
  private boolean mDrawCursorRing=true;
  private boolean mIsPaused;
  private HitTestResult mInitialHitTestResult;
  private int mTouchSlopSquare;
  private int mDoubleTapSlopSquare;
  private int mNavSlop;
  private static final int TAP_TIMEOUT=300;
  private static final int LONG_PRESS_TIMEOUT=1000;
  private static final int MIN_FLING_TIME=250;
  private static final int MOTIONLESS_TIME=100;
  private static final int PAGE_SCROLL_OVERLAP=24;
  boolean mWidthCanMeasure;
  boolean mHeightCanMeasure;
  int mLastWidthSent;
  int mLastHeightSent;
  int mLastActualHeightSent;
  private int mContentWidth;
  private int mContentHeight;
  private boolean mOverlayHorizontalScrollbar=true;
  private boolean mOverlayVerticalScrollbar=false;
  private static final int STD_SPEED=480;
  private static final int MAX_DURATION=750;
  private static final int SLIDE_TITLE_DURATION=500;
  OverScroller mScroller;
  private boolean mInOverScrollMode=false;
  private static Paint mOverScrollBackground;
  private static Paint mOverScrollBorder;
  private boolean mWrapContent;
  private static final int MOTIONLESS_FALSE=0;
  private static final int MOTIONLESS_PENDING=1;
  private static final int MOTIONLESS_TRUE=2;
  private static final int MOTIONLESS_IGNORE=3;
  private int mHeldMotionless;
  private AccessibilityInjector mAccessibilityInjector;
  private boolean mAccessibilityScriptInjected;
  static final boolean USE_JAVA_TEXT_SELECTION=true;
  private Region mTextSelectionRegion=new Region();
  private Paint mTextSelectionPaint;
  private Drawable mSelectHandleLeft;
  private Drawable mSelectHandleRight;
  static final boolean USE_WEBKIT_RINGS=true;
  private static final int HIGHLIGHT_COLOR=0x6633b5e5;
  private static final float TOUCH_HIGHLIGHT_ARC=5.0f;
  private Region mTouchHighlightRegion=new Region();
  private Paint mTouchHightlightPaint;
  private static final boolean DEBUG_TOUCH_HIGHLIGHT=true;
  private static final int TOUCH_HIGHLIGHT_ELAPSE_TIME=2000;
  private Paint mTouchCrossHairColor;
  private int mTouchHighlightX;
  private int mTouchHighlightY;
  private long mTouchHighlightRequested;
  private HTML5VideoViewProxy mHTML5VideoViewProxy;
  private boolean mBlockWebkitViewMessages=false;
  private boolean mHardwareAccelSkia=false;
  private static final int REMEMBER_PASSWORD=1;
  private static final int NEVER_REMEMBER_PASSWORD=2;
  private static final int SWITCH_TO_SHORTPRESS=3;
  private static final int SWITCH_TO_LONGPRESS=4;
  private static final int RELEASE_SINGLE_TAP=5;
  private static final int REQUEST_FORM_DATA=6;
  private static final int RESUME_WEBCORE_PRIORITY=7;
  private static final int DRAG_HELD_MOTIONLESS=8;
  private static final int AWAKEN_SCROLL_BARS=9;
  private static final int PREVENT_DEFAULT_TIMEOUT=10;
  private static final int SCROLL_SELECT_TEXT=11;
  private static final int FIRST_PRIVATE_MSG_ID=REMEMBER_PASSWORD;
  private static final int LAST_PRIVATE_MSG_ID=SCROLL_SELECT_TEXT;
  static final int SCROLL_TO_MSG_ID=101;
  static final int NEW_PICTURE_MSG_ID=105;
  static final int UPDATE_TEXT_ENTRY_MSG_ID=106;
  static final int WEBCORE_INITIALIZED_MSG_ID=107;
  static final int UPDATE_TEXTFIELD_TEXT_MSG_ID=108;
  static final int UPDATE_ZOOM_RANGE=109;
  static final int UNHANDLED_NAV_KEY=110;
  static final int CLEAR_TEXT_ENTRY=111;
  static final int UPDATE_TEXT_SELECTION_MSG_ID=112;
  static final int SHOW_RECT_MSG_ID=113;
  static final int LONG_PRESS_CENTER=114;
  static final int PREVENT_TOUCH_ID=115;
  static final int WEBCORE_NEED_TOUCH_EVENTS=116;
  static final int INVAL_RECT_MSG_ID=117;
  static final int REQUEST_KEYBOARD=118;
  static final int DO_MOTION_UP=119;
  static final int SHOW_FULLSCREEN=120;
  static final int HIDE_FULLSCREEN=121;
  static final int DOM_FOCUS_CHANGED=122;
  static final int REPLACE_BASE_CONTENT=123;
  static final int FORM_DID_BLUR=124;
  static final int RETURN_LABEL=125;
  static final int FIND_AGAIN=126;
  static final int CENTER_FIT_RECT=127;
  static final int REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID=128;
  static final int SET_SCROLLBAR_MODES=129;
  static final int SELECTION_STRING_CHANGED=130;
  static final int SET_TOUCH_HIGHLIGHT_RECTS=131;
  static final int SAVE_WEBARCHIVE_FINISHED=132;
  static final int SET_AUTOFILLABLE=133;
  static final int AUTOFILL_COMPLETE=134;
  static final int SELECT_AT=135;
  static final int SCREEN_ON=136;
  static final int ENTER_FULLSCREEN_VIDEO=137;
  private static final int FIRST_PACKAGE_MSG_ID=SCROLL_TO_MSG_ID;
  private static final int LAST_PACKAGE_MSG_ID=SET_TOUCH_HIGHLIGHT_RECTS;
  static final String[] HandlerPrivateDebugString={"REMEMBER_PASSWORD","NEVER_REMEMBER_PASSWORD","SWITCH_TO_SHORTPRESS","SWITCH_TO_LONGPRESS","RELEASE_SINGLE_TAP","REQUEST_FORM_DATA","RESUME_WEBCORE_PRIORITY","DRAG_HELD_MOTIONLESS","AWAKEN_SCROLL_BARS","PREVENT_DEFAULT_TIMEOUT","SCROLL_SELECT_TEXT"};
  static final String[] HandlerPackageDebugString={"SCROLL_TO_MSG_ID","102","103","104","NEW_PICTURE_MSG_ID","UPDATE_TEXT_ENTRY_MSG_ID","WEBCORE_INITIALIZED_MSG_ID","UPDATE_TEXTFIELD_TEXT_MSG_ID","UPDATE_ZOOM_RANGE","UNHANDLED_NAV_KEY","CLEAR_TEXT_ENTRY","UPDATE_TEXT_SELECTION_MSG_ID","SHOW_RECT_MSG_ID","LONG_PRESS_CENTER","PREVENT_TOUCH_ID","WEBCORE_NEED_TOUCH_EVENTS","INVAL_RECT_MSG_ID","REQUEST_KEYBOARD","DO_MOTION_UP","SHOW_FULLSCREEN","HIDE_FULLSCREEN","DOM_FOCUS_CHANGED","REPLACE_BASE_CONTENT","FORM_DID_BLUR","RETURN_LABEL","FIND_AGAIN","CENTER_FIT_RECT","REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID","SET_SCROLLBAR_MODES","SELECTION_STRING_CHANGED","SET_TOUCH_HIGHLIGHT_RECTS","SAVE_WEBARCHIVE_FINISHED","SET_AUTOFILLABLE","AUTOFILL_COMPLETE","SELECT_AT","SCREEN_ON","ENTER_FULLSCREEN_VIDEO"};
  static final int DEFAULT_VIEWPORT_WIDTH=980;
  static int sMaxViewportWidth=DEFAULT_VIEWPORT_WIDTH;
  private int mInitialScaleInPercent=0;
  private boolean mSendScrollEvent=true;
  private int mSnapScrollMode=SNAP_NONE;
  private static final int SNAP_NONE=0;
  private static final int SNAP_LOCK=1;
  private static final int SNAP_X=2;
  private static final int SNAP_Y=4;
  private boolean mSnapPositive;
  private static final int DRAW_EXTRAS_NONE=0;
  private static final int DRAW_EXTRAS_FIND=1;
  private static final int DRAW_EXTRAS_SELECTION=2;
  private static final int DRAW_EXTRAS_CURSOR_RING=3;
  private static final int SCROLLBAR_AUTO=0;
  private static final int SCROLLBAR_ALWAYSOFF=1;
  private static final int SCROLLBAR_ALWAYSON=2;
  private int mHorizontalScrollBarMode=SCROLLBAR_AUTO;
  private int mVerticalScrollBarMode=SCROLLBAR_AUTO;
  private static final int ACCESSIBILITY_SCRIPT_INJECTION_UNDEFINED=-1;
  private static final int ACCESSIBILITY_SCRIPT_INJECTION_OPTED_OUT=0;
  private static final int ACCESSIBILITY_SCRIPT_INJECTION_PROVIDED=1;
  private static final String ALIAS_ACCESSIBILITY_JS_INTERFACE="accessibility";
  private static final String ACCESSIBILITY_SCRIPT_CHOOSER_JAVASCRIPT="javascript:(function() {" + "    var chooser = document.createElement('script');" + "    chooser.type = 'text/javascript';"+ "    chooser.src = 'https://ssl.gstatic.com/accessibility/javascript/android/AndroidScriptChooser.user.js';"+ "    document.getElementsByTagName('head')[0].appendChild(chooser);"+ "  })();";
  private static final String PATTERN_MATCH_AXS_URL_PARAMETER="(\\?axs=(0|1))|(&axs=(0|1))";
  private TextToSpeech mTextToSpeech;
  private Pattern mMatchAxsUrlParameterPattern;
  private int mOverscrollDistance;
  private int mOverflingDistance;
  private OverScrollGlow mOverScrollGlow;
  private Vector<Integer> mKeysPressed;
  static boolean mLogEvent=true;
  private long mLastTouchUpTime=0;
  private WebViewCore.AutoFillData mAutoFillData;
  private static boolean sNotificationsEnabled=true;
  public static final String SCHEME_TEL="tel:";
  public static final String SCHEME_MAILTO="mailto:";
  public static final String SCHEME_GEO="geo:0,0?q=";
  private int mBackgroundColor=Color.WHITE;
  private static final long SELECT_SCROLL_INTERVAL=1000 / 60;
  private int mAutoScrollX=0;
  private int mAutoScrollY=0;
  private int mMinAutoScrollX=0;
  private int mMaxAutoScrollX=0;
  private int mMinAutoScrollY=0;
  private int mMaxAutoScrollY=0;
  private Rect mScrollingLayerBounds=new Rect();
  private boolean mSentAutoScrollMessage=false;
  private final TouchEventQueue mTouchEventQueue=new TouchEventQueue();
  private PictureListener mPictureListener;
@Deprecated public interface PictureListener {
    @Deprecated public void onNewPicture(    WebView view,    Picture picture);
  }
public class HitTestResult {
    public static final int UNKNOWN_TYPE=0;
    @Deprecated public static final int ANCHOR_TYPE=1;
    public static final int PHONE_TYPE=2;
    public static final int GEO_TYPE=3;
    public static final int EMAIL_TYPE=4;
    public static final int IMAGE_TYPE=5;
    @Deprecated public static final int IMAGE_ANCHOR_TYPE=6;
    public static final int SRC_ANCHOR_TYPE=7;
    public static final int SRC_IMAGE_ANCHOR_TYPE=8;
    public static final int EDIT_TEXT_TYPE=9;
    private int mType;
    private String mExtra;
    HitTestResult(){
      mType=UNKNOWN_TYPE;
    }
    private void setType(    int type){
      mType=type;
    }
    private void setExtra(    String extra){
      mExtra=extra;
    }
    public int getType(){
      return mType;
    }
    public String getExtra(){
      return mExtra;
    }
  }
  public WebView(  Context context){
    this(context,null);
  }
  public WebView(  Context context,  AttributeSet attrs){
    this(context,attrs,com.android.internal.R.attr.webViewStyle);
  }
  public WebView(  Context context,  AttributeSet attrs,  int defStyle){
    this(context,attrs,defStyle,false);
  }
  public WebView(  Context context,  AttributeSet attrs,  int defStyle,  boolean privateBrowsing){
    this(context,attrs,defStyle,null,privateBrowsing);
  }
  protected WebView(  Context context,  AttributeSet attrs,  int defStyle,  Map<String,Object> javaScriptInterfaces,  boolean privateBrowsing){
    super(context,attrs,defStyle);
    checkThread();
    JniUtil.setContext(context);
    mCallbackProxy=new CallbackProxy(context,this);
    mViewManager=new ViewManager(this);
    L10nUtils.setApplicationContext(context.getApplicationContext());
    mWebViewCore=new WebViewCore(context,this,mCallbackProxy,javaScriptInterfaces);
    mDatabase=WebViewDatabase.getInstance(context);
    mScroller=new OverScroller(context,null,0,0,false);
    mZoomManager=new ZoomManager(this,mCallbackProxy);
    init();
    setupPackageListener(context);
    setupProxyListener(context);
    updateMultiTouchSupport(context);
    if (privateBrowsing) {
      startPrivateBrowsing();
    }
    mAutoFillData=new WebViewCore.AutoFillData();
  }
private static class ProxyReceiver extends BroadcastReceiver {
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(Proxy.PROXY_CHANGE_ACTION)) {
        handleProxyBroadcast(intent);
      }
    }
  }
  private static ProxyReceiver sProxyReceiver;
  private static synchronized void setupProxyListener(  Context context){
    if (sProxyReceiver != null || sNotificationsEnabled == false) {
      return;
    }
    IntentFilter filter=new IntentFilter();
    filter.addAction(Proxy.PROXY_CHANGE_ACTION);
    sProxyReceiver=new ProxyReceiver();
    Intent currentProxy=context.getApplicationContext().registerReceiver(sProxyReceiver,filter);
    if (currentProxy != null) {
      handleProxyBroadcast(currentProxy);
    }
  }
  private static synchronized void disableProxyListener(  Context context){
    if (sProxyReceiver == null)     return;
    context.getApplicationContext().unregisterReceiver(sProxyReceiver);
    sProxyReceiver=null;
  }
  private static void handleProxyBroadcast(  Intent intent){
    ProxyProperties proxyProperties=(ProxyProperties)intent.getExtra(Proxy.EXTRA_PROXY_INFO);
    if (proxyProperties == null || proxyProperties.getHost() == null) {
      WebViewCore.sendStaticMessage(EventHub.PROXY_CHANGED,null);
      return;
    }
    WebViewCore.sendStaticMessage(EventHub.PROXY_CHANGED,proxyProperties);
  }
  private static boolean sPackageInstallationReceiverAdded=false;
  private static Set<String> sGoogleApps;
static {
    sGoogleApps=new HashSet<String>();
    sGoogleApps.add("com.google.android.youtube");
  }
private static class PackageListener extends BroadcastReceiver {
    @Override public void onReceive(    Context context,    Intent intent){
      final String action=intent.getAction();
      final String packageName=intent.getData().getSchemeSpecificPart();
      final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
      if (Intent.ACTION_PACKAGE_REMOVED.equals(action) && replacing) {
        return;
      }
      if (sGoogleApps.contains(packageName)) {
        if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
          WebViewCore.sendStaticMessage(EventHub.ADD_PACKAGE_NAME,packageName);
        }
 else {
          WebViewCore.sendStaticMessage(EventHub.REMOVE_PACKAGE_NAME,packageName);
        }
      }
      PluginManager pm=PluginManager.getInstance(context);
      if (pm.containsPluginPermissionAndSignatures(packageName)) {
        pm.refreshPlugins(Intent.ACTION_PACKAGE_ADDED.equals(action));
      }
    }
  }
  private void setupPackageListener(  Context context){
synchronized (WebView.class) {
      if (sPackageInstallationReceiverAdded) {
        return;
      }
      IntentFilter filter=new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme("package");
      BroadcastReceiver packageListener=new PackageListener();
      context.getApplicationContext().registerReceiver(packageListener,filter);
      sPackageInstallationReceiverAdded=true;
    }
    AsyncTask<Void,Void,Set<String>> task=new AsyncTask<Void,Void,Set<String>>(){
      @Override protected Set<String> doInBackground(      Void... unused){
        Set<String> installedPackages=new HashSet<String>();
        PackageManager pm=mContext.getPackageManager();
        for (        String name : sGoogleApps) {
          try {
            PackageInfo pInfo=pm.getPackageInfo(name,PackageManager.GET_ACTIVITIES | PackageManager.GET_SERVICES);
            installedPackages.add(name);
          }
 catch (          PackageManager.NameNotFoundException e) {
          }
        }
        return installedPackages;
      }
      @Override protected void onPostExecute(      Set<String> installedPackages){
        if (mWebViewCore != null) {
          mWebViewCore.sendMessage(EventHub.ADD_PACKAGE_NAMES,installedPackages);
        }
      }
    }
;
    task.execute();
  }
  void updateMultiTouchSupport(  Context context){
    mZoomManager.updateMultiTouchSupport(context);
  }
  private void init(){
    OnTrimMemoryListener.init(getContext());
    setWillNotDraw(false);
    setFocusable(true);
    setFocusableInTouchMode(true);
    setClickable(true);
    setLongClickable(true);
    final ViewConfiguration configuration=ViewConfiguration.get(getContext());
    int slop=configuration.getScaledTouchSlop();
    mTouchSlopSquare=slop * slop;
    slop=configuration.getScaledDoubleTapSlop();
    mDoubleTapSlopSquare=slop * slop;
    final float density=getContext().getResources().getDisplayMetrics().density;
    mNavSlop=(int)(16 * density);
    mZoomManager.init(density);
    mMaximumFling=configuration.getScaledMaximumFlingVelocity();
    DRAG_LAYER_INVERSE_DENSITY_SQUARED=1 / (density * density);
    mOverscrollDistance=configuration.getScaledOverscrollDistance();
    mOverflingDistance=configuration.getScaledOverflingDistance();
    setScrollBarStyle(super.getScrollBarStyle());
    mKeysPressed=new Vector<Integer>(2);
    mHTML5VideoViewProxy=null;
  }
  @Override public boolean shouldDelayChildPressedState(){
    return true;
  }
  private void addAccessibilityApisToJavaScript(){
    if (AccessibilityManager.getInstance(mContext).isEnabled() && getSettings().getJavaScriptEnabled()) {
      mTextToSpeech=new TextToSpeech(getContext(),null);
      addJavascriptInterface(mTextToSpeech,ALIAS_ACCESSIBILITY_JS_INTERFACE);
    }
  }
  private void removeAccessibilityApisFromJavaScript(){
    if (mTextToSpeech != null) {
      removeJavascriptInterface(ALIAS_ACCESSIBILITY_JS_INTERFACE);
      mTextToSpeech.shutdown();
      mTextToSpeech=null;
    }
  }
  @Override public void setOverScrollMode(  int mode){
    super.setOverScrollMode(mode);
    if (mode != OVER_SCROLL_NEVER) {
      if (mOverScrollGlow == null) {
        mOverScrollGlow=new OverScrollGlow(this);
      }
    }
 else {
      mOverScrollGlow=null;
    }
  }
  void updateDefaultZoomDensity(  int zoomDensity){
    final float density=mContext.getResources().getDisplayMetrics().density * 100 / zoomDensity;
    mNavSlop=(int)(16 * density);
    mZoomManager.updateDefaultZoomDensity(density);
  }
  boolean onSavePassword(  String schemePlusHost,  String username,  String password,  final Message resumeMsg){
    boolean rVal=false;
    if (resumeMsg == null) {
      mDatabase.setUsernamePassword(schemePlusHost,username,password);
    }
 else {
      final Message remember=mPrivateHandler.obtainMessage(REMEMBER_PASSWORD);
      remember.getData().putString("host",schemePlusHost);
      remember.getData().putString("username",username);
      remember.getData().putString("password",password);
      remember.obj=resumeMsg;
      final Message neverRemember=mPrivateHandler.obtainMessage(NEVER_REMEMBER_PASSWORD);
      neverRemember.getData().putString("host",schemePlusHost);
      neverRemember.getData().putString("username",username);
      neverRemember.getData().putString("password",password);
      neverRemember.obj=resumeMsg;
      new AlertDialog.Builder(getContext()).setTitle(com.android.internal.R.string.save_password_label).setMessage(com.android.internal.R.string.save_password_message).setPositiveButton(com.android.internal.R.string.save_password_notnow,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          resumeMsg.sendToTarget();
        }
      }
).setNeutralButton(com.android.internal.R.string.save_password_remember,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          remember.sendToTarget();
        }
      }
).setNegativeButton(com.android.internal.R.string.save_password_never,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          neverRemember.sendToTarget();
        }
      }
).setOnCancelListener(new OnCancelListener(){
        public void onCancel(        DialogInterface dialog){
          resumeMsg.sendToTarget();
        }
      }
).show();
      rVal=true;
    }
    return rVal;
  }
  @Override public void setScrollBarStyle(  int style){
    if (style == View.SCROLLBARS_INSIDE_INSET || style == View.SCROLLBARS_OUTSIDE_INSET) {
      mOverlayHorizontalScrollbar=mOverlayVerticalScrollbar=false;
    }
 else {
      mOverlayHorizontalScrollbar=mOverlayVerticalScrollbar=true;
    }
    super.setScrollBarStyle(style);
  }
  public void setHorizontalScrollbarOverlay(  boolean overlay){
    checkThread();
    mOverlayHorizontalScrollbar=overlay;
  }
  public void setVerticalScrollbarOverlay(  boolean overlay){
    checkThread();
    mOverlayVerticalScrollbar=overlay;
  }
  public boolean overlayHorizontalScrollbar(){
    checkThread();
    return mOverlayHorizontalScrollbar;
  }
  public boolean overlayVerticalScrollbar(){
    checkThread();
    return mOverlayVerticalScrollbar;
  }
  int getViewWidth(){
    if (!isVerticalScrollBarEnabled() || mOverlayVerticalScrollbar) {
      return getWidth();
    }
 else {
      return Math.max(0,getWidth() - getVerticalScrollbarWidth());
    }
  }
  protected int getTitleHeight(){
    return mTitleBar != null ? mTitleBar.getHeight() : 0;
  }
  public int getVisibleTitleHeight(){
    checkThread();
    return getVisibleTitleHeightImpl();
  }
  private int getVisibleTitleHeightImpl(){
    return Math.max(getTitleHeight() - Math.max(0,mScrollY),0);
  }
  int getViewHeight(){
    return getViewHeightWithTitle() - getVisibleTitleHeightImpl();
  }
  int getViewHeightWithTitle(){
    int height=getHeight();
    if (isHorizontalScrollBarEnabled() && !mOverlayHorizontalScrollbar) {
      height-=getHorizontalScrollbarHeight();
    }
    return height;
  }
  public SslCertificate getCertificate(){
    checkThread();
    return mCertificate;
  }
  public void setCertificate(  SslCertificate certificate){
    checkThread();
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,"setCertificate=" + certificate);
    }
    mCertificate=certificate;
  }
  public void savePassword(  String host,  String username,  String password){
    checkThread();
    mDatabase.setUsernamePassword(host,username,password);
  }
  public void setHttpAuthUsernamePassword(  String host,  String realm,  String username,  String password){
    checkThread();
    mDatabase.setHttpAuthUsernamePassword(host,realm,username,password);
  }
  public String[] getHttpAuthUsernamePassword(  String host,  String realm){
    checkThread();
    return mDatabase.getHttpAuthUsernamePassword(host,realm);
  }
  private void clearActionModes(){
    if (mSelectCallback != null) {
      mSelectCallback.finish();
    }
    if (mFindCallback != null) {
      mFindCallback.finish();
    }
  }
  private void clearHelpers(){
    clearTextEntry();
    clearActionModes();
    dismissFullScreenMode();
  }
  public void destroy(){
    checkThread();
    destroyImpl();
  }
  private void destroyImpl(){
    clearHelpers();
    if (mListBoxDialog != null) {
      mListBoxDialog.dismiss();
      mListBoxDialog=null;
    }
    if (mNativeClass != 0)     nativeStopGL();
    if (mWebViewCore != null) {
      mCallbackProxy.setWebViewClient(null);
      mCallbackProxy.setWebChromeClient(null);
synchronized (this) {
        WebViewCore webViewCore=mWebViewCore;
        mWebViewCore=null;
        webViewCore.destroy();
      }
      mPrivateHandler.removeCallbacksAndMessages(null);
      mCallbackProxy.removeCallbacksAndMessages(null);
synchronized (mCallbackProxy) {
        mCallbackProxy.notify();
      }
    }
    if (mNativeClass != 0) {
      nativeDestroy();
      mNativeClass=0;
    }
  }
  @Deprecated public static void enablePlatformNotifications(){
    checkThread();
synchronized (WebView.class) {
      Network.enablePlatformNotifications();
      sNotificationsEnabled=true;
      Context context=JniUtil.getContext();
      if (context != null)       setupProxyListener(context);
    }
  }
  @Deprecated public static void disablePlatformNotifications(){
    checkThread();
synchronized (WebView.class) {
      Network.disablePlatformNotifications();
      sNotificationsEnabled=false;
      Context context=JniUtil.getContext();
      if (context != null)       disableProxyListener(context);
    }
  }
  public void setJsFlags(  String flags){
    checkThread();
    mWebViewCore.sendMessage(EventHub.SET_JS_FLAGS,flags);
  }
  public void setNetworkAvailable(  boolean networkUp){
    checkThread();
    mWebViewCore.sendMessage(EventHub.SET_NETWORK_STATE,networkUp ? 1 : 0,0);
  }
  public void setNetworkType(  String type,  String subtype){
    checkThread();
    Map<String,String> map=new HashMap<String,String>();
    map.put("type",type);
    map.put("subtype",subtype);
    mWebViewCore.sendMessage(EventHub.SET_NETWORK_TYPE,map);
  }
  public WebBackForwardList saveState(  Bundle outState){
    checkThread();
    if (outState == null) {
      return null;
    }
    WebBackForwardList list=copyBackForwardList();
    final int currentIndex=list.getCurrentIndex();
    final int size=list.getSize();
    if (currentIndex < 0 || currentIndex >= size || size == 0) {
      return null;
    }
    outState.putInt("index",currentIndex);
    ArrayList<byte[]> history=new ArrayList<byte[]>(size);
    for (int i=0; i < size; i++) {
      WebHistoryItem item=list.getItemAtIndex(i);
      if (null == item) {
        Log.w(LOGTAG,"saveState: Unexpected null history item.");
        return null;
      }
      byte[] data=item.getFlattenedData();
      if (data == null) {
        return null;
      }
      history.add(data);
    }
    outState.putSerializable("history",history);
    if (mCertificate != null) {
      outState.putBundle("certificate",SslCertificate.saveState(mCertificate));
    }
    outState.putBoolean("privateBrowsingEnabled",isPrivateBrowsingEnabled());
    mZoomManager.saveZoomState(outState);
    return list;
  }
  @Deprecated public boolean savePicture(  Bundle b,  final File dest){
    checkThread();
    if (dest == null || b == null) {
      return false;
    }
    final Picture p=capturePicture();
    final File temp=new File(dest.getPath() + ".writing");
    new Thread(new Runnable(){
      public void run(){
        FileOutputStream out=null;
        try {
          out=new FileOutputStream(temp);
          p.writeToStream(out);
          temp.renameTo(dest);
        }
 catch (        Exception e) {
        }
 finally {
          if (out != null) {
            try {
              out.close();
            }
 catch (            Exception e) {
            }
          }
          temp.delete();
        }
      }
    }
).start();
    b.putInt("scrollX",mScrollX);
    b.putInt("scrollY",mScrollY);
    mZoomManager.saveZoomState(b);
    return true;
  }
  private void restoreHistoryPictureFields(  Picture p,  Bundle b){
    int sx=b.getInt("scrollX",0);
    int sy=b.getInt("scrollY",0);
    mDrawHistory=true;
    mHistoryPicture=p;
    mScrollX=sx;
    mScrollY=sy;
    mZoomManager.restoreZoomState(b);
    final float scale=mZoomManager.getScale();
    mHistoryWidth=Math.round(p.getWidth() * scale);
    mHistoryHeight=Math.round(p.getHeight() * scale);
    invalidate();
  }
  @Deprecated public boolean restorePicture(  Bundle b,  File src){
    checkThread();
    if (src == null || b == null) {
      return false;
    }
    if (!src.exists()) {
      return false;
    }
    try {
      final FileInputStream in=new FileInputStream(src);
      final Bundle copy=new Bundle(b);
      new Thread(new Runnable(){
        public void run(){
          try {
            final Picture p=Picture.createFromStream(in);
            if (p != null) {
              mPrivateHandler.post(new Runnable(){
                public void run(){
                  restoreHistoryPictureFields(p,copy);
                }
              }
);
            }
          }
  finally {
            try {
              in.close();
            }
 catch (            Exception e) {
            }
          }
        }
      }
).start();
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
    return true;
  }
  public boolean saveViewState(  OutputStream stream){
    try {
      return ViewStateSerializer.serializeViewState(stream,this);
    }
 catch (    IOException e) {
      Log.w(LOGTAG,"Failed to saveViewState",e);
    }
    return false;
  }
  public boolean loadViewState(  InputStream stream){
    try {
      mLoadedPicture=ViewStateSerializer.deserializeViewState(stream,this);
      mBlockWebkitViewMessages=true;
      setNewPicture(mLoadedPicture,true);
      return true;
    }
 catch (    IOException e) {
      Log.w(LOGTAG,"Failed to loadViewState",e);
    }
    return false;
  }
  public void clearViewState(){
    mBlockWebkitViewMessages=false;
    mLoadedPicture=null;
    invalidate();
  }
  public WebBackForwardList restoreState(  Bundle inState){
    checkThread();
    WebBackForwardList returnList=null;
    if (inState == null) {
      return returnList;
    }
    if (inState.containsKey("index") && inState.containsKey("history")) {
      mCertificate=SslCertificate.restoreState(inState.getBundle("certificate"));
      final WebBackForwardList list=mCallbackProxy.getBackForwardList();
      final int index=inState.getInt("index");
synchronized (list) {
        final List<byte[]> history=(List<byte[]>)inState.getSerializable("history");
        final int size=history.size();
        if (index < 0 || index >= size) {
          return null;
        }
        for (int i=0; i < size; i++) {
          byte[] data=history.remove(0);
          if (data == null) {
            return null;
          }
          WebHistoryItem item=new WebHistoryItem(data);
          list.addHistoryItem(item);
        }
        returnList=copyBackForwardList();
        returnList.setCurrentIndex(index);
      }
      if (inState.getBoolean("privateBrowsingEnabled")) {
        getSettings().setPrivateBrowsingEnabled(true);
      }
      mZoomManager.restoreZoomState(inState);
      mWebViewCore.removeMessages();
      mWebViewCore.sendMessage(EventHub.RESTORE_STATE,index);
    }
    return returnList;
  }
  public void loadUrl(  String url,  Map<String,String> extraHeaders){
    checkThread();
    loadUrlImpl(url,extraHeaders);
  }
  private void loadUrlImpl(  String url,  Map<String,String> extraHeaders){
    switchOutDrawHistory();
    WebViewCore.GetUrlData arg=new WebViewCore.GetUrlData();
    arg.mUrl=url;
    arg.mExtraHeaders=extraHeaders;
    mWebViewCore.sendMessage(EventHub.LOAD_URL,arg);
    clearHelpers();
  }
  public void loadUrl(  String url){
    checkThread();
    loadUrlImpl(url);
  }
  private void loadUrlImpl(  String url){
    if (url == null) {
      return;
    }
    loadUrlImpl(url,null);
  }
  public void postUrl(  String url,  byte[] postData){
    checkThread();
    if (URLUtil.isNetworkUrl(url)) {
      switchOutDrawHistory();
      WebViewCore.PostUrlData arg=new WebViewCore.PostUrlData();
      arg.mUrl=url;
      arg.mPostData=postData;
      mWebViewCore.sendMessage(EventHub.POST_URL,arg);
      clearHelpers();
    }
 else {
      loadUrlImpl(url);
    }
  }
  public void loadData(  String data,  String mimeType,  String encoding){
    checkThread();
    loadDataImpl(data,mimeType,encoding);
  }
  private void loadDataImpl(  String data,  String mimeType,  String encoding){
    StringBuilder dataUrl=new StringBuilder("data:");
    dataUrl.append(mimeType);
    if ("base64".equals(encoding)) {
      dataUrl.append(";base64");
    }
    dataUrl.append(",");
    dataUrl.append(data);
    loadUrlImpl(dataUrl.toString());
  }
  public void loadDataWithBaseURL(  String baseUrl,  String data,  String mimeType,  String encoding,  String historyUrl){
    checkThread();
    if (baseUrl != null && baseUrl.toLowerCase().startsWith("data:")) {
      loadDataImpl(data,mimeType,encoding);
      return;
    }
    switchOutDrawHistory();
    WebViewCore.BaseUrlData arg=new WebViewCore.BaseUrlData();
    arg.mBaseUrl=baseUrl;
    arg.mData=data;
    arg.mMimeType=mimeType;
    arg.mEncoding=encoding;
    arg.mHistoryUrl=historyUrl;
    mWebViewCore.sendMessage(EventHub.LOAD_DATA,arg);
    clearHelpers();
  }
  public void saveWebArchive(  String filename){
    checkThread();
    saveWebArchiveImpl(filename,false,null);
  }
static class SaveWebArchiveMessage {
    SaveWebArchiveMessage(    String basename,    boolean autoname,    ValueCallback<String> callback){
      mBasename=basename;
      mAutoname=autoname;
      mCallback=callback;
    }
    final String mBasename;
    final boolean mAutoname;
    final ValueCallback<String> mCallback;
    String mResultFile;
  }
  public void saveWebArchive(  String basename,  boolean autoname,  ValueCallback<String> callback){
    checkThread();
    saveWebArchiveImpl(basename,autoname,callback);
  }
  private void saveWebArchiveImpl(  String basename,  boolean autoname,  ValueCallback<String> callback){
    mWebViewCore.sendMessage(EventHub.SAVE_WEBARCHIVE,new SaveWebArchiveMessage(basename,autoname,callback));
  }
  public void stopLoading(){
    checkThread();
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.STOP_LOADING);
  }
  public void reload(){
    checkThread();
    clearHelpers();
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.RELOAD);
  }
  public boolean canGoBack(){
    checkThread();
    WebBackForwardList l=mCallbackProxy.getBackForwardList();
synchronized (l) {
      if (l.getClearPending()) {
        return false;
      }
 else {
        return l.getCurrentIndex() > 0;
      }
    }
  }
  public void goBack(){
    checkThread();
    goBackOrForwardImpl(-1);
  }
  public boolean canGoForward(){
    checkThread();
    WebBackForwardList l=mCallbackProxy.getBackForwardList();
synchronized (l) {
      if (l.getClearPending()) {
        return false;
      }
 else {
        return l.getCurrentIndex() < l.getSize() - 1;
      }
    }
  }
  public void goForward(){
    checkThread();
    goBackOrForwardImpl(1);
  }
  public boolean canGoBackOrForward(  int steps){
    checkThread();
    WebBackForwardList l=mCallbackProxy.getBackForwardList();
synchronized (l) {
      if (l.getClearPending()) {
        return false;
      }
 else {
        int newIndex=l.getCurrentIndex() + steps;
        return newIndex >= 0 && newIndex < l.getSize();
      }
    }
  }
  public void goBackOrForward(  int steps){
    checkThread();
    goBackOrForwardImpl(steps);
  }
  private void goBackOrForwardImpl(  int steps){
    goBackOrForward(steps,false);
  }
  private void goBackOrForward(  int steps,  boolean ignoreSnapshot){
    if (steps != 0) {
      clearHelpers();
      mWebViewCore.sendMessage(EventHub.GO_BACK_FORWARD,steps,ignoreSnapshot ? 1 : 0);
    }
  }
  public boolean isPrivateBrowsingEnabled(){
    checkThread();
    return getSettings().isPrivateBrowsingEnabled();
  }
  private void startPrivateBrowsing(){
    getSettings().setPrivateBrowsingEnabled(true);
  }
  private boolean extendScroll(  int y){
    int finalY=mScroller.getFinalY();
    int newY=pinLocY(finalY + y);
    if (newY == finalY)     return false;
    mScroller.setFinalY(newY);
    mScroller.extendDuration(computeDuration(0,y));
    return true;
  }
  public boolean pageUp(  boolean top){
    checkThread();
    if (mNativeClass == 0) {
      return false;
    }
    nativeClearCursor();
    if (top) {
      return pinScrollTo(mScrollX,0,true,0);
    }
    int h=getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
      y=-h + PAGE_SCROLL_OVERLAP;
    }
 else {
      y=-h / 2;
    }
    return mScroller.isFinished() ? pinScrollBy(0,y,true,0) : extendScroll(y);
  }
  public boolean pageDown(  boolean bottom){
    checkThread();
    if (mNativeClass == 0) {
      return false;
    }
    nativeClearCursor();
    if (bottom) {
      return pinScrollTo(mScrollX,computeRealVerticalScrollRange(),true,0);
    }
    int h=getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
      y=h - PAGE_SCROLL_OVERLAP;
    }
 else {
      y=h / 2;
    }
    return mScroller.isFinished() ? pinScrollBy(0,y,true,0) : extendScroll(y);
  }
  public void clearView(){
    checkThread();
    mContentWidth=0;
    mContentHeight=0;
    setBaseLayer(0,null,false,false,false);
    mWebViewCore.sendMessage(EventHub.CLEAR_CONTENT);
  }
  public Picture capturePicture(){
    checkThread();
    if (mNativeClass == 0)     return null;
    Picture result=new Picture();
    nativeCopyBaseContentToPicture(result);
    return result;
  }
  private boolean inEditingMode(){
    return mWebTextView != null && mWebTextView.getParent() != null;
  }
  private void clearTextEntry(){
    if (inEditingMode()) {
      mWebTextView.remove();
    }
 else {
      hideSoftKeyboard();
    }
  }
  public float getScale(){
    checkThread();
    return mZoomManager.getScale();
  }
  float getReadingLevelScale(){
    return mZoomManager.getReadingLevelScale();
  }
  public void setInitialScale(  int scaleInPercent){
    checkThread();
    mZoomManager.setInitialScaleInPercent(scaleInPercent);
  }
  public void invokeZoomPicker(){
    checkThread();
    if (!getSettings().supportZoom()) {
      Log.w(LOGTAG,"This WebView doesn't support zoom.");
      return;
    }
    clearHelpers();
    mZoomManager.invokeZoomPicker();
  }
  public HitTestResult getHitTestResult(){
    checkThread();
    return hitTestResult(mInitialHitTestResult);
  }
  private HitTestResult hitTestResult(  HitTestResult fallback){
    if (mNativeClass == 0) {
      return null;
    }
    HitTestResult result=new HitTestResult();
    if (nativeHasCursorNode()) {
      if (nativeCursorIsTextInput()) {
        result.setType(HitTestResult.EDIT_TEXT_TYPE);
      }
 else {
        String text=nativeCursorText();
        if (text != null) {
          if (text.startsWith(SCHEME_TEL)) {
            result.setType(HitTestResult.PHONE_TYPE);
            result.setExtra(text.substring(SCHEME_TEL.length()));
          }
 else           if (text.startsWith(SCHEME_MAILTO)) {
            result.setType(HitTestResult.EMAIL_TYPE);
            result.setExtra(text.substring(SCHEME_MAILTO.length()));
          }
 else           if (text.startsWith(SCHEME_GEO)) {
            result.setType(HitTestResult.GEO_TYPE);
            result.setExtra(URLDecoder.decode(text.substring(SCHEME_GEO.length())));
          }
 else           if (nativeCursorIsAnchor()) {
            result.setType(HitTestResult.SRC_ANCHOR_TYPE);
            result.setExtra(text);
          }
        }
      }
    }
 else     if (fallback != null) {
      Log.v(LOGTAG,"hitTestResult use fallback");
      result=fallback;
    }
    int type=result.getType();
    if (type == HitTestResult.UNKNOWN_TYPE || type == HitTestResult.SRC_ANCHOR_TYPE) {
      int contentX=viewToContentX(mLastTouchX + mScrollX);
      int contentY=viewToContentY(mLastTouchY + mScrollY);
      String text=nativeImageURI(contentX,contentY);
      if (text != null) {
        result.setType(type == HitTestResult.UNKNOWN_TYPE ? HitTestResult.IMAGE_TYPE : HitTestResult.SRC_IMAGE_ANCHOR_TYPE);
        result.setExtra(text);
      }
    }
    return result;
  }
  private void domChangedFocus(){
    if (inEditingMode()) {
      mPrivateHandler.obtainMessage(DOM_FOCUS_CHANGED).sendToTarget();
    }
  }
  public void requestFocusNodeHref(  Message hrefMsg){
    checkThread();
    if (hrefMsg == null) {
      return;
    }
    int contentX=viewToContentX(mLastTouchX + mScrollX);
    int contentY=viewToContentY(mLastTouchY + mScrollY);
    if (nativeHasCursorNode()) {
      Rect cursorBounds=nativeGetCursorRingBounds();
      if (!cursorBounds.contains(contentX,contentY)) {
        int slop=viewToContentDimension(mNavSlop);
        cursorBounds.inset(-slop,-slop);
        if (cursorBounds.contains(contentX,contentY)) {
          contentX=(int)cursorBounds.centerX();
          contentY=(int)cursorBounds.centerY();
        }
      }
    }
    mWebViewCore.sendMessage(EventHub.REQUEST_CURSOR_HREF,contentX,contentY,hrefMsg);
  }
  public void requestImageRef(  Message msg){
    checkThread();
    if (0 == mNativeClass)     return;
    int contentX=viewToContentX(mLastTouchX + mScrollX);
    int contentY=viewToContentY(mLastTouchY + mScrollY);
    String ref=nativeImageURI(contentX,contentY);
    Bundle data=msg.getData();
    data.putString("url",ref);
    msg.setData(data);
    msg.sendToTarget();
  }
  static int pinLoc(  int x,  int viewMax,  int docMax){
    if (docMax < viewMax) {
      x=0;
    }
 else     if (x < 0) {
      x=0;
    }
 else     if (x + viewMax > docMax) {
      x=docMax - viewMax;
    }
    return x;
  }
  int pinLocX(  int x){
    if (mInOverScrollMode)     return x;
    return pinLoc(x,getViewWidth(),computeRealHorizontalScrollRange());
  }
  int pinLocY(  int y){
    if (mInOverScrollMode)     return y;
    return pinLoc(y,getViewHeightWithTitle(),computeRealVerticalScrollRange() + getTitleHeight());
  }
  private View mTitleBar;
  private int mTitleGravity;
  public void setEmbeddedTitleBar(  View v){
    if (mTitleBar == v)     return;
    if (mTitleBar != null) {
      removeView(mTitleBar);
    }
    if (null != v) {
      addView(v,new AbsoluteLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT,0,0));
    }
    mTitleBar=v;
  }
  public void setTitleBarGravity(  int gravity){
    mTitleGravity=gravity;
    invalidate();
  }
  private int viewToContentDimension(  int d){
    return Math.round(d * mZoomManager.getInvScale());
  }
  int viewToContentX(  int x){
    return viewToContentDimension(x);
  }
  int viewToContentY(  int y){
    return viewToContentDimension(y - getTitleHeight());
  }
  private float viewToContentXf(  int x){
    return x * mZoomManager.getInvScale();
  }
  private float viewToContentYf(  int y){
    return (y - getTitleHeight()) * mZoomManager.getInvScale();
  }
  int contentToViewDimension(  int d){
    return Math.round(d * mZoomManager.getScale());
  }
  int contentToViewX(  int x){
    return contentToViewDimension(x);
  }
  int contentToViewY(  int y){
    return contentToViewDimension(y) + getTitleHeight();
  }
  private Rect contentToViewRect(  Rect x){
    return new Rect(contentToViewX(x.left),contentToViewY(x.top),contentToViewX(x.right),contentToViewY(x.bottom));
  }
  private void viewInvalidate(  int l,  int t,  int r,  int b){
    final float scale=mZoomManager.getScale();
    final int dy=getTitleHeight();
    invalidate((int)Math.floor(l * scale),(int)Math.floor(t * scale) + dy,(int)Math.ceil(r * scale),(int)Math.ceil(b * scale) + dy);
  }
  private void viewInvalidateDelayed(  long delay,  int l,  int t,  int r,  int b){
    final float scale=mZoomManager.getScale();
    final int dy=getTitleHeight();
    postInvalidateDelayed(delay,(int)Math.floor(l * scale),(int)Math.floor(t * scale) + dy,(int)Math.ceil(r * scale),(int)Math.ceil(b * scale) + dy);
  }
  private void invalidateContentRect(  Rect r){
    viewInvalidate(r.left,r.top,r.right,r.bottom);
  }
  private void abortAnimation(){
    mScroller.abortAnimation();
    mLastVelocity=0;
  }
  private void recordNewContentSize(  int w,  int h,  boolean updateLayout){
    if ((w | h) == 0) {
      return;
    }
    if (mContentWidth != w || mContentHeight != h) {
      mContentWidth=w;
      mContentHeight=h;
      if (!mDrawHistory) {
        updateScrollCoordinates(pinLocX(mScrollX),pinLocY(mScrollY));
        if (!mScroller.isFinished()) {
          mScroller.setFinalX(pinLocX(mScroller.getFinalX()));
          mScroller.setFinalY(pinLocY(mScroller.getFinalY()));
        }
      }
    }
    contentSizeChanged(updateLayout);
  }
  private Rect mLastVisibleRectSent;
  private Rect mLastGlobalRect;
  Rect sendOurVisibleRect(){
    if (mZoomManager.isPreventingWebkitUpdates())     return mLastVisibleRectSent;
    Rect rect=new Rect();
    calcOurContentVisibleRect(rect);
    if (!rect.equals(mLastVisibleRectSent)) {
      if (!mBlockWebkitViewMessages) {
        Point pos=new Point(rect.left,rect.top);
        mWebViewCore.removeMessages(EventHub.SET_SCROLL_OFFSET);
        mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET,nativeMoveGeneration(),mSendScrollEvent ? 1 : 0,pos);
      }
      mLastVisibleRectSent=rect;
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
    }
    Rect globalRect=new Rect();
    if (getGlobalVisibleRect(globalRect) && !globalRect.equals(mLastGlobalRect)) {
      if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG,"sendOurVisibleRect=(" + globalRect.left + ","+ globalRect.top+ ",r="+ globalRect.right+ ",b="+ globalRect.bottom);
      }
      if (!mBlockWebkitViewMessages) {
        mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS,globalRect);
      }
      mLastGlobalRect=globalRect;
    }
    return rect;
  }
  private void calcOurVisibleRect(  Rect r){
    Point p=new Point();
    getGlobalVisibleRect(r,p);
    r.offset(-p.x,-p.y);
  }
  private void calcOurContentVisibleRect(  Rect r){
    calcOurVisibleRect(r);
    r.left=viewToContentX(r.left);
    r.top=viewToContentY(r.top + getVisibleTitleHeightImpl());
    r.right=viewToContentX(r.right);
    r.bottom=viewToContentY(r.bottom);
  }
  private void calcOurContentVisibleRectF(  RectF r){
    Rect ri=new Rect(0,0,0,0);
    calcOurVisibleRect(ri);
    r.left=viewToContentXf(ri.left);
    r.top=viewToContentYf(ri.top + getVisibleTitleHeightImpl());
    r.right=viewToContentXf(ri.right);
    r.bottom=viewToContentYf(ri.bottom);
  }
static class ViewSizeData {
    int mWidth;
    int mHeight;
    float mHeightWidthRatio;
    int mActualViewHeight;
    int mTextWrapWidth;
    int mAnchorX;
    int mAnchorY;
    float mScale;
    boolean mIgnoreHeight;
  }
  boolean sendViewSizeZoom(  boolean force){
    if (mBlockWebkitViewMessages)     return false;
    if (mZoomManager.isPreventingWebkitUpdates())     return false;
    int viewWidth=getViewWidth();
    int newWidth=Math.round(viewWidth * mZoomManager.getInvScale());
    int viewHeight=getViewHeightWithTitle() - getTitleHeight();
    int newHeight=Math.round(viewHeight * mZoomManager.getInvScale());
    float heightWidthRatio=(float)viewHeight / viewWidth;
    if (newWidth > mLastWidthSent && mWrapContent) {
      newHeight=0;
      heightWidthRatio=0;
    }
    int actualViewHeight=Math.round(getViewHeight() * mZoomManager.getInvScale());
    if (newWidth != mLastWidthSent || newHeight != mLastHeightSent || force || actualViewHeight != mLastActualHeightSent) {
      ViewSizeData data=new ViewSizeData();
      data.mWidth=newWidth;
      data.mHeight=newHeight;
      data.mHeightWidthRatio=heightWidthRatio;
      data.mActualViewHeight=actualViewHeight;
      data.mTextWrapWidth=Math.round(viewWidth / mZoomManager.getTextWrapScale());
      data.mScale=mZoomManager.getScale();
      data.mIgnoreHeight=mZoomManager.isFixedLengthAnimationInProgress() && !mHeightCanMeasure;
      data.mAnchorX=mZoomManager.getDocumentAnchorX();
      data.mAnchorY=mZoomManager.getDocumentAnchorY();
      mWebViewCore.sendMessage(EventHub.VIEW_SIZE_CHANGED,data);
      mLastWidthSent=newWidth;
      mLastHeightSent=newHeight;
      mLastActualHeightSent=actualViewHeight;
      mZoomManager.clearDocumentAnchor();
      return true;
    }
    return false;
  }
  private int computeRealHorizontalScrollRange(){
    if (mDrawHistory) {
      return mHistoryWidth;
    }
 else {
      return (int)Math.floor(mContentWidth * mZoomManager.getScale());
    }
  }
  @Override protected int computeHorizontalScrollRange(){
    int range=computeRealHorizontalScrollRange();
    final int scrollX=mScrollX;
    final int overscrollRight=computeMaxScrollX();
    if (scrollX < 0) {
      range-=scrollX;
    }
 else     if (scrollX > overscrollRight) {
      range+=scrollX - overscrollRight;
    }
    return range;
  }
  @Override protected int computeHorizontalScrollOffset(){
    return Math.max(mScrollX,0);
  }
  private int computeRealVerticalScrollRange(){
    if (mDrawHistory) {
      return mHistoryHeight;
    }
 else {
      return (int)Math.floor(mContentHeight * mZoomManager.getScale());
    }
  }
  @Override protected int computeVerticalScrollRange(){
    int range=computeRealVerticalScrollRange();
    final int scrollY=mScrollY;
    final int overscrollBottom=computeMaxScrollY();
    if (scrollY < 0) {
      range-=scrollY;
    }
 else     if (scrollY > overscrollBottom) {
      range+=scrollY - overscrollBottom;
    }
    return range;
  }
  @Override protected int computeVerticalScrollOffset(){
    return Math.max(mScrollY - getTitleHeight(),0);
  }
  @Override protected int computeVerticalScrollExtent(){
    return getViewHeight();
  }
  @Override protected void onDrawVerticalScrollBar(  Canvas canvas,  Drawable scrollBar,  int l,  int t,  int r,  int b){
    if (mScrollY < 0) {
      t-=mScrollY;
    }
    scrollBar.setBounds(l,t + getVisibleTitleHeightImpl(),r,b);
    scrollBar.draw(canvas);
  }
  @Override protected void onOverScrolled(  int scrollX,  int scrollY,  boolean clampedX,  boolean clampedY){
    if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
      nativeScrollLayer(mScrollingLayer,scrollX,scrollY);
      mScrollingLayerRect.left=scrollX;
      mScrollingLayerRect.top=scrollY;
      invalidate();
      return;
    }
    mInOverScrollMode=false;
    int maxX=computeMaxScrollX();
    int maxY=computeMaxScrollY();
    if (maxX == 0) {
      scrollX=pinLocX(scrollX);
    }
 else     if (scrollX < 0 || scrollX > maxX) {
      mInOverScrollMode=true;
    }
    if (scrollY < 0 || scrollY > maxY) {
      mInOverScrollMode=true;
    }
    int oldX=mScrollX;
    int oldY=mScrollY;
    super.scrollTo(scrollX,scrollY);
    if (mOverScrollGlow != null) {
      mOverScrollGlow.pullGlow(mScrollX,mScrollY,oldX,oldY,maxX,maxY);
    }
  }
  public String getUrl(){
    checkThread();
    WebHistoryItem h=mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getUrl() : null;
  }
  public String getOriginalUrl(){
    checkThread();
    WebHistoryItem h=mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getOriginalUrl() : null;
  }
  public String getTitle(){
    checkThread();
    WebHistoryItem h=mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getTitle() : null;
  }
  public Bitmap getFavicon(){
    checkThread();
    WebHistoryItem h=mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getFavicon() : null;
  }
  public String getTouchIconUrl(){
    WebHistoryItem h=mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getTouchIconUrl() : null;
  }
  public int getProgress(){
    checkThread();
    return mCallbackProxy.getProgress();
  }
  public int getContentHeight(){
    checkThread();
    return mContentHeight;
  }
  public int getContentWidth(){
    return mContentWidth;
  }
  public int getPageBackgroundColor(){
    return nativeGetBackgroundColor();
  }
  public void pauseTimers(){
    checkThread();
    mWebViewCore.sendMessage(EventHub.PAUSE_TIMERS);
  }
  public void resumeTimers(){
    checkThread();
    mWebViewCore.sendMessage(EventHub.RESUME_TIMERS);
  }
  public void onPause(){
    checkThread();
    if (!mIsPaused) {
      mIsPaused=true;
      mWebViewCore.sendMessage(EventHub.ON_PAUSE);
      if (mHTML5VideoViewProxy != null) {
        mHTML5VideoViewProxy.pauseAndDispatch();
      }
    }
  }
  public void onResume(){
    checkThread();
    if (mIsPaused) {
      mIsPaused=false;
      mWebViewCore.sendMessage(EventHub.ON_RESUME);
    }
  }
  public boolean isPaused(){
    return mIsPaused;
  }
  public void freeMemory(){
    checkThread();
    mWebViewCore.sendMessage(EventHub.FREE_MEMORY);
  }
  public void clearCache(  boolean includeDiskFiles){
    checkThread();
    mWebViewCore.sendMessage(EventHub.CLEAR_CACHE,includeDiskFiles ? 1 : 0,0);
  }
  public void clearFormData(){
    checkThread();
    if (inEditingMode()) {
      AutoCompleteAdapter adapter=null;
      mWebTextView.setAdapterCustom(adapter);
    }
  }
  public void clearHistory(){
    checkThread();
    mCallbackProxy.getBackForwardList().setClearPending();
    mWebViewCore.sendMessage(EventHub.CLEAR_HISTORY);
  }
  public void clearSslPreferences(){
    checkThread();
    mWebViewCore.sendMessage(EventHub.CLEAR_SSL_PREF_TABLE);
  }
  public WebBackForwardList copyBackForwardList(){
    checkThread();
    return mCallbackProxy.getBackForwardList().clone();
  }
  public void findNext(  boolean forward){
    checkThread();
    if (0 == mNativeClass)     return;
    nativeFindNext(forward);
  }
  public int findAll(  String find){
    checkThread();
    if (0 == mNativeClass)     return 0;
    int result=find != null ? nativeFindAll(find.toLowerCase(),find.toUpperCase(),find.equalsIgnoreCase(mLastFind)) : 0;
    invalidate();
    mLastFind=find;
    return result;
  }
  public boolean showFindDialog(  String text,  boolean showIme){
    checkThread();
    FindActionModeCallback callback=new FindActionModeCallback(mContext);
    if (getParent() == null || startActionMode(callback) == null) {
      return false;
    }
    mFindCallback=callback;
    setFindIsUp(true);
    mFindCallback.setWebView(this);
    if (showIme) {
      mFindCallback.showSoftInput();
    }
 else     if (text != null) {
      mFindCallback.setText(text);
      mFindCallback.findAll();
      return true;
    }
    if (text == null) {
      text=mLastFind;
    }
    if (text != null) {
      mFindCallback.setText(text);
    }
    return true;
  }
  private FindActionModeCallback mFindCallback;
  private void setFindIsUp(  boolean isUp){
    mFindIsUp=isUp;
    if (0 == mNativeClass)     return;
    nativeSetFindIsUp(isUp);
  }
  int findIndex(){
    if (0 == mNativeClass)     return -1;
    return nativeFindIndex();
  }
  private boolean mFindIsUp;
  private String mLastFind;
  public static String findAddress(  String addr){
    checkThread();
    return findAddress(addr,false);
  }
  public static String findAddress(  String addr,  boolean caseInsensitive){
    return WebViewCore.nativeFindAddress(addr,caseInsensitive);
  }
  public void clearMatches(){
    checkThread();
    if (mNativeClass == 0)     return;
    nativeSetFindIsEmpty();
    invalidate();
  }
  void notifyFindDialogDismissed(){
    mFindCallback=null;
    if (mWebViewCore == null) {
      return;
    }
    clearMatches();
    setFindIsUp(false);
    pinScrollTo(mScrollX,mScrollY,false,0);
    invalidate();
  }
  public void documentHasImages(  Message response){
    checkThread();
    if (response == null) {
      return;
    }
    mWebViewCore.sendMessage(EventHub.DOC_HAS_IMAGES,response);
  }
  public void stopScroll(){
    mScroller.forceFinished(true);
    mLastVelocity=0;
  }
  @Override public void computeScroll(){
    if (mScroller.computeScrollOffset()) {
      int oldX=mScrollX;
      int oldY=mScrollY;
      int x=mScroller.getCurrX();
      int y=mScroller.getCurrY();
      invalidate();
      if (!mScroller.isFinished()) {
        int rangeX=computeMaxScrollX();
        int rangeY=computeMaxScrollY();
        int overflingDistance=mOverflingDistance;
        if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
          oldX=mScrollingLayerRect.left;
          oldY=mScrollingLayerRect.top;
          rangeX=mScrollingLayerRect.right;
          rangeY=mScrollingLayerRect.bottom;
          overflingDistance=0;
        }
        overScrollBy(x - oldX,y - oldY,oldX,oldY,rangeX,rangeY,overflingDistance,overflingDistance,false);
        if (mOverScrollGlow != null) {
          mOverScrollGlow.absorbGlow(x,y,oldX,oldY,rangeX,rangeY);
        }
      }
 else {
        if (mTouchMode != TOUCH_DRAG_LAYER_MODE) {
          mScrollX=x;
          mScrollY=y;
        }
 else {
          nativeScrollLayer(mScrollingLayer,x,y);
          mScrollingLayerRect.left=x;
          mScrollingLayerRect.top=y;
        }
        abortAnimation();
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
        nativeSetIsScrolling(false);
        if (!mBlockWebkitViewMessages) {
          WebViewCore.resumePriority();
          if (!mSelectingText) {
            WebViewCore.resumeUpdatePicture(mWebViewCore);
          }
        }
        if (oldX != mScrollX || oldY != mScrollY) {
          sendOurVisibleRect();
        }
      }
    }
 else {
      super.computeScroll();
    }
  }
  private static int computeDuration(  int dx,  int dy){
    int distance=Math.max(Math.abs(dx),Math.abs(dy));
    int duration=distance * 1000 / STD_SPEED;
    return Math.min(duration,MAX_DURATION);
  }
  private boolean pinScrollBy(  int dx,  int dy,  boolean animate,  int animationDuration){
    return pinScrollTo(mScrollX + dx,mScrollY + dy,animate,animationDuration);
  }
  private boolean pinScrollTo(  int x,  int y,  boolean animate,  int animationDuration){
    x=pinLocX(x);
    y=pinLocY(y);
    int dx=x - mScrollX;
    int dy=y - mScrollY;
    if ((dx | dy) == 0) {
      return false;
    }
    abortAnimation();
    if (animate) {
      mScroller.startScroll(mScrollX,mScrollY,dx,dy,animationDuration > 0 ? animationDuration : computeDuration(dx,dy));
      awakenScrollBars(mScroller.getDuration());
      invalidate();
    }
 else {
      scrollTo(x,y);
    }
    return true;
  }
  private boolean setContentScrollBy(  int cx,  int cy,  boolean animate){
    if (mDrawHistory) {
      return false;
    }
    cx=contentToViewDimension(cx);
    cy=contentToViewDimension(cy);
    if (mHeightCanMeasure) {
      if (cy != 0) {
        Rect tempRect=new Rect();
        calcOurVisibleRect(tempRect);
        tempRect.offset(cx,cy);
        requestRectangleOnScreen(tempRect);
      }
      return cy == 0 && cx != 0 && pinScrollBy(cx,0,animate,0);
    }
 else {
      return pinScrollBy(cx,cy,animate,0);
    }
  }
  void onPageStarted(  String url){
    setCertificate(null);
    mAccessibilityScriptInjected=false;
  }
  void onPageFinished(  String url){
    if (mPageThatNeedsToSlideTitleBarOffScreen != null) {
      if (mPageThatNeedsToSlideTitleBarOffScreen.equals(url) && mScrollX == 0 && mScrollY == 0) {
        pinScrollTo(0,mYDistanceToSlideTitleOffScreen,true,SLIDE_TITLE_DURATION);
      }
      mPageThatNeedsToSlideTitleBarOffScreen=null;
    }
    mZoomManager.onPageFinished(url);
    injectAccessibilityForUrl(url);
  }
  private void injectAccessibilityForUrl(  String url){
    if (mWebViewCore == null) {
      return;
    }
    AccessibilityManager accessibilityManager=AccessibilityManager.getInstance(mContext);
    if (!accessibilityManager.isEnabled()) {
      ensureAccessibilityScriptInjectorInstance(false);
      return;
    }
    if (!getSettings().getJavaScriptEnabled()) {
      ensureAccessibilityScriptInjectorInstance(true);
      return;
    }
    int axsParameterValue=getAxsUrlParameterValue(url);
    if (axsParameterValue == ACCESSIBILITY_SCRIPT_INJECTION_UNDEFINED) {
      boolean onDeviceScriptInjectionEnabled=(Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_SCRIPT_INJECTION,0) == 1);
      if (onDeviceScriptInjectionEnabled) {
        ensureAccessibilityScriptInjectorInstance(false);
        loadUrl(ACCESSIBILITY_SCRIPT_CHOOSER_JAVASCRIPT);
        mAccessibilityScriptInjected=true;
      }
 else {
        ensureAccessibilityScriptInjectorInstance(true);
      }
    }
 else     if (axsParameterValue == ACCESSIBILITY_SCRIPT_INJECTION_OPTED_OUT) {
      ensureAccessibilityScriptInjectorInstance(true);
    }
 else     if (axsParameterValue == ACCESSIBILITY_SCRIPT_INJECTION_PROVIDED) {
      ensureAccessibilityScriptInjectorInstance(false);
      loadUrl(ACCESSIBILITY_SCRIPT_CHOOSER_JAVASCRIPT);
    }
 else {
      Log.e(LOGTAG,"Unknown URL value for the \"axs\" URL parameter: " + axsParameterValue);
    }
  }
  private void ensureAccessibilityScriptInjectorInstance(  boolean present){
    if (present) {
      if (mAccessibilityInjector == null) {
        mAccessibilityInjector=new AccessibilityInjector(this);
      }
    }
 else {
      mAccessibilityInjector=null;
    }
  }
  private int getAxsUrlParameterValue(  String url){
    if (mMatchAxsUrlParameterPattern == null) {
      mMatchAxsUrlParameterPattern=Pattern.compile(PATTERN_MATCH_AXS_URL_PARAMETER);
    }
    Matcher matcher=mMatchAxsUrlParameterPattern.matcher(url);
    if (matcher.find()) {
      String keyValuePair=url.substring(matcher.start(),matcher.end());
      return Integer.parseInt(keyValuePair.split("=")[1]);
    }
    return -1;
  }
  private String mPageThatNeedsToSlideTitleBarOffScreen;
  private int mYDistanceToSlideTitleOffScreen;
  private boolean setContentScrollTo(  int cx,  int cy){
    if (mDrawHistory) {
      return false;
    }
    int vx;
    int vy;
    if ((cx | cy) == 0) {
      vx=0;
      vy=0;
    }
 else {
      vx=contentToViewX(cx);
      vy=contentToViewY(cy);
    }
    if (cx == 0 && cy == 1 && mScrollX == 0 && mScrollY == 0 && mTitleBar != null) {
      if (getProgress() < 100) {
        mPageThatNeedsToSlideTitleBarOffScreen=getUrl();
        mYDistanceToSlideTitleOffScreen=vy;
      }
 else {
        pinScrollTo(vx,vy,true,SLIDE_TITLE_DURATION);
      }
      return false;
    }
    pinScrollTo(vx,vy,false,0);
    if ((mScrollX != vx && cx >= 0) || (mScrollY != vy && cy >= 0)) {
      return true;
    }
 else {
      return false;
    }
  }
  private void spawnContentScrollTo(  int cx,  int cy){
    if (mDrawHistory) {
      return;
    }
    int vx=contentToViewX(cx);
    int vy=contentToViewY(cy);
    pinScrollTo(vx,vy,true,0);
  }
  private void contentSizeChanged(  boolean updateLayout){
    if ((mContentWidth | mContentHeight) == 0) {
      return;
    }
    if (mHeightCanMeasure) {
      if (getMeasuredHeight() != contentToViewDimension(mContentHeight) || updateLayout) {
        requestLayout();
      }
    }
 else     if (mWidthCanMeasure) {
      if (getMeasuredWidth() != contentToViewDimension(mContentWidth) || updateLayout) {
        requestLayout();
      }
    }
 else {
      sendViewSizeZoom(false);
    }
  }
  public void setWebViewClient(  WebViewClient client){
    checkThread();
    mCallbackProxy.setWebViewClient(client);
  }
  public WebViewClient getWebViewClient(){
    return mCallbackProxy.getWebViewClient();
  }
  public void setDownloadListener(  DownloadListener listener){
    checkThread();
    mCallbackProxy.setDownloadListener(listener);
  }
  public void setWebChromeClient(  WebChromeClient client){
    checkThread();
    mCallbackProxy.setWebChromeClient(client);
  }
  public WebChromeClient getWebChromeClient(){
    return mCallbackProxy.getWebChromeClient();
  }
  public void setWebBackForwardListClient(  WebBackForwardListClient client){
    mCallbackProxy.setWebBackForwardListClient(client);
  }
  public WebBackForwardListClient getWebBackForwardListClient(){
    return mCallbackProxy.getWebBackForwardListClient();
  }
  @Deprecated public void setPictureListener(  PictureListener listener){
    checkThread();
    mPictureListener=listener;
  }
  public void externalRepresentation(  Message callback){
    mWebViewCore.sendMessage(EventHub.REQUEST_EXT_REPRESENTATION,callback);
  }
  public void documentAsText(  Message callback){
    mWebViewCore.sendMessage(EventHub.REQUEST_DOC_AS_TEXT,callback);
  }
  public void addJavascriptInterface(  Object obj,  String interfaceName){
    checkThread();
    if (obj == null) {
      return;
    }
    WebViewCore.JSInterfaceData arg=new WebViewCore.JSInterfaceData();
    arg.mObject=obj;
    arg.mInterfaceName=interfaceName;
    mWebViewCore.sendMessage(EventHub.ADD_JS_INTERFACE,arg);
  }
  public void removeJavascriptInterface(  String interfaceName){
    checkThread();
    if (mWebViewCore != null) {
      WebViewCore.JSInterfaceData arg=new WebViewCore.JSInterfaceData();
      arg.mInterfaceName=interfaceName;
      mWebViewCore.sendMessage(EventHub.REMOVE_JS_INTERFACE,arg);
    }
  }
  public WebSettings getSettings(){
    checkThread();
    return (mWebViewCore != null) ? mWebViewCore.getSettings() : null;
  }
  @Deprecated public static synchronized PluginList getPluginList(){
    checkThread();
    return new PluginList();
  }
  @Deprecated public void refreshPlugins(  boolean reloadOpenPages){
    checkThread();
  }
  @Override protected void finalize() throws Throwable {
    try {
      destroyImpl();
    }
  finally {
      super.finalize();
    }
  }
  @Override protected boolean drawChild(  Canvas canvas,  View child,  long drawingTime){
    if (child == mTitleBar) {
      mTitleBar.offsetLeftAndRight(mScrollX - mTitleBar.getLeft());
      int newTop=0;
      if (mTitleGravity == Gravity.NO_GRAVITY) {
        newTop=Math.min(0,mScrollY);
      }
 else       if (mTitleGravity == Gravity.TOP) {
        newTop=mScrollY;
      }
      mTitleBar.setBottom(newTop + mTitleBar.getHeight());
      mTitleBar.setTop(newTop);
    }
    return super.drawChild(canvas,child,drawingTime);
  }
  private void drawContent(  Canvas canvas,  boolean drawRings){
    nativeRecordButtons(hasFocus() && hasWindowFocus(),(mTouchMode == TOUCH_SHORTPRESS_START_MODE && !USE_WEBKIT_RINGS) || mTrackballDown || mGotCenterDown,false);
    drawCoreAndCursorRing(canvas,mBackgroundColor,mDrawCursorRing && drawRings);
  }
  private void drawOverScrollBackground(  Canvas canvas){
    if (mOverScrollBackground == null) {
      mOverScrollBackground=new Paint();
      Bitmap bm=BitmapFactory.decodeResource(mContext.getResources(),com.android.internal.R.drawable.status_bar_background);
      mOverScrollBackground.setShader(new BitmapShader(bm,Shader.TileMode.REPEAT,Shader.TileMode.REPEAT));
      mOverScrollBorder=new Paint();
      mOverScrollBorder.setStyle(Paint.Style.STROKE);
      mOverScrollBorder.setStrokeWidth(0);
      mOverScrollBorder.setColor(0xffbbbbbb);
    }
    int top=0;
    int right=computeRealHorizontalScrollRange();
    int bottom=top + computeRealVerticalScrollRange();
    canvas.save();
    canvas.translate(mScrollX,mScrollY);
    canvas.clipRect(-mScrollX,top - mScrollY,right - mScrollX,bottom - mScrollY,Region.Op.DIFFERENCE);
    canvas.drawPaint(mOverScrollBackground);
    canvas.restore();
    canvas.drawRect(-1,top - 1,right,bottom,mOverScrollBorder);
    canvas.clipRect(0,top,right,bottom);
  }
  @Override protected void onDraw(  Canvas canvas){
    if (mNativeClass == 0) {
      canvas.drawColor(mBackgroundColor);
      return;
    }
    if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
      canvas.drawColor(mBackgroundColor);
      return;
    }
    if (canvas.isHardwareAccelerated()) {
      mZoomManager.setHardwareAccelerated();
    }
    int saveCount=canvas.save();
    if (mInOverScrollMode && !getSettings().getUseWebViewBackgroundForOverscrollBackground()) {
      drawOverScrollBackground(canvas);
    }
    if (mTitleBar != null) {
      canvas.translate(0,getTitleHeight());
    }
    boolean drawJavaRings=!mTouchHighlightRegion.isEmpty() && (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE || mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_DONE_MODE);
    boolean drawNativeRings=!drawJavaRings;
    if (USE_WEBKIT_RINGS) {
      drawNativeRings=!drawJavaRings && !isInTouchMode();
    }
    drawContent(canvas,drawNativeRings);
    canvas.restoreToCount(saveCount);
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
      invalidate();
    }
    mWebViewCore.signalRepaintDone();
    if (mOverScrollGlow != null && mOverScrollGlow.drawEdgeGlows(canvas)) {
      invalidate();
    }
    if (drawJavaRings) {
      long delay=System.currentTimeMillis() - mTouchHighlightRequested;
      if (delay < ViewConfiguration.getTapTimeout()) {
        Rect r=mTouchHighlightRegion.getBounds();
        postInvalidateDelayed(delay,r.left,r.top,r.right,r.bottom);
      }
 else {
        if (mTouchHightlightPaint == null) {
          mTouchHightlightPaint=new Paint();
          mTouchHightlightPaint.setColor(HIGHLIGHT_COLOR);
        }
        RegionIterator iter=new RegionIterator(mTouchHighlightRegion);
        Rect r=new Rect();
        while (iter.next(r)) {
          canvas.drawRect(r,mTouchHightlightPaint);
        }
      }
    }
    if (DEBUG_TOUCH_HIGHLIGHT) {
      if (getSettings().getNavDump()) {
        if ((mTouchHighlightX | mTouchHighlightY) != 0) {
          if (mTouchCrossHairColor == null) {
            mTouchCrossHairColor=new Paint();
            mTouchCrossHairColor.setColor(Color.RED);
          }
          canvas.drawLine(mTouchHighlightX - mNavSlop,mTouchHighlightY - mNavSlop,mTouchHighlightX + mNavSlop + 1,mTouchHighlightY + mNavSlop + 1,mTouchCrossHairColor);
          canvas.drawLine(mTouchHighlightX + mNavSlop + 1,mTouchHighlightY - mNavSlop,mTouchHighlightX - mNavSlop,mTouchHighlightY + mNavSlop + 1,mTouchCrossHairColor);
        }
      }
    }
  }
  private void removeTouchHighlight(){
    mWebViewCore.removeMessages(EventHub.GET_TOUCH_HIGHLIGHT_RECTS);
    mPrivateHandler.removeMessages(SET_TOUCH_HIGHLIGHT_RECTS);
    setTouchHighlightRects(null);
  }
  @Override public void setLayoutParams(  ViewGroup.LayoutParams params){
    if (params.height == LayoutParams.WRAP_CONTENT) {
      mWrapContent=true;
    }
    super.setLayoutParams(params);
  }
  @Override public boolean performLongClick(){
    if (getParent() == null)     return false;
    final ScaleGestureDetector detector=mZoomManager.getMultiTouchGestureDetector();
    if (detector != null && detector.isInProgress()) {
      return false;
    }
    if (mNativeClass != 0 && nativeCursorIsTextInput()) {
      centerKeyPressOnTextField();
      rebuildWebTextView();
    }
 else {
      clearTextEntry();
    }
    if (inEditingMode()) {
      mWebTextView.ensureLayout();
      AbsoluteLayout.LayoutParams params=(AbsoluteLayout.LayoutParams)mWebTextView.getLayoutParams();
      MotionEvent fake=MotionEvent.obtain(mLastTouchTime,mLastTouchTime,MotionEvent.ACTION_DOWN,mLastTouchX - params.x + mScrollX,mLastTouchY - params.y + mScrollY,0);
      mWebTextView.dispatchTouchEvent(fake);
      return mWebTextView.performLongClick();
    }
    if (mSelectingText)     return false;
    if (super.performLongClick()) {
      return true;
    }
    return selectText();
  }
  public boolean selectText(){
    int x=viewToContentX(mLastTouchX + mScrollX);
    int y=viewToContentY(mLastTouchY + mScrollY);
    return selectText(x,y);
  }
  boolean selectText(  int x,  int y){
    if (!setUpSelect(true,x,y)) {
      return false;
    }
    nativeSetExtendSelection();
    mDrawSelectionPointer=false;
    mSelectionStarted=true;
    mTouchMode=TOUCH_DRAG_MODE;
    return true;
  }
  private int mOrientation=Configuration.ORIENTATION_UNDEFINED;
  @Override protected void onConfigurationChanged(  Configuration newConfig){
    if (mSelectingText && mOrientation != newConfig.orientation) {
      selectionDone();
    }
    mOrientation=newConfig.orientation;
  }
  private SelectActionModeCallback mSelectCallback;
  private static final int FULLY_ON_SCREEN=0;
  private static final int INTERSECTS_SCREEN=1;
  private static final int ANYWHERE=2;
  private boolean didUpdateWebTextViewDimensions(  int intersection){
    Rect contentBounds=nativeFocusCandidateNodeBounds();
    Rect vBox=contentToViewRect(contentBounds);
    Rect visibleRect=new Rect();
    calcOurVisibleRect(visibleRect);
    boolean onScreen;
switch (intersection) {
case FULLY_ON_SCREEN:
      onScreen=visibleRect.contains(vBox);
    break;
case INTERSECTS_SCREEN:
  onScreen=Rect.intersects(visibleRect,vBox);
break;
case ANYWHERE:
onScreen=true;
break;
default :
throw new AssertionError("invalid parameter passed to didUpdateWebTextViewDimensions");
}
if (onScreen) {
mWebTextView.setRect(vBox.left,vBox.top,vBox.width(),vBox.height());
mWebTextView.updateTextSize();
updateWebTextViewPadding();
return true;
}
 else {
mWebTextView.remove();
return false;
}
}
void setBaseLayer(int layer,Region invalRegion,boolean showVisualIndicator,boolean isPictureAfterFirstLayout,boolean registerPageSwapCallback){
if (mNativeClass == 0) return;
nativeSetBaseLayer(layer,invalRegion,showVisualIndicator,isPictureAfterFirstLayout,registerPageSwapCallback);
if (mHTML5VideoViewProxy != null) {
mHTML5VideoViewProxy.setBaseLayer(layer);
}
}
int getBaseLayer(){
if (mNativeClass == 0) {
return 0;
}
return nativeGetBaseLayer();
}
private void onZoomAnimationStart(){
if (inEditingMode()) {
mWebTextView.setVisibility(INVISIBLE);
}
}
private void onZoomAnimationEnd(){
if (inEditingMode() && didUpdateWebTextViewDimensions(FULLY_ON_SCREEN)) {
mWebTextView.setVisibility(VISIBLE);
}
}
void onFixedLengthZoomAnimationStart(){
WebViewCore.pauseUpdatePicture(getWebViewCore());
onZoomAnimationStart();
}
void onFixedLengthZoomAnimationEnd(){
if (!mBlockWebkitViewMessages && !mSelectingText) {
WebViewCore.resumeUpdatePicture(mWebViewCore);
}
onZoomAnimationEnd();
}
private static final int ZOOM_BITS=Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG | Paint.SUBPIXEL_TEXT_FLAG;
private static final int SCROLL_BITS=Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG;
private final DrawFilter mZoomFilter=new PaintFlagsDrawFilter(ZOOM_BITS,Paint.LINEAR_TEXT_FLAG);
private final DrawFilter mScrollFilter=new PaintFlagsDrawFilter(SCROLL_BITS,0);
private void drawCoreAndCursorRing(Canvas canvas,int color,boolean drawCursorRing){
if (mDrawHistory) {
canvas.scale(mZoomManager.getScale(),mZoomManager.getScale());
canvas.drawPicture(mHistoryPicture);
return;
}
if (mNativeClass == 0) return;
boolean animateZoom=mZoomManager.isFixedLengthAnimationInProgress();
boolean animateScroll=((!mScroller.isFinished() || mVelocityTracker != null) && (mTouchMode != TOUCH_DRAG_MODE || mHeldMotionless != MOTIONLESS_TRUE)) || mDeferTouchMode == TOUCH_DRAG_MODE;
if (mTouchMode == TOUCH_DRAG_MODE) {
if (mHeldMotionless == MOTIONLESS_PENDING) {
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
mHeldMotionless=MOTIONLESS_FALSE;
}
if (mHeldMotionless == MOTIONLESS_FALSE) {
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(DRAG_HELD_MOTIONLESS),MOTIONLESS_TIME);
mHeldMotionless=MOTIONLESS_PENDING;
}
}
if (animateZoom) {
mZoomManager.animateZoom(canvas);
}
 else if (!canvas.isHardwareAccelerated()) {
canvas.scale(mZoomManager.getScale(),mZoomManager.getScale());
}
boolean UIAnimationsRunning=false;
if (mNativeClass != 0 && nativeEvaluateLayersAnimations()) {
UIAnimationsRunning=true;
if (!canvas.isHardwareAccelerated()) invalidate();
}
int extras=DRAW_EXTRAS_NONE;
if (mFindIsUp) {
extras=DRAW_EXTRAS_FIND;
}
 else if (mSelectingText && !USE_JAVA_TEXT_SELECTION) {
extras=DRAW_EXTRAS_SELECTION;
nativeSetSelectionPointer(mDrawSelectionPointer,mZoomManager.getInvScale(),mSelectX,mSelectY - getTitleHeight());
}
 else if (drawCursorRing) {
extras=DRAW_EXTRAS_CURSOR_RING;
}
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"mFindIsUp=" + mFindIsUp + " mSelectingText="+ mSelectingText+ " nativePageShouldHandleShiftAndArrows()="+ nativePageShouldHandleShiftAndArrows()+ " animateZoom="+ animateZoom+ " extras="+ extras);
}
if (canvas.isHardwareAccelerated()) {
int functor=nativeGetDrawGLFunction(mGLViewportEmpty ? null : mGLRectViewport,mGLViewportEmpty ? null : mViewRectViewport,getScale(),extras);
((HardwareCanvas)canvas).callDrawGLFunction(functor);
if (mHardwareAccelSkia != getSettings().getHardwareAccelSkiaEnabled()) {
mHardwareAccelSkia=getSettings().getHardwareAccelSkiaEnabled();
nativeUseHardwareAccelSkia(mHardwareAccelSkia);
}
if (mSelectingText && USE_JAVA_TEXT_SELECTION) {
drawTextSelectionHandles(canvas);
}
}
 else {
DrawFilter df=null;
if (mZoomManager.isZoomAnimating() || UIAnimationsRunning) {
df=mZoomFilter;
}
 else if (animateScroll) {
df=mScrollFilter;
}
canvas.setDrawFilter(df);
int content=nativeDraw(canvas,color,extras,false);
canvas.setDrawFilter(null);
if (!mBlockWebkitViewMessages && content != 0) {
mWebViewCore.sendMessage(EventHub.SPLIT_PICTURE_SET,content,0);
}
}
if (extras == DRAW_EXTRAS_CURSOR_RING) {
if (mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
mTouchMode=TOUCH_SHORTPRESS_MODE;
}
}
if (mFocusSizeChanged) {
mFocusSizeChanged=false;
if (!canvas.isHardwareAccelerated() && !animateZoom && inEditingMode()) {
didUpdateWebTextViewDimensions(ANYWHERE);
}
}
}
private void drawTextSelectionHandles(Canvas canvas){
if (mTextSelectionPaint == null) {
mTextSelectionPaint=new Paint();
mTextSelectionPaint.setColor(HIGHLIGHT_COLOR);
}
mTextSelectionRegion.setEmpty();
nativeGetTextSelectionRegion(mTextSelectionRegion);
Rect r=new Rect();
RegionIterator iter=new RegionIterator(mTextSelectionRegion);
int start_x=-1;
int start_y=-1;
int end_x=-1;
int end_y=-1;
while (iter.next(r)) {
r=new Rect(contentToViewDimension(r.left),contentToViewDimension(r.top),contentToViewDimension(r.right),contentToViewDimension(r.bottom));
if (start_x < 0 || start_y < 0) {
start_x=r.left;
start_y=r.bottom;
}
end_x=r.right;
end_y=r.bottom;
canvas.drawRect(r,mTextSelectionPaint);
}
if (mSelectHandleLeft == null) {
mSelectHandleLeft=mContext.getResources().getDrawable(com.android.internal.R.drawable.text_select_handle_left);
}
start_x-=(mSelectHandleLeft.getIntrinsicWidth() * 3) / 4;
mSelectHandleLeft.setBounds(start_x,start_y,start_x + mSelectHandleLeft.getIntrinsicWidth(),start_y + mSelectHandleLeft.getIntrinsicHeight());
if (mSelectHandleRight == null) {
mSelectHandleRight=mContext.getResources().getDrawable(com.android.internal.R.drawable.text_select_handle_right);
}
end_x-=mSelectHandleRight.getIntrinsicWidth() / 4;
mSelectHandleRight.setBounds(end_x,end_y,end_x + mSelectHandleRight.getIntrinsicWidth(),end_y + mSelectHandleRight.getIntrinsicHeight());
mSelectHandleLeft.draw(canvas);
mSelectHandleRight.draw(canvas);
}
private boolean mDrawHistory=false;
private Picture mHistoryPicture=null;
private int mHistoryWidth=0;
private int mHistoryHeight=0;
boolean drawHistory(){
return mDrawHistory;
}
int getHistoryPictureWidth(){
return (mHistoryPicture != null) ? mHistoryPicture.getWidth() : 0;
}
void switchOutDrawHistory(){
if (null == mWebViewCore) return;
if (mDrawHistory && (getProgress() == 100 || nativeHasContent())) {
mDrawHistory=false;
mHistoryPicture=null;
invalidate();
int oldScrollX=mScrollX;
int oldScrollY=mScrollY;
mScrollX=pinLocX(mScrollX);
mScrollY=pinLocY(mScrollY);
if (oldScrollX != mScrollX || oldScrollY != mScrollY) {
onScrollChanged(mScrollX,mScrollY,oldScrollX,oldScrollY);
}
 else {
sendOurVisibleRect();
}
}
}
WebViewCore.CursorData cursorData(){
WebViewCore.CursorData result=cursorDataNoPosition();
Point position=nativeCursorPosition();
result.mX=position.x;
result.mY=position.y;
return result;
}
WebViewCore.CursorData cursorDataNoPosition(){
WebViewCore.CursorData result=new WebViewCore.CursorData();
result.mMoveGeneration=nativeMoveGeneration();
result.mFrame=nativeCursorFramePointer();
return result;
}
void deleteSelection(int start,int end){
mTextGeneration++;
WebViewCore.TextSelectionData data=new WebViewCore.TextSelectionData(start,end);
mWebViewCore.sendMessage(EventHub.DELETE_SELECTION,mTextGeneration,0,data);
}
void setSelection(int start,int end){
if (mWebViewCore != null) {
mWebViewCore.sendMessage(EventHub.SET_SELECTION,start,end);
}
}
@Override public InputConnection onCreateInputConnection(EditorInfo outAttrs){
InputConnection connection=super.onCreateInputConnection(outAttrs);
outAttrs.imeOptions|=EditorInfo.IME_FLAG_NO_FULLSCREEN;
return connection;
}
private void displaySoftKeyboard(boolean isTextView){
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
boolean zoom=mZoomManager.getScale() < mZoomManager.getDefaultScale();
if (zoom) {
mZoomManager.setZoomCenter(mLastTouchX,mLastTouchY);
mZoomManager.setZoomScale(mZoomManager.getDefaultScale(),false);
}
if (isTextView) {
rebuildWebTextView();
if (inEditingMode()) {
imm.showSoftInput(mWebTextView,0,mWebTextView.getResultReceiver());
if (zoom) {
didUpdateWebTextViewDimensions(INTERSECTS_SCREEN);
}
return;
}
}
imm.showSoftInput(this,0);
}
private void hideSoftKeyboard(){
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null && (imm.isActive(this) || (inEditingMode() && imm.isActive(mWebTextView)))) {
imm.hideSoftInputFromWindow(this.getWindowToken(),0);
}
}
void rebuildWebTextView(){
if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus())) {
return;
}
boolean alreadyThere=inEditingMode();
if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
if (alreadyThere) {
mWebTextView.remove();
}
return;
}
if (mWebTextView == null) {
mWebTextView=new WebTextView(mContext,WebView.this,mAutoFillData.getQueryId());
mTextGeneration=0;
}
mWebTextView.updateTextSize();
Rect visibleRect=new Rect();
calcOurContentVisibleRect(visibleRect);
Rect bounds=nativeFocusCandidateNodeBounds();
Rect vBox=contentToViewRect(bounds);
mWebTextView.setRect(vBox.left,vBox.top,vBox.width(),vBox.height());
if (!Rect.intersects(bounds,visibleRect)) {
revealSelection();
}
String text=nativeFocusCandidateText();
int nodePointer=nativeFocusCandidatePointer();
mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
mWebTextView.setNodePointer(nodePointer);
mWebTextView.setType(nativeFocusCandidateType());
updateWebTextViewPadding();
if (null == text) {
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"rebuildWebTextView null == text");
}
text="";
}
mWebTextView.setTextAndKeepSelection(text);
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null && imm.isActive(mWebTextView)) {
imm.restartInput(mWebTextView);
}
if (isFocused()) {
mWebTextView.requestFocus();
}
}
void updateWebTextViewPadding(){
Rect paddingRect=nativeFocusCandidatePaddingRect();
if (paddingRect != null) {
mWebTextView.setPadding(contentToViewDimension(paddingRect.left),contentToViewDimension(paddingRect.top),contentToViewDimension(paddingRect.right),contentToViewDimension(paddingRect.bottom));
}
}
void revealSelection(){
if (mWebViewCore != null) {
mWebViewCore.sendMessage(EventHub.REVEAL_SELECTION);
}
}
void requestFormData(String name,int nodePointer,boolean autoFillable,boolean autoComplete){
if (mWebViewCore.getSettings().getSaveFormData()) {
Message update=mPrivateHandler.obtainMessage(REQUEST_FORM_DATA);
update.arg1=nodePointer;
RequestFormData updater=new RequestFormData(name,getUrl(),update,autoFillable,autoComplete);
Thread t=new Thread(updater);
t.start();
}
}
void requestLabel(int framePointer,int nodePointer){
mWebViewCore.sendMessage(EventHub.REQUEST_LABEL,framePointer,nodePointer);
}
private class RequestFormData implements Runnable {
private String mName;
private String mUrl;
private Message mUpdateMessage;
private boolean mAutoFillable;
private boolean mAutoComplete;
private WebSettings mWebSettings;
public RequestFormData(String name,String url,Message msg,boolean autoFillable,boolean autoComplete){
mName=name;
mUrl=WebTextView.urlForAutoCompleteData(url);
mUpdateMessage=msg;
mAutoFillable=autoFillable;
mAutoComplete=autoComplete;
mWebSettings=getSettings();
}
public void run(){
ArrayList<String> pastEntries=new ArrayList<String>();
if (mAutoFillable) {
if (mWebSettings != null && mWebSettings.getAutoFillProfile() != null) {
pastEntries.add(getResources().getText(com.android.internal.R.string.autofill_this_form).toString() + " " + mAutoFillData.getPreviewString());
mWebTextView.setAutoFillProfileIsSet(true);
}
 else {
pastEntries.add(getResources().getText(com.android.internal.R.string.setup_autofill).toString());
mWebTextView.setAutoFillProfileIsSet(false);
}
}
if (mAutoComplete) {
pastEntries.addAll(mDatabase.getFormData(mUrl,mName));
}
if (pastEntries.size() > 0) {
AutoCompleteAdapter adapter=new AutoCompleteAdapter(mContext,pastEntries);
mUpdateMessage.obj=adapter;
mUpdateMessage.sendToTarget();
}
}
}
public void dumpDisplayTree(){
nativeDumpDisplayTree(getUrl());
}
public void dumpDomTree(boolean toFile){
mWebViewCore.sendMessage(EventHub.DUMP_DOMTREE,toFile ? 1 : 0,0);
}
public void dumpRenderTree(boolean toFile){
mWebViewCore.sendMessage(EventHub.DUMP_RENDERTREE,toFile ? 1 : 0,0);
}
public void useMockDeviceOrientation(){
mWebViewCore.sendMessage(EventHub.USE_MOCK_DEVICE_ORIENTATION);
}
public void setMockDeviceOrientation(boolean canProvideAlpha,double alpha,boolean canProvideBeta,double beta,boolean canProvideGamma,double gamma){
mWebViewCore.setMockDeviceOrientation(canProvideAlpha,alpha,canProvideBeta,beta,canProvideGamma,gamma);
}
public void dumpV8Counters(){
mWebViewCore.sendMessage(EventHub.DUMP_V8COUNTERS);
}
private boolean mGotCenterDown=false;
@Override public boolean onKeyMultiple(int keyCode,int repeatCount,KeyEvent event){
if (mBlockWebkitViewMessages) {
return false;
}
if (keyCode == KeyEvent.KEYCODE_UNKNOWN && event.getCharacters() != null) {
mWebViewCore.sendMessage(EventHub.KEY_DOWN,event);
mWebViewCore.sendMessage(EventHub.KEY_UP,event);
return true;
}
return false;
}
private boolean isEnterActionKey(int keyCode){
return keyCode == KeyEvent.KEYCODE_DPAD_CENTER || keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_NUMPAD_ENTER;
}
@Override public boolean onKeyDown(int keyCode,KeyEvent event){
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"keyDown at " + System.currentTimeMillis() + "keyCode="+ keyCode+ ", "+ event+ ", unicode="+ event.getUnicodeChar());
}
if (mBlockWebkitViewMessages) {
return false;
}
if (event.isCtrlPressed()) {
return false;
}
if (mNativeClass == 0) {
return false;
}
if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
mAutoRedraw=!mAutoRedraw;
if (mAutoRedraw) {
invalidate();
}
return true;
}
if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
return false;
}
if (accessibilityScriptInjected()) {
if (AccessibilityManager.getInstance(mContext).isEnabled()) {
mWebViewCore.sendMessage(EventHub.KEY_DOWN,event);
return true;
}
 else {
mAccessibilityScriptInjected=false;
}
}
 else if (mAccessibilityInjector != null) {
if (AccessibilityManager.getInstance(mContext).isEnabled()) {
if (mAccessibilityInjector.onKeyEvent(event)) {
return true;
}
}
 else {
mAccessibilityInjector=null;
}
}
if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {
if (event.hasNoModifiers()) {
pageUp(false);
return true;
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
pageUp(true);
return true;
}
}
if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {
if (event.hasNoModifiers()) {
pageDown(false);
return true;
}
 else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
pageDown(true);
return true;
}
}
if (keyCode == KeyEvent.KEYCODE_MOVE_HOME && event.hasNoModifiers()) {
pageUp(true);
return true;
}
if (keyCode == KeyEvent.KEYCODE_MOVE_END && event.hasNoModifiers()) {
pageDown(true);
return true;
}
if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
switchOutDrawHistory();
if (nativePageShouldHandleShiftAndArrows()) {
letPageHandleNavKey(keyCode,event.getEventTime(),true,event.getMetaState());
return true;
}
if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
pageUp(true);
return true;
case KeyEvent.KEYCODE_DPAD_DOWN:
pageDown(true);
return true;
case KeyEvent.KEYCODE_DPAD_LEFT:
nativeClearCursor();
return pinScrollTo(0,mScrollY,true,0);
case KeyEvent.KEYCODE_DPAD_RIGHT:
nativeClearCursor();
return pinScrollTo(mContentWidth,mScrollY,true,0);
}
}
if (mSelectingText) {
int xRate=keyCode == KeyEvent.KEYCODE_DPAD_LEFT ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ? 1 : 0;
int yRate=keyCode == KeyEvent.KEYCODE_DPAD_UP ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_DOWN ? 1 : 0;
int multiplier=event.getRepeatCount() + 1;
moveSelection(xRate * multiplier,yRate * multiplier);
return true;
}
if (navHandledKey(keyCode,1,false,event.getEventTime())) {
playSoundEffect(keyCodeToSoundsEffect(keyCode));
return true;
}
return false;
}
if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
switchOutDrawHistory();
boolean wantsKeyEvents=nativeCursorNodePointer() == 0 || nativeCursorWantsKeyEvents();
if (event.getRepeatCount() == 0) {
if (mSelectingText) {
return true;
}
mGotCenterDown=true;
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER),LONG_PRESS_TIMEOUT);
nativeRecordButtons(hasFocus() && hasWindowFocus(),true,true);
if (!wantsKeyEvents) return true;
}
if (!wantsKeyEvents) return false;
}
if (getSettings().getNavDump()) {
switch (keyCode) {
case KeyEvent.KEYCODE_4:
dumpDisplayTree();
break;
case KeyEvent.KEYCODE_5:
case KeyEvent.KEYCODE_6:
dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
break;
case KeyEvent.KEYCODE_7:
case KeyEvent.KEYCODE_8:
dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
break;
case KeyEvent.KEYCODE_9:
nativeInstrumentReport();
return true;
}
}
if (nativeCursorIsTextInput()) {
mWebViewCore.sendMessage(EventHub.FAKE_CLICK,nativeCursorFramePointer(),nativeCursorNodePointer());
rebuildWebTextView();
if (inEditingMode()) {
mWebTextView.setDefaultSelection();
return mWebTextView.dispatchKeyEvent(event);
}
}
 else if (nativeHasFocusNode()) {
rebuildWebTextView();
if (inEditingMode()) {
mWebTextView.setDefaultSelection();
return mWebTextView.dispatchKeyEvent(event);
}
}
if (nativeCursorWantsKeyEvents() || true) {
mWebViewCore.sendMessage(EventHub.KEY_DOWN,event);
return true;
}
return false;
}
@Override public boolean onKeyUp(int keyCode,KeyEvent event){
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"keyUp at " + System.currentTimeMillis() + ", "+ event+ ", unicode="+ event.getUnicodeChar());
}
if (mBlockWebkitViewMessages) {
return false;
}
if (mNativeClass == 0) {
return false;
}
if (keyCode == KeyEvent.KEYCODE_CALL && nativeHasCursorNode()) {
String text=nativeCursorText();
if (!nativeCursorIsTextInput() && text != null && text.startsWith(SCHEME_TEL)) {
Intent intent=new Intent(Intent.ACTION_DIAL,Uri.parse(text));
getContext().startActivity(intent);
return true;
}
}
if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
return false;
}
if (accessibilityScriptInjected()) {
if (AccessibilityManager.getInstance(mContext).isEnabled()) {
mWebViewCore.sendMessage(EventHub.KEY_UP,event);
return true;
}
 else {
mAccessibilityScriptInjected=false;
}
}
 else if (mAccessibilityInjector != null) {
if (AccessibilityManager.getInstance(mContext).isEnabled()) {
if (mAccessibilityInjector.onKeyEvent(event)) {
return true;
}
}
 else {
mAccessibilityInjector=null;
}
}
if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
if (nativePageShouldHandleShiftAndArrows()) {
letPageHandleNavKey(keyCode,event.getEventTime(),false,event.getMetaState());
return true;
}
return false;
}
if (isEnterActionKey(keyCode)) {
mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
mGotCenterDown=false;
if (mSelectingText) {
if (mExtendSelection) {
copySelection();
selectionDone();
}
 else {
mExtendSelection=true;
nativeSetExtendSelection();
invalidate();
}
return true;
}
Rect visibleRect=sendOurVisibleRect();
if (!nativeCursorIntersects(visibleRect)) {
return false;
}
WebViewCore.CursorData data=cursorData();
mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE,data);
playSoundEffect(SoundEffectConstants.CLICK);
if (nativeCursorIsTextInput()) {
rebuildWebTextView();
centerKeyPressOnTextField();
if (inEditingMode()) {
mWebTextView.setDefaultSelection();
}
return true;
}
clearTextEntry();
nativeShowCursorTimed();
if (mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
return true;
}
if (nativeCursorNodePointer() != 0 && !nativeCursorWantsKeyEvents()) {
mWebViewCore.sendMessage(EventHub.CLICK,data.mFrame,nativeCursorNodePointer());
return true;
}
}
if (nativeCursorWantsKeyEvents() || true) {
mWebViewCore.sendMessage(EventHub.KEY_UP,event);
return true;
}
return false;
}
private boolean setUpSelect(boolean selectWord,int x,int y){
if (0 == mNativeClass) return false;
if (inFullScreenMode()) return false;
if (mSelectingText) return true;
nativeResetSelection();
if (selectWord && !nativeWordSelection(x,y)) {
selectionDone();
return false;
}
mSelectCallback=new SelectActionModeCallback();
mSelectCallback.setWebView(this);
if (startActionMode(mSelectCallback) == null) {
selectionDone();
return false;
}
mExtendSelection=false;
mSelectingText=mDrawSelectionPointer=true;
WebViewCore.pauseUpdatePicture(mWebViewCore);
if (nativeHasCursorNode()) {
Rect rect=nativeCursorNodeBounds();
mSelectX=contentToViewX(rect.left);
mSelectY=contentToViewY(rect.top);
}
 else if (mLastTouchY > getVisibleTitleHeightImpl()) {
mSelectX=mScrollX + mLastTouchX;
mSelectY=mScrollY + mLastTouchY;
}
 else {
mSelectX=mScrollX + getViewWidth() / 2;
mSelectY=mScrollY + getViewHeightWithTitle() / 2;
}
nativeHideCursor();
mMinAutoScrollX=0;
mMaxAutoScrollX=getViewWidth();
mMinAutoScrollY=0;
mMaxAutoScrollY=getViewHeightWithTitle();
mScrollingLayer=nativeScrollableLayer(viewToContentX(mSelectX),viewToContentY(mSelectY),mScrollingLayerRect,mScrollingLayerBounds);
if (mScrollingLayer != 0) {
if (mScrollingLayerRect.left != mScrollingLayerRect.right) {
mMinAutoScrollX=Math.max(mMinAutoScrollX,contentToViewX(mScrollingLayerBounds.left));
mMaxAutoScrollX=Math.min(mMaxAutoScrollX,contentToViewX(mScrollingLayerBounds.right));
}
if (mScrollingLayerRect.top != mScrollingLayerRect.bottom) {
mMinAutoScrollY=Math.max(mMinAutoScrollY,contentToViewY(mScrollingLayerBounds.top));
mMaxAutoScrollY=Math.min(mMaxAutoScrollY,contentToViewY(mScrollingLayerBounds.bottom));
}
}
mMinAutoScrollX+=SELECT_SCROLL;
mMaxAutoScrollX-=SELECT_SCROLL;
mMinAutoScrollY+=SELECT_SCROLL;
mMaxAutoScrollY-=SELECT_SCROLL;
return true;
}
@Deprecated public void emulateShiftHeld(){
checkThread();
setUpSelect(false,0,0);
}
public void selectAll(){
if (0 == mNativeClass) return;
if (inFullScreenMode()) return;
if (!mSelectingText) {
Point select=nativeSelectableText();
if (!selectText(select.x,select.y)) return;
}
nativeSelectAll();
mDrawSelectionPointer=false;
mExtendSelection=true;
invalidate();
}
void selectionDone(){
if (mSelectingText) {
mSelectingText=false;
mSelectCallback.finish();
mSelectCallback=null;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
invalidate();
mAutoScrollX=0;
mAutoScrollY=0;
mSentAutoScrollMessage=false;
}
}
public boolean copySelection(){
boolean copiedSomething=false;
String selection=getSelection();
if (selection != null && selection != "") {
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"copySelection \"" + selection + "\"");
}
Toast.makeText(mContext,com.android.internal.R.string.text_copied,Toast.LENGTH_SHORT).show();
copiedSomething=true;
ClipboardManager cm=(ClipboardManager)getContext().getSystemService(Context.CLIPBOARD_SERVICE);
cm.setText(selection);
}
invalidate();
return copiedSomething;
}
public SearchBox getSearchBox(){
if ((mWebViewCore == null) || (mWebViewCore.getBrowserFrame() == null)) {
return null;
}
return mWebViewCore.getBrowserFrame().getSearchBox();
}
String getSelection(){
if (mNativeClass == 0) return "";
return nativeGetSelection();
}
@Override protected void onAttachedToWindow(){
super.onAttachedToWindow();
if (hasWindowFocus()) setActive(true);
final ViewTreeObserver treeObserver=getViewTreeObserver();
if (mGlobalLayoutListener == null) {
mGlobalLayoutListener=new InnerGlobalLayoutListener();
treeObserver.addOnGlobalLayoutListener(mGlobalLayoutListener);
}
if (mScrollChangedListener == null) {
mScrollChangedListener=new InnerScrollChangedListener();
treeObserver.addOnScrollChangedListener(mScrollChangedListener);
}
addAccessibilityApisToJavaScript();
mTouchEventQueue.reset();
}
@Override protected void onDetachedFromWindow(){
clearHelpers();
mZoomManager.dismissZoomPicker();
if (hasWindowFocus()) setActive(false);
final ViewTreeObserver treeObserver=getViewTreeObserver();
if (mGlobalLayoutListener != null) {
treeObserver.removeGlobalOnLayoutListener(mGlobalLayoutListener);
mGlobalLayoutListener=null;
}
if (mScrollChangedListener != null) {
treeObserver.removeOnScrollChangedListener(mScrollChangedListener);
mScrollChangedListener=null;
}
removeAccessibilityApisFromJavaScript();
super.onDetachedFromWindow();
}
@Override protected void onVisibilityChanged(View changedView,int visibility){
super.onVisibilityChanged(changedView,visibility);
if (visibility != View.VISIBLE && mZoomManager != null) {
mZoomManager.dismissZoomPicker();
}
}
@Deprecated public void onChildViewAdded(View parent,View child){
}
@Deprecated public void onChildViewRemoved(View p,View child){
}
@Deprecated public void onGlobalFocusChanged(View oldFocus,View newFocus){
}
void setActive(boolean active){
if (active) {
if (hasFocus()) {
mDrawCursorRing=true;
setFocusControllerActive(true);
if (mNativeClass != 0) {
nativeRecordButtons(true,false,true);
}
}
 else {
if (!inEditingMode()) {
mDrawCursorRing=false;
setFocusControllerActive(false);
}
}
}
 else {
if (!mZoomManager.isZoomPickerVisible()) {
mDrawCursorRing=false;
}
mKeysPressed.clear();
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
mTouchMode=TOUCH_DONE_MODE;
if (mNativeClass != 0) {
nativeRecordButtons(false,false,true);
}
setFocusControllerActive(false);
}
invalidate();
}
@Override public void onWindowFocusChanged(boolean hasWindowFocus){
setActive(hasWindowFocus);
if (hasWindowFocus) {
JWebCoreJavaBridge.setActiveWebView(this);
}
 else {
JWebCoreJavaBridge.removeActiveWebView(this);
}
super.onWindowFocusChanged(hasWindowFocus);
}
void setFocusControllerActive(boolean active){
if (mWebViewCore == null) return;
mWebViewCore.sendMessage(EventHub.SET_ACTIVE,active ? 1 : 0,0);
if (active && mListBoxMessage != null) {
mWebViewCore.sendMessage(mListBoxMessage);
mListBoxMessage=null;
}
}
@Override protected void onFocusChanged(boolean focused,int direction,Rect previouslyFocusedRect){
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"MT focusChanged " + focused + ", "+ direction);
}
if (focused) {
if (hasWindowFocus()) {
mDrawCursorRing=true;
if (mNativeClass != 0) {
nativeRecordButtons(true,false,true);
}
setFocusControllerActive(true);
}
}
 else {
if (!inEditingMode()) {
mDrawCursorRing=false;
if (mNativeClass != 0) {
nativeRecordButtons(false,false,true);
}
setFocusControllerActive(false);
}
mKeysPressed.clear();
}
super.onFocusChanged(focused,direction,previouslyFocusedRect);
}
void setGLRectViewport(){
boolean visible=getGlobalVisibleRect(mGLRectViewport);
if (visible) {
View rootView=getRootView();
int rootViewHeight=rootView.getHeight();
mViewRectViewport.set(mGLRectViewport);
int savedWebViewBottom=mGLRectViewport.bottom;
mGLRectViewport.bottom=rootViewHeight - mGLRectViewport.top - getVisibleTitleHeightImpl();
mGLRectViewport.top=rootViewHeight - savedWebViewBottom;
mGLViewportEmpty=false;
}
 else {
mGLViewportEmpty=true;
}
nativeUpdateDrawGLFunction(mGLViewportEmpty ? null : mGLRectViewport,mGLViewportEmpty ? null : mViewRectViewport);
}
@Override protected boolean setFrame(int left,int top,int right,int bottom){
boolean changed=super.setFrame(left,top,right,bottom);
if (!changed && mHeightCanMeasure) {
sendViewSizeZoom(false);
}
setGLRectViewport();
return changed;
}
@Override protected void onSizeChanged(int w,int h,int ow,int oh){
super.onSizeChanged(w,h,ow,oh);
int newMaxViewportWidth=(int)(Math.max(w,h) / mZoomManager.getDefaultMinZoomScale());
if (newMaxViewportWidth > sMaxViewportWidth) {
sMaxViewportWidth=newMaxViewportWidth;
}
mZoomManager.onSizeChanged(w,h,ow,oh);
if (mLoadedPicture != null && mDelaySetPicture == null) {
setNewPicture(mLoadedPicture,false);
}
}
@Override protected void onScrollChanged(int l,int t,int oldl,int oldt){
super.onScrollChanged(l,t,oldl,oldt);
if (!mInOverScrollMode) {
sendOurVisibleRect();
int titleHeight=getTitleHeight();
if (Math.max(titleHeight - t,0) != Math.max(titleHeight - oldt,0)) {
sendViewSizeZoom(false);
}
}
}
@Override public boolean dispatchKeyEvent(KeyEvent event){
switch (event.getAction()) {
case KeyEvent.ACTION_DOWN:
mKeysPressed.add(Integer.valueOf(event.getKeyCode()));
break;
case KeyEvent.ACTION_MULTIPLE:
break;
case KeyEvent.ACTION_UP:
int location=mKeysPressed.indexOf(Integer.valueOf(event.getKeyCode()));
if (location == -1) {
return false;
}
 else {
mKeysPressed.remove(location);
}
break;
default :
break;
}
if (inEditingMode() && mWebTextView.isFocused()) {
return mWebTextView.dispatchKeyEvent(event);
}
 else {
return super.dispatchKeyEvent(event);
}
}
private static final float HSLOPE_TO_START_SNAP=.25f;
private static final float HSLOPE_TO_BREAK_SNAP=.4f;
private static final float VSLOPE_TO_START_SNAP=1.25f;
private static final float VSLOPE_TO_BREAK_SNAP=.95f;
private static final float ANGLE_VERT=2f;
private static final float ANGLE_HORIZ=0f;
private static final float MMA_WEIGHT_N=5;
private boolean hitFocusedPlugin(int contentX,int contentY){
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"nativeFocusIsPlugin()=" + nativeFocusIsPlugin());
Rect r=nativeFocusNodeBounds();
Log.v(LOGTAG,"nativeFocusNodeBounds()=(" + r.left + ", "+ r.top+ ", "+ r.right+ ", "+ r.bottom+ ")");
}
return nativeFocusIsPlugin() && nativeFocusNodeBounds().contains(contentX,contentY);
}
private boolean shouldForwardTouchEvent(){
if (mFullScreenHolder != null) return true;
if (mBlockWebkitViewMessages) return false;
return mForwardTouchEvents && !mSelectingText && mPreventDefault != PREVENT_DEFAULT_IGNORE && mPreventDefault != PREVENT_DEFAULT_NO;
}
private boolean inFullScreenMode(){
return mFullScreenHolder != null;
}
private void dismissFullScreenMode(){
if (inFullScreenMode()) {
mFullScreenHolder.hide();
mFullScreenHolder=null;
}
}
void onPinchToZoomAnimationStart(){
cancelTouch();
onZoomAnimationStart();
}
void onPinchToZoomAnimationEnd(ScaleGestureDetector detector){
onZoomAnimationEnd();
mTouchMode=TOUCH_PINCH_DRAG;
mConfirmMove=true;
startTouch(detector.getFocusX(),detector.getFocusY(),mLastTouchTime);
}
private void startScrollingLayer(float x,float y){
int contentX=viewToContentX((int)x + mScrollX);
int contentY=viewToContentY((int)y + mScrollY);
mScrollingLayer=nativeScrollableLayer(contentX,contentY,mScrollingLayerRect,mScrollingLayerBounds);
if (mScrollingLayer != 0) {
mTouchMode=TOUCH_DRAG_LAYER_MODE;
}
}
private float DRAG_LAYER_INVERSE_DENSITY_SQUARED;
private static final int DRAG_LAYER_FINGER_DISTANCE=20000;
@Override public boolean onHoverEvent(MotionEvent event){
if (mNativeClass == 0) {
return false;
}
WebViewCore.CursorData data=cursorDataNoPosition();
data.mX=viewToContentX((int)event.getX() + mScrollX);
data.mY=viewToContentY((int)event.getY() + mScrollY);
mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE,data);
return true;
}
@Override public boolean onTouchEvent(MotionEvent ev){
if (mNativeClass == 0 || (!isClickable() && !isLongClickable())) {
return false;
}
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,ev + " at " + ev.getEventTime()+ " mTouchMode="+ mTouchMode+ " numPointers="+ ev.getPointerCount());
}
if (ev.getPointerCount() > 1 && mPreventDefault != PREVENT_DEFAULT_NO) {
passMultiTouchToWebKit(ev,mTouchEventQueue.nextTouchSequence());
}
 else {
mTouchEventQueue.enqueueTouchEvent(ev);
}
return true;
}
private float calculateDragAngle(int dx,int dy){
dx=Math.abs(dx);
dy=Math.abs(dy);
return (float)Math.atan2(dy,dx);
}
private boolean handleTouchEventCommon(MotionEvent ev,int action,int x,int y){
long eventTime=ev.getEventTime();
x=Math.min(x,getViewWidth() - 1);
y=Math.min(y,getViewHeightWithTitle() - 1);
int deltaX=mLastTouchX - x;
int deltaY=mLastTouchY - y;
int contentX=viewToContentX(x + mScrollX);
int contentY=viewToContentY(y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
mPreventDefault=PREVENT_DEFAULT_NO;
mConfirmMove=false;
mInitialHitTestResult=null;
if (!mScroller.isFinished()) {
mScroller.abortAnimation();
mTouchMode=TOUCH_DRAG_START_MODE;
mConfirmMove=true;
mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
}
 else if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
if (USE_WEBKIT_RINGS || getSettings().supportTouchOnly()) {
removeTouchHighlight();
}
if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
mTouchMode=TOUCH_DOUBLE_TAP_MODE;
}
 else {
doShortPress();
mTouchMode=TOUCH_INIT_MODE;
mDeferTouchProcess=!mBlockWebkitViewMessages && (!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
}
}
 else {
mTouchMode=TOUCH_INIT_MODE;
mDeferTouchProcess=!mBlockWebkitViewMessages && (!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
if (!mBlockWebkitViewMessages) {
mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
}
if (USE_WEBKIT_RINGS || getSettings().supportTouchOnly()) {
TouchHighlightData data=new TouchHighlightData();
data.mX=contentX;
data.mY=contentY;
data.mNativeLayerRect=new Rect();
data.mNativeLayer=nativeScrollableLayer(contentX,contentY,data.mNativeLayerRect,null);
data.mSlop=viewToContentDimension(mNavSlop);
mTouchHighlightRegion.setEmpty();
if (!mBlockWebkitViewMessages) {
mTouchHighlightRequested=System.currentTimeMillis();
mWebViewCore.sendMessageAtFrontOfQueue(EventHub.GET_TOUCH_HIGHLIGHT_RECTS,data);
}
if (DEBUG_TOUCH_HIGHLIGHT) {
if (getSettings().getNavDump()) {
mTouchHighlightX=(int)x + mScrollX;
mTouchHighlightY=(int)y + mScrollY;
mPrivateHandler.postDelayed(new Runnable(){
public void run(){
mTouchHighlightX=mTouchHighlightY=0;
invalidate();
}
}
,TOUCH_HIGHLIGHT_ELAPSE_TIME);
}
}
}
if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
}
if (mSelectingText) {
mDrawSelectionPointer=false;
mSelectionStarted=nativeStartSelection(contentX,contentY);
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"select=" + contentX + ","+ contentY);
}
invalidate();
}
}
if (!mSelectingText && (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE)) {
mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
if (inFullScreenMode() || mDeferTouchProcess) {
mPreventDefault=PREVENT_DEFAULT_YES;
}
 else if (!mBlockWebkitViewMessages && mForwardTouchEvents) {
mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
}
 else {
mPreventDefault=PREVENT_DEFAULT_NO;
}
if (shouldForwardTouchEvent()) {
TouchEventData ted=new TouchEventData();
ted.mAction=action;
ted.mIds=new int[1];
ted.mIds[0]=ev.getPointerId(0);
ted.mPoints=new Point[1];
ted.mPoints[0]=new Point(contentX,contentY);
ted.mPointsInView=new Point[1];
ted.mPointsInView[0]=new Point(x,y);
ted.mMetaState=ev.getMetaState();
ted.mReprocess=mDeferTouchProcess;
ted.mNativeLayer=nativeScrollableLayer(contentX,contentY,ted.mNativeLayerRect,null);
ted.mSequence=mTouchEventQueue.nextTouchSequence();
mTouchEventQueue.preQueueTouchEventData(ted);
mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
if (mDeferTouchProcess) {
mLastTouchX=x;
mLastTouchY=y;
break;
}
if (!inFullScreenMode()) {
mPrivateHandler.removeMessages(PREVENT_DEFAULT_TIMEOUT);
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
}
}
}
startTouch(x,y,eventTime);
break;
}
case MotionEvent.ACTION_MOVE:
{
boolean firstMove=false;
if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
mConfirmMove=true;
firstMove=true;
if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
mTouchMode=TOUCH_INIT_MODE;
}
if (USE_WEBKIT_RINGS || getSettings().supportTouchOnly()) {
removeTouchHighlight();
}
}
if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
TouchEventData ted=new TouchEventData();
ted.mAction=action;
ted.mIds=new int[1];
ted.mIds[0]=ev.getPointerId(0);
ted.mPoints=new Point[1];
ted.mPoints[0]=new Point(contentX,contentY);
ted.mPointsInView=new Point[1];
ted.mPointsInView[0]=new Point(x,y);
ted.mMetaState=ev.getMetaState();
ted.mReprocess=mDeferTouchProcess;
ted.mNativeLayer=mScrollingLayer;
ted.mNativeLayerRect.set(mScrollingLayerRect);
ted.mSequence=mTouchEventQueue.nextTouchSequence();
mTouchEventQueue.preQueueTouchEventData(ted);
mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
mLastSentTouchTime=eventTime;
if (mDeferTouchProcess) {
break;
}
if (firstMove && !inFullScreenMode()) {
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
}
}
if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
break;
}
if (mVelocityTracker == null) {
Log.e(LOGTAG,"Got null mVelocityTracker when " + "mPreventDefault = " + mPreventDefault + " mDeferTouchProcess = "+ mDeferTouchProcess+ " mTouchMode = "+ mTouchMode);
}
 else {
mVelocityTracker.addMovement(ev);
}
if (mSelectingText && mSelectionStarted) {
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"extend=" + contentX + ","+ contentY);
}
ViewParent parent=getParent();
if (parent != null) {
parent.requestDisallowInterceptTouchEvent(true);
}
mAutoScrollX=x <= mMinAutoScrollX ? -SELECT_SCROLL : x >= mMaxAutoScrollX ? SELECT_SCROLL : 0;
mAutoScrollY=y <= mMinAutoScrollY ? -SELECT_SCROLL : y >= mMaxAutoScrollY ? SELECT_SCROLL : 0;
if ((mAutoScrollX != 0 || mAutoScrollY != 0) && !mSentAutoScrollMessage) {
mSentAutoScrollMessage=true;
mPrivateHandler.sendEmptyMessageDelayed(SCROLL_SELECT_TEXT,SELECT_SCROLL_INTERVAL);
}
if (deltaX != 0 || deltaY != 0) {
nativeExtendSelection(contentX,contentY);
invalidate();
}
break;
}
if (mTouchMode != TOUCH_DRAG_MODE && mTouchMode != TOUCH_DRAG_LAYER_MODE) {
if (!mConfirmMove) {
break;
}
if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
mLastTouchTime=eventTime;
break;
}
final ScaleGestureDetector detector=mZoomManager.getMultiTouchGestureDetector();
mAverageAngle=calculateDragAngle(deltaX,deltaY);
if (detector == null || !detector.isInProgress()) {
if (mAverageAngle < HSLOPE_TO_START_SNAP) {
mSnapScrollMode=SNAP_X;
mSnapPositive=deltaX > 0;
mAverageAngle=ANGLE_HORIZ;
}
 else if (mAverageAngle > VSLOPE_TO_START_SNAP) {
mSnapScrollMode=SNAP_Y;
mSnapPositive=deltaY > 0;
mAverageAngle=ANGLE_VERT;
}
}
mTouchMode=TOUCH_DRAG_MODE;
mLastTouchX=x;
mLastTouchY=y;
deltaX=0;
deltaY=0;
startScrollingLayer(x,y);
startDrag();
}
boolean done=false;
boolean keepScrollBarsVisible=false;
if (deltaX == 0 && deltaY == 0) {
keepScrollBarsVisible=done=true;
}
 else {
mAverageAngle+=(calculateDragAngle(deltaX,deltaY) - mAverageAngle) / MMA_WEIGHT_N;
if (mSnapScrollMode != SNAP_NONE) {
if (mSnapScrollMode == SNAP_Y) {
if (mAverageAngle < VSLOPE_TO_BREAK_SNAP) {
mSnapScrollMode=SNAP_NONE;
}
}
if (mSnapScrollMode == SNAP_X) {
if (mAverageAngle > HSLOPE_TO_BREAK_SNAP) {
mSnapScrollMode=SNAP_NONE;
}
}
}
 else {
if (mAverageAngle < HSLOPE_TO_START_SNAP) {
mSnapScrollMode=SNAP_X;
mSnapPositive=deltaX > 0;
mAverageAngle=(mAverageAngle + ANGLE_HORIZ) / 2;
}
 else if (mAverageAngle > VSLOPE_TO_START_SNAP) {
mSnapScrollMode=SNAP_Y;
mSnapPositive=deltaY > 0;
mAverageAngle=(mAverageAngle + ANGLE_VERT) / 2;
}
}
if (mSnapScrollMode != SNAP_NONE) {
if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
deltaY=0;
}
 else {
deltaX=0;
}
}
mLastTouchX=x;
mLastTouchY=y;
if ((deltaX | deltaY) != 0) {
mHeldMotionless=MOTIONLESS_FALSE;
}
mLastTouchTime=eventTime;
}
doDrag(deltaX,deltaY);
if (keepScrollBarsVisible && mTouchMode != TOUCH_DRAG_LAYER_MODE) {
if (mHeldMotionless != MOTIONLESS_TRUE) {
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
}
awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
return !done;
}
break;
}
case MotionEvent.ACTION_UP:
{
if (!isFocused()) requestFocus();
if (shouldForwardTouchEvent()) {
TouchEventData ted=new TouchEventData();
ted.mIds=new int[1];
ted.mIds[0]=ev.getPointerId(0);
ted.mAction=action;
ted.mPoints=new Point[1];
ted.mPoints[0]=new Point(contentX,contentY);
ted.mPointsInView=new Point[1];
ted.mPointsInView[0]=new Point(x,y);
ted.mMetaState=ev.getMetaState();
ted.mReprocess=mDeferTouchProcess;
ted.mNativeLayer=mScrollingLayer;
ted.mNativeLayerRect.set(mScrollingLayerRect);
ted.mSequence=mTouchEventQueue.nextTouchSequence();
mTouchEventQueue.preQueueTouchEventData(ted);
mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
mLastTouchUpTime=eventTime;
if (mSentAutoScrollMessage) {
mAutoScrollX=mAutoScrollY=0;
}
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
TouchEventData ted=new TouchEventData();
ted.mIds=new int[1];
ted.mIds[0]=ev.getPointerId(0);
ted.mAction=WebViewCore.ACTION_DOUBLETAP;
ted.mPoints=new Point[1];
ted.mPoints[0]=new Point(contentX,contentY);
ted.mPointsInView=new Point[1];
ted.mPointsInView[0]=new Point(x,y);
ted.mMetaState=ev.getMetaState();
ted.mReprocess=mDeferTouchProcess;
ted.mNativeLayer=nativeScrollableLayer(contentX,contentY,ted.mNativeLayerRect,null);
ted.mSequence=mTouchEventQueue.nextTouchSequence();
mTouchEventQueue.preQueueTouchEventData(ted);
mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
mZoomManager.handleDoubleTap(mLastTouchX,mLastTouchY);
mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,"Miss a drag as we are waiting for" + " WebCore's response for touch down.");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mSelectingText) {
if (!nativeHitSelection(contentX,contentY)) {
selectionDone();
}
break;
}
if (mTouchMode == TOUCH_INIT_MODE && (canZoomIn() || canZoomOut())) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
case TOUCH_DRAG_LAYER_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,"Got null mVelocityTracker when " + "mPreventDefault = " + mPreventDefault + " mDeferTouchProcess = "+ mDeferTouchProcess);
}
 else {
mVelocityTracker.addMovement(ev);
}
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
 else {
if (mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY())) {
invalidate();
}
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
if (!mSelectingText) {
WebViewCore.resumeUpdatePicture(mWebViewCore);
}
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY());
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}
private void passMultiTouchToWebKit(MotionEvent ev,long sequence){
TouchEventData ted=new TouchEventData();
ted.mAction=ev.getActionMasked();
final int count=ev.getPointerCount();
ted.mIds=new int[count];
ted.mPoints=new Point[count];
ted.mPointsInView=new Point[count];
for (int c=0; c < count; c++) {
ted.mIds[c]=ev.getPointerId(c);
int x=viewToContentX((int)ev.getX(c) + mScrollX);
int y=viewToContentY((int)ev.getY(c) + mScrollY);
ted.mPoints[c]=new Point(x,y);
ted.mPointsInView[c]=new Point((int)ev.getX(c),(int)ev.getY(c));
}
if (ted.mAction == MotionEvent.ACTION_POINTER_DOWN || ted.mAction == MotionEvent.ACTION_POINTER_UP) {
ted.mActionIndex=ev.getActionIndex();
}
ted.mMetaState=ev.getMetaState();
ted.mReprocess=true;
ted.mMotionEvent=MotionEvent.obtain(ev);
ted.mSequence=sequence;
mTouchEventQueue.preQueueTouchEventData(ted);
mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
cancelLongPress();
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
}
void handleMultiTouchInWebView(MotionEvent ev){
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"multi-touch: " + ev + " at "+ ev.getEventTime()+ " mTouchMode="+ mTouchMode+ " numPointers="+ ev.getPointerCount()+ " scrolloffset=("+ mScrollX+ ","+ mScrollY+ ")");
}
final ScaleGestureDetector detector=mZoomManager.getMultiTouchGestureDetector();
if (detector == null) return;
float x=ev.getX();
float y=ev.getY();
if (mPreventDefault != PREVENT_DEFAULT_YES) {
detector.onTouchEvent(ev);
if (detector.isInProgress()) {
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"detector is in progress");
}
mLastTouchTime=ev.getEventTime();
x=detector.getFocusX();
y=detector.getFocusY();
cancelLongPress();
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (!mZoomManager.supportsPanDuringZoom()) {
return;
}
mTouchMode=TOUCH_DRAG_MODE;
if (mVelocityTracker == null) {
mVelocityTracker=VelocityTracker.obtain();
}
}
}
int action=ev.getActionMasked();
if (action == MotionEvent.ACTION_POINTER_DOWN) {
cancelTouch();
action=MotionEvent.ACTION_DOWN;
}
 else if (action == MotionEvent.ACTION_POINTER_UP && ev.getPointerCount() >= 2) {
mLastTouchX=Math.round(x);
mLastTouchY=Math.round(y);
}
 else if (action == MotionEvent.ACTION_MOVE) {
if (x < 0 || y < 0) {
return;
}
}
handleTouchEventCommon(ev,action,Math.round(x),Math.round(y));
}
private void cancelWebCoreTouchEvent(int x,int y,boolean removeEvents){
if (shouldForwardTouchEvent()) {
if (removeEvents) {
mWebViewCore.removeMessages(EventHub.TOUCH_EVENT);
}
TouchEventData ted=new TouchEventData();
ted.mIds=new int[1];
ted.mIds[0]=0;
ted.mPoints=new Point[1];
ted.mPoints[0]=new Point(x,y);
ted.mPointsInView=new Point[1];
int viewX=contentToViewX(x) - mScrollX;
int viewY=contentToViewY(y) - mScrollY;
ted.mPointsInView[0]=new Point(viewX,viewY);
ted.mAction=MotionEvent.ACTION_CANCEL;
ted.mNativeLayer=nativeScrollableLayer(x,y,ted.mNativeLayerRect,null);
ted.mSequence=mTouchEventQueue.nextTouchSequence();
mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
mPreventDefault=PREVENT_DEFAULT_IGNORE;
if (removeEvents) {
mTouchEventQueue.ignoreCurrentlyMissingEvents();
}
}
}
private void startTouch(float x,float y,long eventTime){
mStartTouchX=mLastTouchX=Math.round(x);
mStartTouchY=mLastTouchY=Math.round(y);
mLastTouchTime=eventTime;
mVelocityTracker=VelocityTracker.obtain();
mSnapScrollMode=SNAP_NONE;
}
private void startDrag(){
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
nativeSetIsScrolling(true);
if (!mDragFromTextInput) {
nativeHideCursor();
}
if (mHorizontalScrollBarMode != SCROLLBAR_ALWAYSOFF || mVerticalScrollBarMode != SCROLLBAR_ALWAYSOFF) {
mZoomManager.invokeZoomPicker();
}
}
private void doDrag(int deltaX,int deltaY){
if ((deltaX | deltaY) != 0) {
int oldX=mScrollX;
int oldY=mScrollY;
int rangeX=computeMaxScrollX();
int rangeY=computeMaxScrollY();
int overscrollDistance=mOverscrollDistance;
if (mScrollingLayer != 0) {
final int contentX=viewToContentDimension(deltaX);
final int contentY=viewToContentDimension(deltaY);
final int maxX=mScrollingLayerRect.right;
final int maxY=mScrollingLayerRect.bottom;
final int resultX=Math.max(0,Math.min(mScrollingLayerRect.left + contentX,maxX));
final int resultY=Math.max(0,Math.min(mScrollingLayerRect.top + contentY,maxY));
if (resultX != mScrollingLayerRect.left || resultY != mScrollingLayerRect.top) {
mTouchMode=TOUCH_DRAG_LAYER_MODE;
deltaX=contentX;
deltaY=contentY;
oldX=mScrollingLayerRect.left;
oldY=mScrollingLayerRect.top;
rangeX=maxX;
rangeY=maxY;
}
 else {
mTouchMode=TOUCH_DRAG_MODE;
}
}
if (mOverScrollGlow != null) {
mOverScrollGlow.setOverScrollDeltas(deltaX,deltaY);
}
overScrollBy(deltaX,deltaY,oldX,oldY,rangeX,rangeY,mOverscrollDistance,mOverscrollDistance,true);
if (mOverScrollGlow != null && mOverScrollGlow.isAnimating()) {
invalidate();
}
}
mZoomManager.keepZoomPickerVisible();
}
private void stopTouch(){
if (mScroller.isFinished() && !mSelectingText && (mTouchMode == TOUCH_DRAG_MODE || mTouchMode == TOUCH_DRAG_LAYER_MODE)) {
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
nativeSetIsScrolling(false);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mOverScrollGlow != null) {
mOverScrollGlow.releaseAll();
}
}
private void cancelTouch(){
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if ((mTouchMode == TOUCH_DRAG_MODE || mTouchMode == TOUCH_DRAG_LAYER_MODE) && !mSelectingText) {
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
nativeSetIsScrolling(false);
}
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (USE_WEBKIT_RINGS || getSettings().supportTouchOnly()) {
removeTouchHighlight();
}
mHeldMotionless=MOTIONLESS_TRUE;
mTouchMode=TOUCH_DONE_MODE;
nativeHideCursor();
}
@Override public boolean onGenericMotionEvent(MotionEvent event){
if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
switch (event.getAction()) {
case MotionEvent.ACTION_SCROLL:
{
final float vscroll;
final float hscroll;
if ((event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0) {
vscroll=0;
hscroll=event.getAxisValue(MotionEvent.AXIS_VSCROLL);
}
 else {
vscroll=-event.getAxisValue(MotionEvent.AXIS_VSCROLL);
hscroll=event.getAxisValue(MotionEvent.AXIS_HSCROLL);
}
if (hscroll != 0 || vscroll != 0) {
final int vdelta=(int)(vscroll * getVerticalScrollFactor());
final int hdelta=(int)(hscroll * getHorizontalScrollFactor());
if (pinScrollBy(hdelta,vdelta,false,0)) {
return true;
}
}
}
}
}
return super.onGenericMotionEvent(event);
}
private long mTrackballFirstTime=0;
private long mTrackballLastTime=0;
private float mTrackballRemainsX=0.0f;
private float mTrackballRemainsY=0.0f;
private int mTrackballXMove=0;
private int mTrackballYMove=0;
private boolean mSelectingText=false;
private boolean mSelectionStarted=false;
private boolean mExtendSelection=false;
private boolean mDrawSelectionPointer=false;
private static final int TRACKBALL_KEY_TIMEOUT=1000;
private static final int TRACKBALL_TIMEOUT=200;
private static final int TRACKBALL_WAIT=100;
private static final int TRACKBALL_SCALE=400;
private static final int TRACKBALL_SCROLL_COUNT=5;
private static final int TRACKBALL_MOVE_COUNT=10;
private static final int TRACKBALL_MULTIPLIER=3;
private static final int SELECT_CURSOR_OFFSET=16;
private static final int SELECT_SCROLL=5;
private int mSelectX=0;
private int mSelectY=0;
private boolean mFocusSizeChanged=false;
private boolean mTrackballDown=false;
private long mTrackballUpTime=0;
private long mLastCursorTime=0;
private Rect mLastCursorBounds;
private boolean mMapTrackballToArrowKeys=true;
private DrawData mDelaySetPicture;
private DrawData mLoadedPicture;
public void setMapTrackballToArrowKeys(boolean setMap){
checkThread();
mMapTrackballToArrowKeys=setMap;
}
void resetTrackballTime(){
mTrackballLastTime=0;
}
@Override public boolean onTrackballEvent(MotionEvent ev){
long time=ev.getEventTime();
if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
if (ev.getY() > 0) pageDown(true);
if (ev.getY() < 0) pageUp(true);
return true;
}
if (ev.getAction() == MotionEvent.ACTION_DOWN) {
if (mSelectingText) {
return true;
}
mTrackballDown=true;
if (mNativeClass == 0) {
return false;
}
nativeRecordButtons(hasFocus() && hasWindowFocus(),true,true);
if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
nativeSelectBestAt(mLastCursorBounds);
}
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"onTrackballEvent down ev=" + ev + " time="+ time+ " mLastCursorTime="+ mLastCursorTime);
}
if (isInTouchMode()) requestFocusFromTouch();
return false;
}
if (ev.getAction() == MotionEvent.ACTION_UP) {
mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
mTrackballDown=false;
mTrackballUpTime=time;
if (mSelectingText) {
if (mExtendSelection) {
copySelection();
selectionDone();
}
 else {
mExtendSelection=true;
nativeSetExtendSelection();
invalidate();
}
return true;
}
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"onTrackballEvent up ev=" + ev + " time="+ time);
}
return false;
}
if ((mMapTrackballToArrowKeys && (ev.getMetaState() & KeyEvent.META_SHIFT_ON) == 0) || AccessibilityManager.getInstance(mContext).isEnabled()) {
if (DebugFlags.WEB_VIEW) Log.v(LOGTAG,"onTrackballEvent gmail quit");
return false;
}
if (mTrackballDown) {
if (DebugFlags.WEB_VIEW) Log.v(LOGTAG,"onTrackballEvent down quit");
return true;
}
if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
if (DebugFlags.WEB_VIEW) Log.v(LOGTAG,"onTrackballEvent up timeout quit");
return true;
}
switchOutDrawHistory();
if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"onTrackballEvent time=" + time + " last="+ mTrackballLastTime);
}
mTrackballFirstTime=time;
mTrackballXMove=mTrackballYMove=0;
}
mTrackballLastTime=time;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"onTrackballEvent ev=" + ev + " time="+ time);
}
mTrackballRemainsX+=ev.getX();
mTrackballRemainsY+=ev.getY();
doTrackball(time,ev.getMetaState());
return true;
}
void moveSelection(float xRate,float yRate){
if (mNativeClass == 0) return;
int width=getViewWidth();
int height=getViewHeight();
mSelectX+=xRate;
mSelectY+=yRate;
int maxX=width + mScrollX;
int maxY=height + mScrollY;
mSelectX=Math.min(maxX,Math.max(mScrollX - SELECT_CURSOR_OFFSET,mSelectX));
mSelectY=Math.min(maxY,Math.max(mScrollY - SELECT_CURSOR_OFFSET,mSelectY));
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"moveSelection" + " mSelectX=" + mSelectX + " mSelectY="+ mSelectY+ " mScrollX="+ mScrollX+ " mScrollY="+ mScrollY+ " xRate="+ xRate+ " yRate="+ yRate);
}
nativeMoveSelection(viewToContentX(mSelectX),viewToContentY(mSelectY));
int scrollX=mSelectX < mScrollX ? -SELECT_CURSOR_OFFSET : mSelectX > maxX - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
int scrollY=mSelectY < mScrollY ? -SELECT_CURSOR_OFFSET : mSelectY > maxY - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
pinScrollBy(scrollX,scrollY,true,0);
Rect select=new Rect(mSelectX,mSelectY,mSelectX + 1,mSelectY + 1);
requestRectangleOnScreen(select);
invalidate();
}
private int scaleTrackballX(float xRate,int width){
int xMove=(int)(xRate / TRACKBALL_SCALE * width);
int nextXMove=xMove;
if (xMove > 0) {
if (xMove > mTrackballXMove) {
xMove-=mTrackballXMove;
}
}
 else if (xMove < mTrackballXMove) {
xMove-=mTrackballXMove;
}
mTrackballXMove=nextXMove;
return xMove;
}
private int scaleTrackballY(float yRate,int height){
int yMove=(int)(yRate / TRACKBALL_SCALE * height);
int nextYMove=yMove;
if (yMove > 0) {
if (yMove > mTrackballYMove) {
yMove-=mTrackballYMove;
}
}
 else if (yMove < mTrackballYMove) {
yMove-=mTrackballYMove;
}
mTrackballYMove=nextYMove;
return yMove;
}
private int keyCodeToSoundsEffect(int keyCode){
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
return SoundEffectConstants.NAVIGATION_UP;
case KeyEvent.KEYCODE_DPAD_RIGHT:
return SoundEffectConstants.NAVIGATION_RIGHT;
case KeyEvent.KEYCODE_DPAD_DOWN:
return SoundEffectConstants.NAVIGATION_DOWN;
case KeyEvent.KEYCODE_DPAD_LEFT:
return SoundEffectConstants.NAVIGATION_LEFT;
}
throw new IllegalArgumentException("keyCode must be one of " + "{KEYCODE_DPAD_UP, KEYCODE_DPAD_RIGHT, KEYCODE_DPAD_DOWN, " + "KEYCODE_DPAD_LEFT}.");
}
private void doTrackball(long time,int metaState){
int elapsed=(int)(mTrackballLastTime - mTrackballFirstTime);
if (elapsed == 0) {
elapsed=TRACKBALL_TIMEOUT;
}
float xRate=mTrackballRemainsX * 1000 / elapsed;
float yRate=mTrackballRemainsY * 1000 / elapsed;
int viewWidth=getViewWidth();
int viewHeight=getViewHeight();
if (mSelectingText) {
if (!mDrawSelectionPointer) {
mSelectX=contentToViewX(nativeSelectionX());
mSelectY=contentToViewY(nativeSelectionY());
mDrawSelectionPointer=mExtendSelection=true;
nativeSetExtendSelection();
}
moveSelection(scaleTrackballX(xRate,viewWidth),scaleTrackballY(yRate,viewHeight));
mTrackballRemainsX=mTrackballRemainsY=0;
return;
}
float ax=Math.abs(xRate);
float ay=Math.abs(yRate);
float maxA=Math.max(ax,ay);
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"doTrackball elapsed=" + elapsed + " xRate="+ xRate+ " yRate="+ yRate+ " mTrackballRemainsX="+ mTrackballRemainsX+ " mTrackballRemainsY="+ mTrackballRemainsY);
}
int width=mContentWidth - viewWidth;
int height=mContentHeight - viewHeight;
if (width < 0) width=0;
if (height < 0) height=0;
ax=Math.abs(mTrackballRemainsX * TRACKBALL_MULTIPLIER);
ay=Math.abs(mTrackballRemainsY * TRACKBALL_MULTIPLIER);
maxA=Math.max(ax,ay);
int count=Math.max(0,(int)maxA);
int oldScrollX=mScrollX;
int oldScrollY=mScrollY;
if (count > 0) {
int selectKeyCode=ax < ay ? mTrackballRemainsY < 0 ? KeyEvent.KEYCODE_DPAD_UP : KeyEvent.KEYCODE_DPAD_DOWN : mTrackballRemainsX < 0 ? KeyEvent.KEYCODE_DPAD_LEFT : KeyEvent.KEYCODE_DPAD_RIGHT;
count=Math.min(count,TRACKBALL_MOVE_COUNT);
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"doTrackball keyCode=" + selectKeyCode + " count="+ count+ " mTrackballRemainsX="+ mTrackballRemainsX+ " mTrackballRemainsY="+ mTrackballRemainsY);
}
if (mNativeClass != 0 && nativePageShouldHandleShiftAndArrows()) {
for (int i=0; i < count; i++) {
letPageHandleNavKey(selectKeyCode,time,true,metaState);
}
letPageHandleNavKey(selectKeyCode,time,false,metaState);
}
 else if (navHandledKey(selectKeyCode,count,false,time)) {
playSoundEffect(keyCodeToSoundsEffect(selectKeyCode));
}
mTrackballRemainsX=mTrackballRemainsY=0;
}
if (count >= TRACKBALL_SCROLL_COUNT) {
int xMove=scaleTrackballX(xRate,width);
int yMove=scaleTrackballY(yRate,height);
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"doTrackball pinScrollBy" + " count=" + count + " xMove="+ xMove+ " yMove="+ yMove+ " mScrollX-oldScrollX="+ (mScrollX - oldScrollX)+ " mScrollY-oldScrollY="+ (mScrollY - oldScrollY));
}
if (Math.abs(mScrollX - oldScrollX) > Math.abs(xMove)) {
xMove=0;
}
if (Math.abs(mScrollY - oldScrollY) > Math.abs(yMove)) {
yMove=0;
}
if (xMove != 0 || yMove != 0) {
pinScrollBy(xMove,yMove,true,0);
}
}
}
int computeMaxScrollX(){
return Math.max(computeRealHorizontalScrollRange() - getViewWidth(),0);
}
int computeMaxScrollY(){
return Math.max(computeRealVerticalScrollRange() + getTitleHeight() - getViewHeightWithTitle(),0);
}
boolean updateScrollCoordinates(int x,int y){
int oldX=mScrollX;
int oldY=mScrollY;
mScrollX=x;
mScrollY=y;
if (oldX != mScrollX || oldY != mScrollY) {
onScrollChanged(mScrollX,mScrollY,oldX,oldY);
return true;
}
 else {
return false;
}
}
public void flingScroll(int vx,int vy){
checkThread();
mScroller.fling(mScrollX,mScrollY,vx,vy,0,computeMaxScrollX(),0,computeMaxScrollY(),mOverflingDistance,mOverflingDistance);
invalidate();
}
private void doFling(){
if (mVelocityTracker == null) {
return;
}
int maxX=computeMaxScrollX();
int maxY=computeMaxScrollY();
mVelocityTracker.computeCurrentVelocity(1000,mMaximumFling);
int vx=(int)mVelocityTracker.getXVelocity();
int vy=(int)mVelocityTracker.getYVelocity();
int scrollX=mScrollX;
int scrollY=mScrollY;
int overscrollDistance=mOverscrollDistance;
int overflingDistance=mOverflingDistance;
if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
scrollX=mScrollingLayerRect.left;
scrollY=mScrollingLayerRect.top;
maxX=mScrollingLayerRect.right;
maxY=mScrollingLayerRect.bottom;
overscrollDistance=overflingDistance=0;
}
if (mSnapScrollMode != SNAP_NONE) {
if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
vy=0;
}
 else {
vx=0;
}
}
if ((maxX == 0 && vy == 0) || (maxY == 0 && vx == 0)) {
WebViewCore.resumePriority();
if (!mSelectingText) {
WebViewCore.resumeUpdatePicture(mWebViewCore);
}
if (mScroller.springBack(scrollX,scrollY,0,maxX,0,maxY)) {
invalidate();
}
return;
}
float currentVelocity=mScroller.getCurrVelocity();
float velocity=(float)Math.hypot(vx,vy);
if (mLastVelocity > 0 && currentVelocity > 0 && velocity > mLastVelocity * MINIMUM_VELOCITY_RATIO_FOR_ACCELERATION) {
float deltaR=(float)(Math.abs(Math.atan2(mLastVelY,mLastVelX) - Math.atan2(vy,vx)));
final float circle=(float)(Math.PI) * 2.0f;
if (deltaR > circle * 0.9f || deltaR < circle * 0.1f) {
vx+=currentVelocity * mLastVelX / mLastVelocity;
vy+=currentVelocity * mLastVelY / mLastVelocity;
velocity=(float)Math.hypot(vx,vy);
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"doFling vx= " + vx + " vy="+ vy);
}
}
 else if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"doFling missed " + deltaR / circle);
}
}
 else if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"doFling start last=" + mLastVelocity + " current="+ currentVelocity+ " vx="+ vx+ " vy="+ vy+ " maxX="+ maxX+ " maxY="+ maxY+ " scrollX="+ scrollX+ " scrollY="+ scrollY+ " layer="+ mScrollingLayer);
}
if ((scrollX == 0 || scrollX == maxX) && Math.abs(vx) < Math.abs(vy)) {
vx=0;
}
if ((scrollY == 0 || scrollY == maxY) && Math.abs(vy) < Math.abs(vx)) {
vy=0;
}
if (overscrollDistance < overflingDistance) {
if ((vx > 0 && scrollX == -overscrollDistance) || (vx < 0 && scrollX == maxX + overscrollDistance)) {
vx=0;
}
if ((vy > 0 && scrollY == -overscrollDistance) || (vy < 0 && scrollY == maxY + overscrollDistance)) {
vy=0;
}
}
mLastVelX=vx;
mLastVelY=vy;
mLastVelocity=velocity;
mScroller.fling(scrollX,scrollY,-vx,-vy,0,maxX,0,maxY,maxX == 0 ? 0 : overflingDistance,overflingDistance);
final int time=mScroller.getDuration();
if (mTouchMode != TOUCH_DRAG_LAYER_MODE) {
awakenScrollBars(time);
}
invalidate();
}
@Deprecated public View getZoomControls(){
checkThread();
if (!getSettings().supportZoom()) {
Log.w(LOGTAG,"This WebView doesn't support zoom.");
return null;
}
return mZoomManager.getExternalZoomPicker();
}
void dismissZoomControl(){
mZoomManager.dismissZoomPicker();
}
float getDefaultZoomScale(){
return mZoomManager.getDefaultScale();
}
public boolean canZoomIn(){
checkThread();
return mZoomManager.canZoomIn();
}
public boolean canZoomOut(){
checkThread();
return mZoomManager.canZoomOut();
}
public boolean zoomIn(){
checkThread();
return mZoomManager.zoomIn();
}
public boolean zoomOut(){
checkThread();
return mZoomManager.zoomOut();
}
private void updateSelection(){
if (mNativeClass == 0) {
return;
}
int contentX=viewToContentX(mLastTouchX + mScrollX);
int contentY=viewToContentY(mLastTouchY + mScrollY);
int slop=viewToContentDimension(mNavSlop);
Rect rect=new Rect(contentX - slop,contentY - slop,contentX + slop,contentY + slop);
nativeSelectBestAt(rect);
mInitialHitTestResult=hitTestResult(null);
}
void scrollFocusedTextInputX(float xPercent){
if (!inEditingMode() || mWebViewCore == null) {
return;
}
mWebViewCore.sendMessage(EventHub.SCROLL_TEXT_INPUT,0,new Float(xPercent));
}
void scrollFocusedTextInputY(int y){
if (!inEditingMode() || mWebViewCore == null) {
return;
}
mWebViewCore.sendMessage(EventHub.SCROLL_TEXT_INPUT,0,viewToContentDimension(y));
}
void initiateTextFieldDrag(float x,float y,long eventTime){
if (!inEditingMode()) {
return;
}
mLastTouchX=Math.round(x + mWebTextView.getLeft() - mScrollX);
mLastTouchY=Math.round(y + mWebTextView.getTop() - mScrollY);
mLastTouchTime=eventTime;
if (!mScroller.isFinished()) {
abortAnimation();
mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
}
mSnapScrollMode=SNAP_NONE;
mVelocityTracker=VelocityTracker.obtain();
mTouchMode=TOUCH_DRAG_START_MODE;
}
boolean textFieldDrag(MotionEvent event){
if (!inEditingMode()) {
return false;
}
mDragFromTextInput=true;
event.offsetLocation((float)(mWebTextView.getLeft() - mScrollX),(float)(mWebTextView.getTop() - mScrollY));
boolean result=onTouchEvent(event);
mDragFromTextInput=false;
return result;
}
void touchUpOnTextField(MotionEvent event){
if (!inEditingMode()) {
return;
}
int x=viewToContentX((int)event.getX() + mWebTextView.getLeft());
int y=viewToContentY((int)event.getY() + mWebTextView.getTop());
int slop=viewToContentDimension(mNavSlop);
nativeMotionUp(x,y,slop);
}
void centerKeyPressOnTextField(){
mWebViewCore.sendMessage(EventHub.CLICK,nativeCursorFramePointer(),nativeCursorNodePointer());
}
private void doShortPress(){
if (mNativeClass == 0) {
return;
}
if (mPreventDefault == PREVENT_DEFAULT_YES) {
return;
}
mTouchMode=TOUCH_DONE_MODE;
switchOutDrawHistory();
int contentX=viewToContentX(mLastTouchX + mScrollX);
int contentY=viewToContentY(mLastTouchY + mScrollY);
int slop=viewToContentDimension(mNavSlop);
if (USE_WEBKIT_RINGS && !mTouchHighlightRegion.isEmpty()) {
mTouchHighlightRequested=0;
invalidate(mTouchHighlightRegion.getBounds());
mPrivateHandler.postDelayed(new Runnable(){
@Override public void run(){
removeTouchHighlight();
}
}
,ViewConfiguration.getPressedStateDuration());
}
if (getSettings().supportTouchOnly()) {
removeTouchHighlight();
WebViewCore.TouchUpData touchUpData=new WebViewCore.TouchUpData();
touchUpData.mMoveGeneration=0;
mWebViewCore.sendMessage(EventHub.TOUCH_UP,touchUpData);
}
 else if (nativePointInNavCache(contentX,contentY,slop)) {
WebViewCore.MotionUpData motionUpData=new WebViewCore.MotionUpData();
motionUpData.mFrame=nativeCacheHitFramePointer();
motionUpData.mNode=nativeCacheHitNodePointer();
motionUpData.mBounds=nativeCacheHitNodeBounds();
motionUpData.mX=contentX;
motionUpData.mY=contentY;
mWebViewCore.sendMessageAtFrontOfQueue(EventHub.VALID_NODE_BOUNDS,motionUpData);
}
 else {
doMotionUp(contentX,contentY);
}
}
private void doMotionUp(int contentX,int contentY){
int slop=viewToContentDimension(mNavSlop);
if (nativeMotionUp(contentX,contentY,slop) && mLogEvent) {
EventLog.writeEvent(EventLogTags.BROWSER_SNAP_CENTER);
}
if (nativeHasCursorNode() && !nativeCursorIsTextInput()) {
playSoundEffect(SoundEffectConstants.CLICK);
}
}
Rect getPluginBounds(int x,int y){
int slop=viewToContentDimension(mNavSlop);
if (nativePointInNavCache(x,y,slop) && nativeCacheHitIsPlugin()) {
return nativeCacheHitNodeBounds();
}
 else {
return null;
}
}
boolean isRectFitOnScreen(Rect rect){
final int rectWidth=rect.width();
final int rectHeight=rect.height();
final int viewWidth=getViewWidth();
final int viewHeight=getViewHeightWithTitle();
float scale=Math.min((float)viewWidth / rectWidth,(float)viewHeight / rectHeight);
scale=mZoomManager.computeScaleWithLimits(scale);
return !mZoomManager.willScaleTriggerZoom(scale) && contentToViewX(rect.left) >= mScrollX && contentToViewX(rect.right) <= mScrollX + viewWidth && contentToViewY(rect.top) >= mScrollY && contentToViewY(rect.bottom) <= mScrollY + viewHeight;
}
void centerFitRect(Rect rect){
final int rectWidth=rect.width();
final int rectHeight=rect.height();
final int viewWidth=getViewWidth();
final int viewHeight=getViewHeightWithTitle();
float scale=Math.min((float)viewWidth / rectWidth,(float)viewHeight / rectHeight);
scale=mZoomManager.computeScaleWithLimits(scale);
if (!mZoomManager.willScaleTriggerZoom(scale)) {
pinScrollTo(contentToViewX(rect.left + rectWidth / 2) - viewWidth / 2,contentToViewY(rect.top + rectHeight / 2) - viewHeight / 2,true,0);
}
 else {
float actualScale=mZoomManager.getScale();
float oldScreenX=rect.left * actualScale - mScrollX;
float rectViewX=rect.left * scale;
float rectViewWidth=rectWidth * scale;
float newMaxWidth=mContentWidth * scale;
float newScreenX=(viewWidth - rectViewWidth) / 2;
if (newScreenX > rectViewX) {
newScreenX=rectViewX;
}
 else if (newScreenX > (newMaxWidth - rectViewX - rectViewWidth)) {
newScreenX=viewWidth - (newMaxWidth - rectViewX);
}
float zoomCenterX=(oldScreenX * scale - newScreenX * actualScale) / (scale - actualScale);
float oldScreenY=rect.top * actualScale + getTitleHeight() - mScrollY;
float rectViewY=rect.top * scale + getTitleHeight();
float rectViewHeight=rectHeight * scale;
float newMaxHeight=mContentHeight * scale + getTitleHeight();
float newScreenY=(viewHeight - rectViewHeight) / 2;
if (newScreenY > rectViewY) {
newScreenY=rectViewY;
}
 else if (newScreenY > (newMaxHeight - rectViewY - rectViewHeight)) {
newScreenY=viewHeight - (newMaxHeight - rectViewY);
}
float zoomCenterY=(oldScreenY * scale - newScreenY * actualScale) / (scale - actualScale);
mZoomManager.setZoomCenter(zoomCenterX,zoomCenterY);
mZoomManager.startZoomAnimation(scale,false);
}
}
private void overrideLoading(String url){
mCallbackProxy.uiOverrideUrlLoading(url);
}
@Override public boolean requestFocus(int direction,Rect previouslyFocusedRect){
if (mFindIsUp) return false;
boolean result=false;
if (inEditingMode()) {
result=mWebTextView.requestFocus(direction,previouslyFocusedRect);
}
 else {
result=super.requestFocus(direction,previouslyFocusedRect);
if (mWebViewCore.getSettings().getNeedInitialFocus() && !isInTouchMode()) {
int fakeKeyDirection=0;
switch (direction) {
case View.FOCUS_UP:
fakeKeyDirection=KeyEvent.KEYCODE_DPAD_UP;
break;
case View.FOCUS_DOWN:
fakeKeyDirection=KeyEvent.KEYCODE_DPAD_DOWN;
break;
case View.FOCUS_LEFT:
fakeKeyDirection=KeyEvent.KEYCODE_DPAD_LEFT;
break;
case View.FOCUS_RIGHT:
fakeKeyDirection=KeyEvent.KEYCODE_DPAD_RIGHT;
break;
default :
return result;
}
if (mNativeClass != 0 && !nativeHasCursorNode()) {
navHandledKey(fakeKeyDirection,1,true,0);
}
}
}
return result;
}
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
super.onMeasure(widthMeasureSpec,heightMeasureSpec);
int heightMode=MeasureSpec.getMode(heightMeasureSpec);
int heightSize=MeasureSpec.getSize(heightMeasureSpec);
int widthMode=MeasureSpec.getMode(widthMeasureSpec);
int widthSize=MeasureSpec.getSize(widthMeasureSpec);
int measuredHeight=heightSize;
int measuredWidth=widthSize;
int contentHeight=contentToViewDimension(mContentHeight);
int contentWidth=contentToViewDimension(mContentWidth);
if (heightMode != MeasureSpec.EXACTLY) {
mHeightCanMeasure=true;
measuredHeight=contentHeight;
if (heightMode == MeasureSpec.AT_MOST) {
if (measuredHeight > heightSize) {
measuredHeight=heightSize;
mHeightCanMeasure=false;
measuredHeight|=MEASURED_STATE_TOO_SMALL;
}
}
}
 else {
mHeightCanMeasure=false;
}
if (mNativeClass != 0) {
nativeSetHeightCanMeasure(mHeightCanMeasure);
}
if (widthMode == MeasureSpec.UNSPECIFIED) {
mWidthCanMeasure=true;
measuredWidth=contentWidth;
}
 else {
if (measuredWidth < contentWidth) {
measuredWidth|=MEASURED_STATE_TOO_SMALL;
}
mWidthCanMeasure=false;
}
synchronized (this) {
setMeasuredDimension(measuredWidth,measuredHeight);
}
}
@Override public boolean requestChildRectangleOnScreen(View child,Rect rect,boolean immediate){
if (mNativeClass == 0) {
return false;
}
if (mZoomManager.isFixedLengthAnimationInProgress()) {
return false;
}
rect.offset(child.getLeft() - child.getScrollX(),child.getTop() - child.getScrollY());
Rect content=new Rect(viewToContentX(mScrollX),viewToContentY(mScrollY),viewToContentX(mScrollX + getWidth() - getVerticalScrollbarWidth()),viewToContentY(mScrollY + getViewHeightWithTitle()));
content=nativeSubtractLayers(content);
int screenTop=contentToViewY(content.top);
int screenBottom=contentToViewY(content.bottom);
int height=screenBottom - screenTop;
int scrollYDelta=0;
if (rect.bottom > screenBottom) {
int oneThirdOfScreenHeight=height / 3;
if (rect.height() > 2 * oneThirdOfScreenHeight) {
scrollYDelta=rect.top - screenTop;
}
 else {
scrollYDelta=rect.top - (screenTop + oneThirdOfScreenHeight);
}
}
 else if (rect.top < screenTop) {
scrollYDelta=rect.top - screenTop;
}
int screenLeft=contentToViewX(content.left);
int screenRight=contentToViewX(content.right);
int width=screenRight - screenLeft;
int scrollXDelta=0;
if (rect.right > screenRight && rect.left > screenLeft) {
if (rect.width() > width) {
scrollXDelta+=(rect.left - screenLeft);
}
 else {
scrollXDelta+=(rect.right - screenRight);
}
}
 else if (rect.left < screenLeft) {
scrollXDelta-=(screenLeft - rect.left);
}
if ((scrollYDelta | scrollXDelta) != 0) {
return pinScrollBy(scrollXDelta,scrollYDelta,!immediate,0);
}
return false;
}
void replaceTextfieldText(int oldStart,int oldEnd,String replace,int newStart,int newEnd){
WebViewCore.ReplaceTextData arg=new WebViewCore.ReplaceTextData();
arg.mReplace=replace;
arg.mNewStart=newStart;
arg.mNewEnd=newEnd;
mTextGeneration++;
arg.mTextGeneration=mTextGeneration;
mWebViewCore.sendMessage(EventHub.REPLACE_TEXT,oldStart,oldEnd,arg);
}
void passToJavaScript(String currentText,KeyEvent event){
WebViewCore.JSKeyData arg=new WebViewCore.JSKeyData();
arg.mEvent=event;
arg.mCurrentText=currentText;
mTextGeneration++;
mWebViewCore.sendMessage(EventHub.PASS_TO_JS,mTextGeneration,0,arg);
mWebViewCore.removeMessages(EventHub.SAVE_DOCUMENT_STATE);
mWebViewCore.sendMessageDelayed(EventHub.SAVE_DOCUMENT_STATE,cursorData(),1000);
}
public synchronized WebViewCore getWebViewCore(){
return mWebViewCore;
}
private static class QueuedTouch {
long mSequence;
MotionEvent mEvent;
TouchEventData mTed;
QueuedTouch mNext;
public QueuedTouch set(TouchEventData ted){
mSequence=ted.mSequence;
mTed=ted;
mEvent=null;
mNext=null;
return this;
}
public QueuedTouch set(MotionEvent ev,long sequence){
mEvent=MotionEvent.obtain(ev);
mSequence=sequence;
mTed=null;
mNext=null;
return this;
}
public QueuedTouch add(QueuedTouch other){
if (other.mSequence < mSequence) {
other.mNext=this;
return other;
}
QueuedTouch insertAt=this;
while (insertAt.mNext != null && insertAt.mNext.mSequence < other.mSequence) {
insertAt=insertAt.mNext;
}
other.mNext=insertAt.mNext;
insertAt.mNext=other;
return this;
}
}
private class TouchEventQueue {
private long mNextTouchSequence=Long.MIN_VALUE + 1;
private long mLastHandledTouchSequence=Long.MIN_VALUE;
private long mIgnoreUntilSequence=Long.MIN_VALUE + 1;
private QueuedTouch mTouchEventQueue;
private QueuedTouch mPreQueue;
private QueuedTouch mQueuedTouchRecycleBin;
private int mQueuedTouchRecycleCount;
private long mLastEventTime=Long.MAX_VALUE;
private static final int MAX_RECYCLED_QUEUED_TOUCH=15;
private static final int QUEUED_GESTURE_TIMEOUT=1000;
private QueuedTouch obtainQueuedTouch(){
if (mQueuedTouchRecycleBin != null) {
QueuedTouch result=mQueuedTouchRecycleBin;
mQueuedTouchRecycleBin=result.mNext;
mQueuedTouchRecycleCount--;
return result;
}
return new QueuedTouch();
}
public void ignoreCurrentlyMissingEvents(){
mIgnoreUntilSequence=mNextTouchSequence;
runQueuedAndPreQueuedEvents();
}
private void runQueuedAndPreQueuedEvents(){
QueuedTouch qd=mPreQueue;
boolean fromPreQueue=true;
while (qd != null && qd.mSequence == mLastHandledTouchSequence + 1) {
handleQueuedTouch(qd);
QueuedTouch recycleMe=qd;
if (fromPreQueue) {
mPreQueue=qd.mNext;
}
 else {
mTouchEventQueue=qd.mNext;
}
recycleQueuedTouch(recycleMe);
mLastHandledTouchSequence++;
long nextPre=mPreQueue != null ? mPreQueue.mSequence : Long.MAX_VALUE;
long nextQueued=mTouchEventQueue != null ? mTouchEventQueue.mSequence : Long.MAX_VALUE;
fromPreQueue=nextPre < nextQueued;
qd=fromPreQueue ? mPreQueue : mTouchEventQueue;
}
}
public void preQueueTouchEventData(TouchEventData ted){
QueuedTouch newTouch=obtainQueuedTouch().set(ted);
if (mPreQueue == null) {
mPreQueue=newTouch;
}
 else {
QueuedTouch insertionPoint=mPreQueue;
while (insertionPoint.mNext != null && insertionPoint.mNext.mSequence < newTouch.mSequence) {
insertionPoint=insertionPoint.mNext;
}
newTouch.mNext=insertionPoint.mNext;
insertionPoint.mNext=newTouch;
}
}
private void recycleQueuedTouch(QueuedTouch qd){
if (mQueuedTouchRecycleCount < MAX_RECYCLED_QUEUED_TOUCH) {
qd.mNext=mQueuedTouchRecycleBin;
mQueuedTouchRecycleBin=qd;
mQueuedTouchRecycleCount++;
}
}
public void reset(){
mNextTouchSequence=Long.MIN_VALUE + 1;
mLastHandledTouchSequence=Long.MIN_VALUE;
mIgnoreUntilSequence=Long.MIN_VALUE + 1;
while (mTouchEventQueue != null) {
QueuedTouch recycleMe=mTouchEventQueue;
mTouchEventQueue=mTouchEventQueue.mNext;
recycleQueuedTouch(recycleMe);
}
while (mPreQueue != null) {
QueuedTouch recycleMe=mPreQueue;
mPreQueue=mPreQueue.mNext;
recycleQueuedTouch(recycleMe);
}
}
public long nextTouchSequence(){
return mNextTouchSequence++;
}
public boolean enqueueTouchEvent(TouchEventData ted){
QueuedTouch preQueue=mPreQueue;
if (preQueue != null) {
if (preQueue.mSequence == ted.mSequence) {
mPreQueue=preQueue.mNext;
}
 else {
QueuedTouch prev=preQueue;
preQueue=null;
while (prev.mNext != null) {
if (prev.mNext.mSequence == ted.mSequence) {
preQueue=prev.mNext;
prev.mNext=preQueue.mNext;
break;
}
 else {
prev=prev.mNext;
}
}
}
}
if (ted.mSequence < mLastHandledTouchSequence) {
Log.w(LOGTAG,"Stale touch event " + MotionEvent.actionToString(ted.mAction) + " received from webcore; ignoring");
return false;
}
if (dropStaleGestures(ted.mMotionEvent,ted.mSequence)) {
return false;
}
runNextQueuedEvents();
if (mLastHandledTouchSequence + 1 == ted.mSequence) {
if (preQueue != null) {
recycleQueuedTouch(preQueue);
preQueue=null;
}
handleQueuedTouchEventData(ted);
mLastHandledTouchSequence++;
runNextQueuedEvents();
}
 else {
QueuedTouch qd=preQueue != null ? preQueue : obtainQueuedTouch().set(ted);
mTouchEventQueue=mTouchEventQueue == null ? qd : mTouchEventQueue.add(qd);
}
return true;
}
public void enqueueTouchEvent(MotionEvent ev){
final long sequence=nextTouchSequence();
if (dropStaleGestures(ev,sequence)) {
return;
}
runNextQueuedEvents();
if (mLastHandledTouchSequence + 1 == sequence) {
handleQueuedMotionEvent(ev);
mLastHandledTouchSequence++;
runNextQueuedEvents();
}
 else {
QueuedTouch qd=obtainQueuedTouch().set(ev,sequence);
mTouchEventQueue=mTouchEventQueue == null ? qd : mTouchEventQueue.add(qd);
}
}
private void runNextQueuedEvents(){
QueuedTouch qd=mTouchEventQueue;
while (qd != null && qd.mSequence == mLastHandledTouchSequence + 1) {
handleQueuedTouch(qd);
QueuedTouch recycleMe=qd;
qd=qd.mNext;
recycleQueuedTouch(recycleMe);
mLastHandledTouchSequence++;
}
mTouchEventQueue=qd;
}
private boolean dropStaleGestures(MotionEvent ev,long sequence){
if (ev != null && ev.getAction() == MotionEvent.ACTION_MOVE && !mConfirmMove) {
final int dx=Math.round(ev.getX()) - mLastTouchX;
final int dy=Math.round(ev.getY()) - mLastTouchY;
if (dx * dx + dy * dy > mTouchSlopSquare) {
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
}
}
if (mTouchEventQueue == null) {
return sequence <= mLastHandledTouchSequence;
}
if (ev != null && ev.getAction() == MotionEvent.ACTION_DOWN) {
long eventTime=ev.getEventTime();
long lastHandledEventTime=mLastEventTime;
if (eventTime > lastHandledEventTime + QUEUED_GESTURE_TIMEOUT) {
Log.w(LOGTAG,"Got ACTION_DOWN but still waiting on stale event. " + "Catching up.");
runQueuedAndPreQueuedEvents();
QueuedTouch qd=mTouchEventQueue;
while (qd != null && qd.mSequence < sequence) {
QueuedTouch recycleMe=qd;
qd=qd.mNext;
recycleQueuedTouch(recycleMe);
}
mTouchEventQueue=qd;
mLastHandledTouchSequence=sequence - 1;
}
}
if (mIgnoreUntilSequence - 1 > mLastHandledTouchSequence) {
QueuedTouch qd=mTouchEventQueue;
while (qd != null && qd.mSequence < mIgnoreUntilSequence) {
QueuedTouch recycleMe=qd;
qd=qd.mNext;
recycleQueuedTouch(recycleMe);
}
mTouchEventQueue=qd;
mLastHandledTouchSequence=mIgnoreUntilSequence - 1;
}
if (mPreQueue != null) {
QueuedTouch qd=mPreQueue;
while (qd != null && qd.mSequence < mIgnoreUntilSequence) {
QueuedTouch recycleMe=qd;
qd=qd.mNext;
recycleQueuedTouch(recycleMe);
}
mPreQueue=qd;
}
return sequence <= mLastHandledTouchSequence;
}
private void handleQueuedTouch(QueuedTouch qt){
if (qt.mTed != null) {
handleQueuedTouchEventData(qt.mTed);
}
 else {
handleQueuedMotionEvent(qt.mEvent);
qt.mEvent.recycle();
}
}
private void handleQueuedMotionEvent(MotionEvent ev){
mLastEventTime=ev.getEventTime();
int action=ev.getActionMasked();
if (ev.getPointerCount() > 1) {
handleMultiTouchInWebView(ev);
}
 else {
final ScaleGestureDetector detector=mZoomManager.getMultiTouchGestureDetector();
if (detector != null && mPreventDefault != PREVENT_DEFAULT_YES) {
detector.onTouchEvent(ev);
}
handleTouchEventCommon(ev,action,Math.round(ev.getX()),Math.round(ev.getY()));
}
}
private void handleQueuedTouchEventData(TouchEventData ted){
if (ted.mMotionEvent != null) {
mLastEventTime=ted.mMotionEvent.getEventTime();
}
if (!ted.mReprocess) {
if (ted.mAction == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) {
mPreventDefault=ted.mNativeResult ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN;
}
 else if (ted.mAction == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
mPreventDefault=ted.mNativeResult ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO;
}
if (mPreventDefault == PREVENT_DEFAULT_YES) {
mTouchHighlightRegion.setEmpty();
}
}
 else {
if (ted.mPoints.length > 1) {
if (!ted.mNativeResult && mPreventDefault != PREVENT_DEFAULT_YES) {
mPreventDefault=PREVENT_DEFAULT_NO;
handleMultiTouchInWebView(ted.mMotionEvent);
}
 else {
mPreventDefault=PREVENT_DEFAULT_YES;
}
return;
}
if (!ted.mNativeResult) {
switch (ted.mAction) {
case MotionEvent.ACTION_DOWN:
mLastDeferTouchX=ted.mPointsInView[0].x;
mLastDeferTouchY=ted.mPointsInView[0].y;
mDeferTouchMode=TOUCH_INIT_MODE;
break;
case MotionEvent.ACTION_MOVE:
{
int x=ted.mPointsInView[0].x;
int y=ted.mPointsInView[0].y;
if (mDeferTouchMode != TOUCH_DRAG_MODE) {
mDeferTouchMode=TOUCH_DRAG_MODE;
mLastDeferTouchX=x;
mLastDeferTouchY=y;
startScrollingLayer(x,y);
startDrag();
}
int deltaX=pinLocX((int)(mScrollX + mLastDeferTouchX - x)) - mScrollX;
int deltaY=pinLocY((int)(mScrollY + mLastDeferTouchY - y)) - mScrollY;
doDrag(deltaX,deltaY);
if (deltaX != 0) mLastDeferTouchX=x;
if (deltaY != 0) mLastDeferTouchY=y;
break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (mDeferTouchMode == TOUCH_DRAG_MODE) {
mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY());
invalidate();
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
}
mDeferTouchMode=TOUCH_DONE_MODE;
break;
case WebViewCore.ACTION_DOUBLETAP:
mLastDeferTouchX=ted.mPointsInView[0].x;
mLastDeferTouchY=ted.mPointsInView[0].y;
mZoomManager.handleDoubleTap(mLastTouchX,mLastTouchY);
mDeferTouchMode=TOUCH_DONE_MODE;
break;
case WebViewCore.ACTION_LONGPRESS:
HitTestResult hitTest=getHitTestResult();
if (hitTest != null && hitTest.mType != HitTestResult.UNKNOWN_TYPE) {
performLongClick();
}
mDeferTouchMode=TOUCH_DONE_MODE;
break;
}
}
}
}
}
class PrivateHandler extends Handler {
@Override public void handleMessage(Message msg){
if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
Log.v(LOGTAG,HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
}
 else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
Log.v(LOGTAG,HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
}
 else {
Log.v(LOGTAG,Integer.toString(msg.what));
}
}
if (mWebViewCore == null) {
return;
}
if (mBlockWebkitViewMessages && msg.what != WEBCORE_INITIALIZED_MSG_ID) {
return;
}
switch (msg.what) {
case REMEMBER_PASSWORD:
{
mDatabase.setUsernamePassword(msg.getData().getString("host"),msg.getData().getString("username"),msg.getData().getString("password"));
((Message)msg.obj).sendToTarget();
break;
}
case NEVER_REMEMBER_PASSWORD:
{
mDatabase.setUsernamePassword(msg.getData().getString("host"),null,null);
((Message)msg.obj).sendToTarget();
break;
}
case PREVENT_DEFAULT_TIMEOUT:
{
if ((msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) || (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN)) {
cancelWebCoreTouchEvent(viewToContentX(mLastTouchX + mScrollX),viewToContentY(mLastTouchY + mScrollY),true);
}
break;
}
case SCROLL_SELECT_TEXT:
{
if (mAutoScrollX == 0 && mAutoScrollY == 0) {
mSentAutoScrollMessage=false;
break;
}
if (mScrollingLayer == 0) {
pinScrollBy(mAutoScrollX,mAutoScrollY,true,0);
}
 else {
mScrollingLayerRect.left+=mAutoScrollX;
mScrollingLayerRect.top+=mAutoScrollY;
nativeScrollLayer(mScrollingLayer,mScrollingLayerRect.left,mScrollingLayerRect.top);
invalidate();
}
sendEmptyMessageDelayed(SCROLL_SELECT_TEXT,SELECT_SCROLL_INTERVAL);
break;
}
case SWITCH_TO_SHORTPRESS:
{
mInitialHitTestResult=null;
if (mTouchMode == TOUCH_INIT_MODE) {
if (!getSettings().supportTouchOnly() && mPreventDefault != PREVENT_DEFAULT_YES) {
mTouchMode=TOUCH_SHORTPRESS_START_MODE;
updateSelection();
}
 else {
mTouchMode=TOUCH_SHORTPRESS_MODE;
}
}
 else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
mTouchMode=TOUCH_DONE_MODE;
}
break;
}
case SWITCH_TO_LONGPRESS:
{
if (USE_WEBKIT_RINGS || getSettings().supportTouchOnly()) {
removeTouchHighlight();
}
if (inFullScreenMode() || mDeferTouchProcess) {
TouchEventData ted=new TouchEventData();
ted.mAction=WebViewCore.ACTION_LONGPRESS;
ted.mIds=new int[1];
ted.mIds[0]=0;
ted.mPoints=new Point[1];
ted.mPoints[0]=new Point(viewToContentX(mLastTouchX + mScrollX),viewToContentY(mLastTouchY + mScrollY));
ted.mPointsInView=new Point[1];
ted.mPointsInView[0]=new Point(mLastTouchX,mLastTouchY);
ted.mMetaState=0;
ted.mReprocess=mDeferTouchProcess;
ted.mNativeLayer=nativeScrollableLayer(ted.mPoints[0].x,ted.mPoints[0].y,ted.mNativeLayerRect,null);
ted.mSequence=mTouchEventQueue.nextTouchSequence();
mTouchEventQueue.preQueueTouchEventData(ted);
mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
mTouchMode=TOUCH_DONE_MODE;
performLongClick();
}
break;
}
case RELEASE_SINGLE_TAP:
{
doShortPress();
break;
}
case SCROLL_TO_MSG_ID:
{
if (msg.arg2 == 1) {
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm == null || !imm.isAcceptingText() || (!imm.isActive(WebView.this) && (!inEditingMode() || !imm.isActive(mWebTextView)))) {
break;
}
}
final Point p=(Point)msg.obj;
if (msg.arg1 == 1) {
spawnContentScrollTo(p.x,p.y);
}
 else {
setContentScrollTo(p.x,p.y);
}
break;
}
case UPDATE_ZOOM_RANGE:
{
WebViewCore.ViewState viewState=(WebViewCore.ViewState)msg.obj;
mZoomManager.updateZoomRange(viewState,getViewWidth(),viewState.mScrollX);
break;
}
case REPLACE_BASE_CONTENT:
{
nativeReplaceBaseContent(msg.arg1);
break;
}
case NEW_PICTURE_MSG_ID:
{
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
setNewPicture(draw,true);
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
String drawableDir=BrowserFrame.getRawResFilename(BrowserFrame.DRAWABLEDIR,mContext);
nativeCreate(msg.arg1,drawableDir);
if (mDelaySetPicture != null) {
setNewPicture(mDelaySetPicture,true);
mDelaySetPicture=null;
}
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.arg2 == mTextGeneration) {
String text=(String)msg.obj;
if (null == text) {
text="";
}
mWebTextView.setTextAndKeepSelection(text);
}
}
break;
case REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID:
displaySoftKeyboard(true);
case UPDATE_TEXT_SELECTION_MSG_ID:
updateTextSelectionFromMessage(msg.arg1,msg.arg2,(WebViewCore.TextSelectionData)msg.obj);
break;
case FORM_DID_BLUR:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
hideSoftKeyboard();
}
break;
case RETURN_LABEL:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setHint((String)msg.obj);
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null && imm.isActive(mWebTextView)) {
imm.restartInput(mWebTextView);
}
}
break;
case UNHANDLED_NAV_KEY:
navHandledKey(msg.arg1,1,false,0);
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case RESUME_WEBCORE_PRIORITY:
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
performLongClick();
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (inFullScreenMode()) {
break;
}
TouchEventData ted=(TouchEventData)msg.obj;
if (mTouchEventQueue.enqueueTouchEvent(ted)) {
removeMessages(PREVENT_DEFAULT_TIMEOUT);
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case FIND_AGAIN:
if (mFindIsUp && mFindCallback != null) {
mFindCallback.findAll();
}
break;
case DRAG_HELD_MOTIONLESS:
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case AWAKEN_SCROLL_BARS:
if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS),ViewConfiguration.getScrollDefaultDelay());
}
break;
case DO_MOTION_UP:
doMotionUp(msg.arg1,msg.arg2);
break;
case SCREEN_ON:
setKeepScreenOn(msg.arg1 == 1);
break;
case ENTER_FULLSCREEN_VIDEO:
int layerId=msg.arg1;
String url=(String)msg.obj;
if (mHTML5VideoViewProxy != null) {
mHTML5VideoViewProxy.enterFullScreenVideo(layerId,url);
}
break;
case SHOW_FULLSCREEN:
{
View view=(View)msg.obj;
int orientation=msg.arg1;
int npp=msg.arg2;
if (inFullScreenMode()) {
Log.w(LOGTAG,"Should not have another full screen.");
dismissFullScreenMode();
}
mFullScreenHolder=new PluginFullScreenHolder(WebView.this,orientation,npp);
mFullScreenHolder.setContentView(view);
mFullScreenHolder.show();
break;
}
case HIDE_FULLSCREEN:
dismissFullScreenMode();
break;
case DOM_FOCUS_CHANGED:
if (inEditingMode()) {
nativeClearCursor();
rebuildWebTextView();
}
break;
case SHOW_RECT_MSG_ID:
{
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewX(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"showRectMsg=(left=" + left + ",width="+ width+ ",maxWidth="+ maxWidth+ ",viewWidth="+ viewWidth+ ",x="+ x+ ",xPercentInDoc="+ data.mXPercentInDoc+ ",xPercentInView="+ data.mXPercentInView+ ")");
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int top=contentToViewY(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
int y=(int)(top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"showRectMsg=(top=" + top + ",height="+ height+ ",maxHeight="+ maxHeight+ ",viewHeight="+ viewHeight+ ",y="+ y+ ",yPercentInDoc="+ data.mYPercentInDoc+ ",yPercentInView="+ data.mYPercentInView+ ")");
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
y=Math.max(0,y - getVisibleTitleHeightImpl());
scrollTo(x,y);
}
break;
case CENTER_FIT_RECT:
centerFitRect((Rect)msg.obj);
break;
case SET_SCROLLBAR_MODES:
mHorizontalScrollBarMode=msg.arg1;
mVerticalScrollBarMode=msg.arg2;
break;
case SELECTION_STRING_CHANGED:
if (mAccessibilityInjector != null) {
String selectionString=(String)msg.obj;
mAccessibilityInjector.onSelectionStringChange(selectionString);
}
break;
case SET_TOUCH_HIGHLIGHT_RECTS:
@SuppressWarnings("unchecked") ArrayList<Rect> rects=(ArrayList<Rect>)msg.obj;
setTouchHighlightRects(rects);
break;
case SAVE_WEBARCHIVE_FINISHED:
SaveWebArchiveMessage saveMessage=(SaveWebArchiveMessage)msg.obj;
if (saveMessage.mCallback != null) {
saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
}
break;
case SET_AUTOFILLABLE:
mAutoFillData=(WebViewCore.AutoFillData)msg.obj;
if (mWebTextView != null) {
mWebTextView.setAutoFillable(mAutoFillData.getQueryId());
rebuildWebTextView();
}
break;
case AUTOFILL_COMPLETE:
if (mWebTextView != null) {
mWebTextView.setAdapterCustom(null);
}
break;
case SELECT_AT:
nativeSelectAt(msg.arg1,msg.arg2);
break;
default :
super.handleMessage(msg);
break;
}
}
}
private void setTouchHighlightRects(ArrayList<Rect> rects){
invalidate(mTouchHighlightRegion.getBounds());
mTouchHighlightRegion.setEmpty();
if (rects != null) {
for (Rect rect : rects) {
Rect viewRect=contentToViewRect(rect);
if (viewRect.width() < getWidth() >> 1 || viewRect.height() < getHeight() >> 1) {
mTouchHighlightRegion.union(viewRect);
}
 else {
Log.w(LOGTAG,"Skip the huge selection rect:" + viewRect);
}
}
invalidate(mTouchHighlightRegion.getBounds());
}
}
protected void pageSwapCallback(){
if (inEditingMode()) {
didUpdateWebTextViewDimensions(ANYWHERE);
}
}
void setNewPicture(final WebViewCore.DrawData draw,boolean updateBaseLayer){
if (mNativeClass == 0) {
if (mDelaySetPicture != null) {
throw new IllegalStateException("Tried to setNewPicture with" + " a delay picture already set! (memory leak)");
}
mDelaySetPicture=draw;
return;
}
WebViewCore.ViewState viewState=draw.mViewState;
boolean isPictureAfterFirstLayout=viewState != null;
if (updateBaseLayer) {
boolean registerPageSwapCallback=!mZoomManager.isFixedLengthAnimationInProgress() && inEditingMode();
setBaseLayer(draw.mBaseLayer,draw.mInvalRegion,getSettings().getShowVisualIndicator(),isPictureAfterFirstLayout,registerPageSwapCallback);
}
final Point viewSize=draw.mViewSize;
if (isPictureAfterFirstLayout) {
mLastWidthSent=0;
mZoomManager.onFirstLayout(draw);
if (!mDrawHistory) {
mSendScrollEvent=false;
setContentScrollTo(viewState.mScrollX,viewState.mScrollY);
mSendScrollEvent=true;
clearTextEntry();
}
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
mSendScrollEvent=false;
recordNewContentSize(draw.mContentSize.x,draw.mContentSize.y,updateLayout);
mSendScrollEvent=true;
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,"NEW_PICTURE_MSG_ID {" + b.left + ","+ b.top+ ","+ b.right+ ","+ b.bottom+ "}");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
mZoomManager.onNewPicture(draw);
if (draw.mFocusSizeChanged && inEditingMode()) {
mFocusSizeChanged=true;
}
if (isPictureAfterFirstLayout) {
mViewManager.postReadyToDrawAll();
}
}
private void updateTextSelectionFromMessage(int nodePointer,int textGeneration,WebViewCore.TextSelectionData data){
if (inEditingMode() && mWebTextView.isSameTextField(nodePointer) && textGeneration == mTextGeneration) {
mWebTextView.setSelectionFromWebKit(data.mStart,data.mEnd);
}
}
private class InvokeListBox implements Runnable {
private boolean mMultiple;
private int[] mSelectedArray;
private int mSelection;
private Container[] mContainers;
private class Container extends Object {
final static int OPTGROUP=-1;
final static int OPTION_DISABLED=0;
final static int OPTION_ENABLED=1;
String mString;
int mEnabled;
int mId;
@Override public String toString(){
return mString;
}
}
private class MyArrayListAdapter extends ArrayAdapter<Container> {
public MyArrayListAdapter(){
super(mContext,mMultiple ? com.android.internal.R.layout.select_dialog_multichoice : com.android.internal.R.layout.webview_select_singlechoice,mContainers);
}
@Override public View getView(int position,View convertView,ViewGroup parent){
convertView=super.getView(position,null,parent);
Container c=item(position);
if (c != null && Container.OPTION_ENABLED != c.mEnabled) {
LinearLayout layout=new LinearLayout(mContext);
layout.setOrientation(LinearLayout.VERTICAL);
if (position > 0) {
View dividerTop=new View(mContext);
dividerTop.setBackgroundResource(android.R.drawable.divider_horizontal_bright);
layout.addView(dividerTop);
}
if (Container.OPTGROUP == c.mEnabled) {
if (mMultiple) {
Assert.assertTrue(convertView instanceof CheckedTextView);
((CheckedTextView)convertView).setCheckMarkDrawable(null);
}
}
 else {
convertView.setEnabled(false);
}
layout.addView(convertView);
if (position < getCount() - 1) {
View dividerBottom=new View(mContext);
dividerBottom.setBackgroundResource(android.R.drawable.divider_horizontal_bright);
layout.addView(dividerBottom);
}
return layout;
}
return convertView;
}
@Override public boolean hasStableIds(){
return false;
}
private Container item(int position){
if (position < 0 || position >= getCount()) {
return null;
}
return (Container)getItem(position);
}
@Override public long getItemId(int position){
Container item=item(position);
if (item == null) {
return -1;
}
return item.mId;
}
@Override public boolean areAllItemsEnabled(){
return false;
}
@Override public boolean isEnabled(int position){
Container item=item(position);
if (item == null) {
return false;
}
return Container.OPTION_ENABLED == item.mEnabled;
}
}
private InvokeListBox(String[] array,int[] enabled,int[] selected){
mMultiple=true;
mSelectedArray=selected;
int length=array.length;
mContainers=new Container[length];
for (int i=0; i < length; i++) {
mContainers[i]=new Container();
mContainers[i].mString=array[i];
mContainers[i].mEnabled=enabled[i];
mContainers[i].mId=i;
}
}
private InvokeListBox(String[] array,int[] enabled,int selection){
mSelection=selection;
mMultiple=false;
int length=array.length;
mContainers=new Container[length];
for (int i=0; i < length; i++) {
mContainers[i]=new Container();
mContainers[i].mString=array[i];
mContainers[i].mEnabled=enabled[i];
mContainers[i].mId=i;
}
}
private class SingleDataSetObserver extends DataSetObserver {
private long mCheckedId;
private ListView mListView;
private Adapter mAdapter;
public SingleDataSetObserver(long id,ListView l,Adapter a){
mCheckedId=id;
mListView=l;
mAdapter=a;
}
@Override public void onChanged(){
int position=mListView.getCheckedItemPosition();
long id=mAdapter.getItemId(position);
if (mCheckedId != id) {
mListView.clearChoices();
int count=mAdapter.getCount();
for (int i=0; i < count; i++) {
if (mAdapter.getItemId(i) == mCheckedId) {
mListView.setItemChecked(i,true);
break;
}
}
}
}
}
public void run(){
final ListView listView=(ListView)LayoutInflater.from(mContext).inflate(com.android.internal.R.layout.select_dialog,null);
final MyArrayListAdapter adapter=new MyArrayListAdapter();
AlertDialog.Builder b=new AlertDialog.Builder(mContext).setView(listView).setCancelable(true).setInverseBackgroundForced(true);
if (mMultiple) {
b.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
mWebViewCore.sendMessage(EventHub.LISTBOX_CHOICES,adapter.getCount(),0,listView.getCheckedItemPositions());
}
}
);
b.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
mWebViewCore.sendMessage(EventHub.SINGLE_LISTBOX_CHOICE,-2,0);
}
}
);
}
mListBoxDialog=b.create();
listView.setAdapter(adapter);
listView.setFocusableInTouchMode(true);
listView.setTextFilterEnabled(!mMultiple);
if (mMultiple) {
listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
int length=mSelectedArray.length;
for (int i=0; i < length; i++) {
listView.setItemChecked(mSelectedArray[i],true);
}
}
 else {
listView.setOnItemClickListener(new OnItemClickListener(){
public void onItemClick(AdapterView<?> parent,View v,int position,long id){
mListBoxMessage=Message.obtain(null,EventHub.SINGLE_LISTBOX_CHOICE,(int)id,0);
mListBoxDialog.dismiss();
mListBoxDialog=null;
}
}
);
if (mSelection != -1) {
listView.setSelection(mSelection);
listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
listView.setItemChecked(mSelection,true);
DataSetObserver observer=new SingleDataSetObserver(adapter.getItemId(mSelection),listView,adapter);
adapter.registerDataSetObserver(observer);
}
}
mListBoxDialog.setOnCancelListener(new DialogInterface.OnCancelListener(){
public void onCancel(DialogInterface dialog){
mWebViewCore.sendMessage(EventHub.SINGLE_LISTBOX_CHOICE,-2,0);
mListBoxDialog=null;
}
}
);
mListBoxDialog.show();
}
}
private Message mListBoxMessage;
void requestListBox(String[] array,int[] enabledArray,int[] selectedArray){
mPrivateHandler.post(new InvokeListBox(array,enabledArray,selectedArray));
}
void requestListBox(String[] array,int[] enabledArray,int selection){
mPrivateHandler.post(new InvokeListBox(array,enabledArray,selection));
}
private void sendMoveFocus(int frame,int node){
mWebViewCore.sendMessage(EventHub.SET_MOVE_FOCUS,new WebViewCore.CursorData(frame,node,0,0));
}
private void sendMoveMouse(int frame,int node,int x,int y){
mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE,new WebViewCore.CursorData(frame,node,x,y));
}
@SuppressWarnings("unused") private void sendMoveMouseIfLatest(boolean removeFocus,boolean stopPaintingCaret){
if (removeFocus) {
clearTextEntry();
}
mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE_IF_LATEST,stopPaintingCaret ? 1 : 0,0,cursorData());
}
private void sendMotionUp(int touchGeneration,int frame,int node,int x,int y){
WebViewCore.TouchUpData touchUpData=new WebViewCore.TouchUpData();
touchUpData.mMoveGeneration=touchGeneration;
touchUpData.mFrame=frame;
touchUpData.mNode=node;
touchUpData.mX=x;
touchUpData.mY=y;
touchUpData.mNativeLayer=nativeScrollableLayer(x,y,touchUpData.mNativeLayerRect,null);
mWebViewCore.sendMessage(EventHub.TOUCH_UP,touchUpData);
}
private int getScaledMaxXScroll(){
int width;
if (mHeightCanMeasure == false) {
width=getViewWidth() / 4;
}
 else {
Rect visRect=new Rect();
calcOurVisibleRect(visRect);
width=visRect.width() / 2;
}
return viewToContentX(width);
}
private int getScaledMaxYScroll(){
int height;
if (mHeightCanMeasure == false) {
height=getViewHeight() / 4;
}
 else {
Rect visRect=new Rect();
calcOurVisibleRect(visRect);
height=visRect.height() / 2;
}
return Math.round(height * mZoomManager.getInvScale());
}
private void viewInvalidate(){
invalidate();
}
private void letPageHandleNavKey(int keyCode,long time,boolean down,int metaState){
int keyEventAction;
int eventHubAction;
if (down) {
keyEventAction=KeyEvent.ACTION_DOWN;
eventHubAction=EventHub.KEY_DOWN;
playSoundEffect(keyCodeToSoundsEffect(keyCode));
}
 else {
keyEventAction=KeyEvent.ACTION_UP;
eventHubAction=EventHub.KEY_UP;
}
KeyEvent event=new KeyEvent(time,time,keyEventAction,keyCode,1,(metaState & KeyEvent.META_SHIFT_ON) | (metaState & KeyEvent.META_ALT_ON) | (metaState & KeyEvent.META_SYM_ON),KeyCharacterMap.VIRTUAL_KEYBOARD,0,0);
mWebViewCore.sendMessage(eventHubAction,event);
}
private boolean navHandledKey(int keyCode,int count,boolean noScroll,long time){
if (mNativeClass == 0) {
return false;
}
mInitialHitTestResult=null;
mLastCursorTime=time;
mLastCursorBounds=nativeGetCursorRingBounds();
boolean keyHandled=nativeMoveCursor(keyCode,count,noScroll) == false;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"navHandledKey mLastCursorBounds=" + mLastCursorBounds + " mLastCursorTime="+ mLastCursorTime+ " handled="+ keyHandled);
}
if (keyHandled == false) {
return keyHandled;
}
Rect contentCursorRingBounds=nativeGetCursorRingBounds();
if (contentCursorRingBounds.isEmpty()) return keyHandled;
Rect viewCursorRingBounds=contentToViewRect(contentCursorRingBounds);
mLastTouchX=(viewCursorRingBounds.left + viewCursorRingBounds.right) / 2;
mLastTouchY=(viewCursorRingBounds.top + viewCursorRingBounds.bottom) / 2;
if (mHeightCanMeasure == false) {
return keyHandled;
}
Rect visRect=new Rect();
calcOurVisibleRect(visRect);
Rect outset=new Rect(visRect);
int maxXScroll=visRect.width() / 2;
int maxYScroll=visRect.height() / 2;
outset.inset(-maxXScroll,-maxYScroll);
if (Rect.intersects(outset,viewCursorRingBounds) == false) {
return keyHandled;
}
int maxH=Math.min(viewCursorRingBounds.right - visRect.right,maxXScroll);
if (maxH > 0) {
pinScrollBy(maxH,0,true,0);
}
 else {
maxH=Math.max(viewCursorRingBounds.left - visRect.left,-maxXScroll);
if (maxH < 0) {
pinScrollBy(maxH,0,true,0);
}
}
if (mLastCursorBounds.isEmpty()) return keyHandled;
if (mLastCursorBounds.equals(contentCursorRingBounds)) {
return keyHandled;
}
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"navHandledKey contentCursorRingBounds=" + contentCursorRingBounds);
}
requestRectangleOnScreen(viewCursorRingBounds);
return keyHandled;
}
private boolean accessibilityScriptInjected(){
return mAccessibilityScriptInjected;
}
@Override public void setBackgroundColor(int color){
mBackgroundColor=color;
mWebViewCore.sendMessage(EventHub.SET_BACKGROUND_COLOR,color);
}
@Deprecated public void debugDump(){
checkThread();
nativeDebugDump();
mWebViewCore.sendMessage(EventHub.DUMP_NAVTREE);
}
public void drawPage(Canvas canvas){
nativeDraw(canvas,0,0,false);
}
public void setHTML5VideoViewProxy(HTML5VideoViewProxy proxy){
mHTML5VideoViewProxy=proxy;
}
public void setTouchInterval(int interval){
mCurrentTouchInterval=interval;
}
protected void updateCachedTextfield(String updatedText){
nativeUpdateCachedTextfield(updatedText,mTextGeneration);
}
void autoFillForm(int autoFillQueryId){
mWebViewCore.sendMessage(EventHub.AUTOFILL_FORM,autoFillQueryId,0);
}
ViewManager getViewManager(){
return mViewManager;
}
private static void checkThread(){
if (Looper.myLooper() != Looper.getMainLooper()) {
RuntimeException exception=new RuntimeException("A WebView method was called on thread '" + Thread.currentThread().getName() + "'. "+ "All WebView methods must be called on the UI thread. "+ "Future versions of WebView may not support use on other threads.");
Log.e(LOGTAG,Log.getStackTraceString(exception));
StrictMode.onWebViewMethodCalledOnWrongThread(exception);
}
}
protected void contentInvalidateAll(){
if (mWebViewCore != null && !mBlockWebkitViewMessages) {
mWebViewCore.sendMessage(EventHub.CONTENT_INVALIDATE_ALL);
}
}
protected void registerPageSwapCallback(){
nativeRegisterPageSwapCallback();
}
public void tileProfilingStart(){
nativeTileProfilingStart();
}
public float tileProfilingStop(){
return nativeTileProfilingStop();
}
public void tileProfilingClear(){
nativeTileProfilingClear();
}
public int tileProfilingNumFrames(){
return nativeTileProfilingNumFrames();
}
public int tileProfilingNumTilesInFrame(int frame){
return nativeTileProfilingNumTilesInFrame(frame);
}
public int tileProfilingGetInt(int frame,int tile,String key){
return nativeTileProfilingGetInt(frame,tile,key);
}
public float tileProfilingGetFloat(int frame,int tile,String key){
return nativeTileProfilingGetFloat(frame,tile,key);
}
private native int nativeCacheHitFramePointer();
private native boolean nativeCacheHitIsPlugin();
private native Rect nativeCacheHitNodeBounds();
private native int nativeCacheHitNodePointer();
native void nativeClearCursor();
private native void nativeCreate(int ptr,String drawableDir);
private native int nativeCursorFramePointer();
private native Rect nativeCursorNodeBounds();
private native int nativeCursorNodePointer();
private native boolean nativeCursorIntersects(Rect visibleRect);
private native boolean nativeCursorIsAnchor();
private native boolean nativeCursorIsTextInput();
private native Point nativeCursorPosition();
private native String nativeCursorText();
private native boolean nativeCursorWantsKeyEvents();
private native void nativeDebugDump();
private native void nativeDestroy();
private native int nativeDraw(Canvas canvas,int color,int extra,boolean splitIfNeeded);
private native void nativeDumpDisplayTree(String urlOrNull);
private native boolean nativeEvaluateLayersAnimations();
private native int nativeGetDrawGLFunction(Rect rect,Rect viewRect,float scale,int extras);
private native void nativeUpdateDrawGLFunction(Rect rect,Rect viewRect);
private native void nativeExtendSelection(int x,int y);
private native int nativeFindAll(String findLower,String findUpper,boolean sameAsLastSearch);
private native void nativeFindNext(boolean forward);
native int nativeFocusCandidateFramePointer();
native boolean nativeFocusCandidateHasNextTextfield();
native boolean nativeFocusCandidateIsPassword();
private native boolean nativeFocusCandidateIsRtlText();
private native boolean nativeFocusCandidateIsTextInput();
native int nativeFocusCandidateMaxLength();
native boolean nativeFocusCandidateIsAutoComplete();
native String nativeFocusCandidateName();
private native Rect nativeFocusCandidateNodeBounds();
private native Rect nativeFocusCandidatePaddingRect();
native int nativeFocusCandidatePointer();
private native String nativeFocusCandidateText();
native float nativeFocusCandidateTextSize();
native int nativeFocusCandidateLineHeight();
private native int nativeFocusCandidateType();
private native boolean nativeFocusIsPlugin();
private native Rect nativeFocusNodeBounds();
native int nativeFocusNodePointer();
private native Rect nativeGetCursorRingBounds();
private native String nativeGetSelection();
private native boolean nativeHasCursorNode();
private native boolean nativeHasFocusNode();
private native void nativeHideCursor();
private native boolean nativeHitSelection(int x,int y);
private native String nativeImageURI(int x,int y);
private native void nativeInstrumentReport();
private native Rect nativeLayerBounds(int layer);
native boolean nativeMoveCursorToNextTextInput();
private native boolean nativeMotionUp(int x,int y,int slop);
private native boolean nativeMoveCursor(int keyCode,int count,boolean noScroll);
private native int nativeMoveGeneration();
private native void nativeMoveSelection(int x,int y);
private native boolean nativePageShouldHandleShiftAndArrows();
private native boolean nativePointInNavCache(int x,int y,int slop);
private native void nativeRecordButtons(boolean focused,boolean pressed,boolean invalidate);
private native void nativeResetSelection();
private native Point nativeSelectableText();
private native void nativeSelectAll();
private native void nativeSelectBestAt(Rect rect);
private native void nativeSelectAt(int x,int y);
private native int nativeSelectionX();
private native int nativeSelectionY();
private native int nativeFindIndex();
private native void nativeSetExtendSelection();
private native void nativeSetFindIsEmpty();
private native void nativeSetFindIsUp(boolean isUp);
private native void nativeSetHeightCanMeasure(boolean measure);
private native void nativeSetBaseLayer(int layer,Region invalRegion,boolean showVisualIndicator,boolean isPictureAfterFirstLayout,boolean registerPageSwapCallback);
private native int nativeGetBaseLayer();
private native void nativeShowCursorTimed();
private native void nativeReplaceBaseContent(int content);
private native void nativeCopyBaseContentToPicture(Picture pict);
private native boolean nativeHasContent();
private native void nativeSetSelectionPointer(boolean set,float scale,int x,int y);
private native boolean nativeStartSelection(int x,int y);
private native void nativeStopGL();
private native Rect nativeSubtractLayers(Rect content);
private native int nativeTextGeneration();
private native void nativeRegisterPageSwapCallback();
private native void nativeTileProfilingStart();
private native float nativeTileProfilingStop();
private native void nativeTileProfilingClear();
private native int nativeTileProfilingNumFrames();
private native int nativeTileProfilingNumTilesInFrame(int frame);
private native int nativeTileProfilingGetInt(int frame,int tile,String key);
private native float nativeTileProfilingGetFloat(int frame,int tile,String key);
private native void nativeUpdateCachedTextfield(String updatedText,int generation);
private native boolean nativeWordSelection(int x,int y);
static final int NO_LEFTEDGE=-1;
native int nativeGetBlockLeftEdge(int x,int y,float scale);
private native void nativeUseHardwareAccelSkia(boolean enabled);
private native int nativeScrollableLayer(int x,int y,Rect scrollRect,Rect scrollBounds);
private native boolean nativeScrollLayer(int layer,int newX,int newY);
private native void nativeSetIsScrolling(boolean isScrolling);
private native int nativeGetBackgroundColor();
native boolean nativeSetProperty(String key,String value);
native String nativeGetProperty(String key);
private native void nativeGetTextSelectionRegion(Region region);
private static native void nativeOnTrimMemory(int level);
}
